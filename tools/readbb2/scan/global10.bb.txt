; ascii translation of /Users/simon/Google Drive/amiga/w/skid2/mag/map/global10.bb
Use ##[$8526] 0
dt.w=0:shap.b=0:sx=100:sy=100:fi=10:fj=10:origh=100
t$="start"
#maxpost=300:#maxedge=200:#maxngon=40
#dp=48:curb.b=0

g$=""; m$=??!?


DEFTYPE .w i,j

#MaxNam=24
Dim nam.s(#MaxNam),com.s(#MaxNam)

NEWTYPE .frend
	lti.q:ltj
	rti.q:rtj
	lsx.w:lsy
	rsx.w:rsy
	lpost.w:rpost.w

	lb.q:mb:rb
	lh	:mh:rh

	go.w
End NEWTYPE

NEWTYPE .grunt
	i.q:j:k:sx.w:sy
End NEWTYPE
Dim gr.grunt(14):*tgr.grunt=gr(0)

Dim con.frend(200):condt.l=&con(0)

Dim map.w(63,63),changed.b(63,63):maptr.l=&map(0,0)
Dim import.w(63,63)
Dim lsx(8),lsy(8),lsz(8)

NEWTYPE .spl
	a.q:b ;:c:d
End NEWTYPE
Dim fish.spl(2)


Statement SetIt{i.w,j.w}
Shared changed()
	If (i>0) AND (i<64)
		If (j>0) AND (j<64)
			If (changed(i,j)=0) OR (changed(i,j)=3) Then changed(i,j)=2
		EndIf
	EndIf
End Statement

MaxLen p$=169:MaxLen f$=64

#wid=130:#defwid=2000:#defhwid=1000
LoadSound 0,"brass2"
casestrcomp 0,g$+"cup1.iff"

LoadShape 0,g$+"pt.pt":GetaSprite 0,0
LoadShape 0,g$+"pt.up":GetaSprite 1,0:GetaSprite 6,0
LoadShape 0,g$+"pt.dn":GetaSprite 2,0:GetaSprite 7,0
LoadShape 0,g$+"pt.sl":GetaSprite 3,0:GetaSprite 5,0
LoadShape 0,g$+"pt.ax":GetaSprite 4,0
	:; NB, 5 = slider as well!
LoadShape 50,g$+"star":DecodeShapes 50
Free MidHandle 0:direct=0

Gosub GetMap
BLITZ:BlitzKeys On:SetInt 5:End SetInt

NEWTYPE .rend
	x.w:y.w
End NEWTYPE
Dim tri.rend(12):ad.l=&tri(0)

NEWTYPE .post
	active.b
	i.q:j.q:k.q:sx.w:sy.w
	edge.w[12]:dest.w[12]
	blend.w
End NEWTYPE
Dim peg.post(#maxpost)
*tpost.post=peg(0):*npost.post=peg(1):stt.w=0:fin.w=0
*gpost.post=peg(2):*hpost.post=peg(3)
*fpost.post=peg(stt):*spost.post=peg(fin)
For cnt.w=0 To #maxpost:peg(cnt)\active=0:Next

NEWTYPE .edge
	i.q:j.q:sx.w:sy.w
	stt.w:fin.w:k.q
	lgon.w:rgon.w
	fti.q:ftj
	a.w:b:c
End NEWTYPE
Dim bound.edge(#maxedge):side.w=0:*tedge.edge=bound(side)
*hedge.edge=bound(side)
For cnt.w=0 To #maxedge:bound(cnt)\stt=-1,-1:Next

NEWTYPE .ngon
	active.b
	i.q:j.q:k.q:sx.w:sy.w
	edge.w[12]
End NEWTYPE
Dim area.ngon(#maxngon):sec.w=0:*tgon.ngon=area(sec)
For cnt.w=0 To #maxngon:area(cnt)\active=0:Next

Statement CopCon{src,dest}
	Shared con()
	For i.w=0 To (SizeOf.frend-1) Step 2
		Poke.w &con(dest)+i,Peek.w(&con(src)+i)
	Next
;	con(dest)\lti=con(src)\lti
;	con(dest)\ltj=con(src)\ltj
;	con(dest)\rti=con(src)\rti
;	con(dest)\rtj=con(src)\rtj

End Statement	 ;CopCon

Function.w ddistance{x1.w,y1.w,x2.w,y2.w}

 SUB d2,d0:BPL xpos:NEG d0:xpos
 SUB d3,d1:BPL ypos:NEG d1:ypos
 CMP d0,d1:BEQ kludge
 BMI ygtx:EXG d0,d1:ygtx
 TST d1:BNE yne:AsmExit:yne
 SWAP d1:CLR d1:DIVU d0,d1:LSR#7,d1
 ADD d1,d1:SWAP d0
 DIVU lvals(pc,d1.w),d0:AsmExit
 kludge:MULU #27146,d0:SWAP d0:ADD d1,d0:AsmExit ;multiply by sqrt(2)
 lvals:IncBin "len.inc"
End Function

Function.q rdistance{x1.w,y1.w}
 TST.w d0:BPL xpos2:NEG d0:xpos2				;d0=width
 TST.w d1:BPL ypos2:NEG d1:ypos2				;d1=height
 CMP d0,d1:BEQ kludge2									;kludge if equal
 BMI ygtx2:EXG d0,d1:ygtx2							 ;d0=greater side
 TST d1:BNE yne2
 MOVEQ #1,d1:SWAP d1:DIVS d0,d1:MOVE d1,d0:EXT.l d0:AsmExit
; MOVEQ #1,d1:SWAP d1:DIVU d0,d1:MOVE d1,d0:EXT.l d0:RTS
 yne2								;if short side 0 len=1/other
 SWAP d1:CLR d1:DIVU d0,d1:LSR#7,d1		;look up=short/long
 ADD d1,d1:EXT.l d1:MOVE lvals2(pc,d1.w),d1:DIVU d0,d1
 MOVE d1,d0:EXT.l d0:AsmExit
 kludge2:MULU #27146,d0:SWAP d0:ADD d0,d1
 MOVEQ #1,d0:SWAP d0:DIVS d1,d0:EXT.l d0:AsmExit
 lvals2:IncBin "len.inc"
End Function

Function.w angle{x1.w,y1.w}
	MOVEQ#0,d2
	TST d1:BPL hpos:MOVEQ#16,d2:NEG d1:hpos
	TST d0:BPL wpos:EOR#8,d2:NEG d0:wpos
	CMP d1,d0:BMI notsteep:BNE neq
	MOVE#$2000,d1:BRA flow:neq
	EOR #4,d2:EXG d1,d0:notsteep
	TST d1:BNE noflow:MOVEQ#0,d1:BRA flow:noflow
	EXT.ld0:SWAP d0:DIVU d1,d0:LSR#6,d0:AND#1022,d0
	MOVE arc(pc,d0),d1
	flow:MOVE.l oct(pc,d2),d0:EOR d0,d1:SWAP d0:ADD d1,d0:AsmExit
	oct:Dc.w 0,0,$4000,-1,0,-1,$c000,0
			Dc.w $8000,-1,$4000,0,$8000,0,$C000,-1
	arc:IncBin "arc.inc"
End Function

Function.q hite {di.q,dj.q,oset.l}
	MOVE.l d2,a0
	MOVE.l d1,d2:SWAP d2:EXT.l d2:ASL.l #7,d2:ADD.l d2,a0
	MOVE.l d0,d2:SWAP d2:EXT.l d2:ASL.l #1,d2:ADD.l d2,a0

	MOVEM (a0)+,d2-d3 ;d0-d1 xy d2-d5 p0-p3
	LEA 124(a0),a0:MOVEM (a0)+,d4-d5
				 MOVE d0,d6:MULU d1,d6:SWAP d6:MULU d6,d5	; x. y.p3
	NOT d0:MOVE d0,d6:MULU d1,d6:SWAP d6:MULU d6,d4	;-x. y.p2
	NOT d1:MOVE d0,d6:MULU d1,d6:SWAP d6:MULU d6,d2	;-x.-y.p0
	NOT d0:					 MULU d1,d0:SWAP d0:MULU d3,d0	 ; x.-y.p1
	ADD.l d2,d0:ADD.l d4,d0:ADD.l d5,d0 ;total
	LSR.l#6,d0:AsmExit
End Function

CNIF 1=0
	Function.q hgh{di.w,dj.w}
	;	UNLK a4:CMP.w #32,d0:BLT stl
				MOVE.l $19000000,d0:AsmExit
	;	stl:MOVE.l #25800000,d0:RTS

	End Function
CEND



Macro qhite
	hite{`1,`2,maptr.l}
End Macro
Macro fhite
	6400
;	hgh{`1,`2}
End Macro


Statement FindLo {fldtp.q,flcon.l,flbez.l}

	MOVE.l d0,d3:SWAP d3:MULU #SizeOf.frend,d3:ADD.l d3,d1
	MOVE.l d1,a0:MOVE.l d2,a1

	MOVE d0,d1:MULU d1,d1:SWAP d1:LSR #1,d1
	MOVE d0,d2:NOT d2:MULU d2,d2:SWAP d2:LSR #1,d2
	MOVE d1,d0:NOT d0:SUB d2,d0

	MOVEM.l	(a0),d3-d6
									 ASR.l #7,d3:MULU d2,d3
									 ASR.l #7,d4:MULU d2,d4
									 ASR.l #7,d5:MULU d2,d5
									 ASR.l #7,d6:MULU d2,d6
	LEA	SizeOf.frend(a0),a0
	MOVE.l	 (a0),d7:ASR.l #7,d7:MULU d0,d7:ADD.l d7,d3
	MOVE.l	4(a0),d7:ASR.l #7,d7:MULU d0,d7:ADD.l d7,d4
	MOVE.l	8(a0),d7:ASR.l #7,d7:MULU d0,d7:ADD.l d7,d5
	MOVE.l 12(a0),d7:ASR.l #7,d7:MULU d0,d7:ADD.l d7,d6
	LEA	SizeOf.frend(a0),a0
	MOVE.l	 (a0),d7:ASR.l #7,d7:MULU d1,d7:ADD.l d7,d3
	MOVE.l	4(a0),d7:ASR.l #7,d7:MULU d1,d7:ADD.l d7,d4
	MOVE.l	8(a0),d7:ASR.l #7,d7:MULU d1,d7:ADD.l d7,d5
	MOVE.l 12(a0),d7:ASR.l #7,d7:MULU d1,d7:ADD.l d7,d6
	ASR.l #4,d3:ASR.l #5,d3:ASR.l #4,d4:ASR.l #5,d4
	ASR.l #4,d5:ASR.l #5,d5:ASR.l #4,d6:ASR.l #5,d6
	MOVEM.l d3-d6,(a1):AsmExit
End Statement

Statement FindDif {fldtp.q,flcon.l,flbez.l}

	MOVE.l d0,d3:SWAP d3:MULU #SizeOf.frend,d3:ADD.l d3,d1
	MOVE.l d1,a0:MOVE.l d2,a1

	MOVE d0,d1:MULU d1,d1:SWAP d1:LSR #1,d1
	MOVE d0,d2:NOT d2:MULU d2,d2:SWAP d2:LSR #1,d2
	MOVE d1,d0:NOT d0:SUB d2,d0

	MOVEM.l	(a0),d3-d6
									 ASR.l #7,d3:MULU d2,d3
									 ASR.l #7,d4:MULU d2,d4
									 ASR.l #7,d5:MULU d2,d5
									 ASR.l #7,d6:MULU d2,d6
	LEA	SizeOf.frend(a0),a0
	MOVE.l	 (a0),d7:ASR.l #7,d7:MULU d0,d7:ADD.l d7,d3
	MOVE.l	4(a0),d7:ASR.l #7,d7:MULU d0,d7:ADD.l d7,d4
	MOVE.l	8(a0),d7:ASR.l #7,d7:MULU d0,d7:ADD.l d7,d5
	MOVE.l 12(a0),d7:ASR.l #7,d7:MULU d0,d7:ADD.l d7,d6
	LEA	SizeOf.frend(a0),a0
	MOVE.l	 (a0),d7:ASR.l #7,d7:MULU d1,d7:ADD.l d7,d3
	MOVE.l	4(a0),d7:ASR.l #7,d7:MULU d1,d7:ADD.l d7,d4
	MOVE.l	8(a0),d7:ASR.l #7,d7:MULU d1,d7:ADD.l d7,d5
	MOVE.l 12(a0),d7:ASR.l #7,d7:MULU d1,d7:ADD.l d7,d6
	ASR.l #4,d3:ASR.l #5,d3:SUB.l	 (a1),d3
	ASR.l #4,d4:ASR.l #5,d4:SUB.l	4(a1),d4
	ASR.l #4,d5:ASR.l #5,d5:SUB.l	8(a1),d5
	ASR.l #4,d6:ASR.l #5,d6:SUB.l 12(a1),d6
	MOVEM.l d3-d6,(a1):AsmExit
End Statement

Function.w FindWid {fldtp.q,pta.w,ptb.w,ptc.w}

	MOVE d0,d4:MULU d4,d4:SWAP d4:LSR #1,d4
	MOVE d0,d6:NOT d6:MULU d6,d6:SWAP d6:LSR #1,d6
	MOVE #$7fff,d5:SUB d4,d5:SUB d6,d5

	MULS d6,d1:SWAP d1
	MULS d5,d2:SWAP d2:ADD d2,d1
	MULS d4,d3:SWAP d3:ADD d3,d1
	MOVE d1,d0:AsmExit
End Statement

Function.l Closer{ri,rj,dti,dtj}
	ASR.l #6,d0:ASR.l #6,d1:ASR.l #6,d2:ASR.l #6,d3
	MOVE d2,d4:MOVE d3,d7
	MULS d1,d4:MULS d0,d7:SUB.l d4,d7:ASL.l #4,d7
	MULS d2,d0:MULS d3,d1:ADD.l d1,d0:ASL.l #4,d0
	SWAP d7:MOVE d7,d0:AsmExit
End Function

Function mapx{i,j}
	Function Return (i-j)ASL 4+512+#dp
End Function
Function mapy{i,j}
	Shared maptr
	temp=(i+j)ASL 3-156
	Function Return temp-!qhite{i,j}+#dp
End Function
Function rely{i,j,k}
	Shared maptr
	temp=(i+j)ASL 3-156-k+#dp
	Function Return temp
End Function

Function.w AddPost{}
	Shared peg()
	cnt.w=0
	##[$80BB]
		If peg(cnt)\active=0
			For cot=0 To 11
				peg(cnt)\edge[cot]=-1
				peg(cnt)\dest[cot]=-1
			Next
			peg(cnt)\active=1:##[$80BE] ##[$80BB]:Function Return cnt
		EndIf
		cnt+1
	##[$80BC] cnt=#maxpost
	Sound 0,1
	Function Return -1
End Function

Function.w AddNgon{}
	Shared peg(),bound(),area()
	cnt.w=0
	##[$80BB]
		If area(cnt)\active=0
			For cot=0 To 11
				area(cnt)\edge[cot]=-1
			Next
			area(cnt)\active=1:##[$80BE] ##[$80BB]:Function Return cnt
		EndIf
		cnt+1
	##[$80BC] cnt=#maxngon
	Sound 0,1
	Function Return -1
End Function

Statement SubEdge{stt.w,fin.w}	;needs to be called twice
	Shared bound(),peg(),area()
	*spost.post=peg(stt):*fpost.post=peg(fin)
	For cnt.w=0 To 11
		If *spost\dest[cnt]=fin
			*tedge.edge=bound(*spost\edge[cnt])
			*spost\edge[cnt]=-1:*spost\dest[cnt]=-1

			*tedge\stt=-1:*tedge\fin=-1
		EndIf
	Next
	For cnt.w=0 To 11
		If *fpost\dest[cnt]=stt
			*fpost\edge[cnt]=-1:*fpost\dest[cnt]=-1
		EndIf
	Next
End Statement

Function AddEdge{stt,fin}
	Shared bound(),peg(),maptr.l
	ok=On
	If stt=fin Then ok=Off ;if actually a line..
	*spost.post=peg(stt):*fpost.post=peg(fin)
	For cnt.w=0 To 11			 ; see if line already exists
		If *spost\edge[cnt] > -1
			If *spost\dest[cnt]=fin Then ok=Off
		EndIf
		If *fpost\edge[cnt] > -1
			If *fpost\dest[cnt]=stt Then ok=Off
		EndIf
	Next

;	If NOT ok Then Stop
	cnt=0:adstt.w=-1:adfin.w=-1:nuedge.w=-1
	##[$80BB]
		If *spost\edge[cnt]=-1 Then adstt=cnt
		If *fpost\edge[cnt]=-1 Then adfin=cnt
		cnt+1
	##[$80BC] cnt=11
	cnt=-1
	##[$80BB]
		cnt+1
		If bound(cnt)\stt=-1 Then nuedge=cnt:cnt=#maxedge
	##[$80BC] cnt=#maxedge
	If (nuedge=-1) OR (adfin=-1) OR (addstt=-1) Then ok=Off
;	If NOT ok Then Stop
	yippe
	If ok
		bound(nuedge)\stt=stt:bound(nuedge)\fin=fin
		peg(stt)\edge[adstt]=nuedge
		peg(stt)\dest[adstt]=fin
		peg(fin)\edge[adfin]=nuedge
		peg(fin)\dest[adfin]=stt
		bound(nuedge)\lgon=0
		bound(nuedge)\rgon=0
		bound(nuedge)\i=(peg(stt)\i+peg(fin)\i) ASR 1
		bound(nuedge)\j=(peg(stt)\j+peg(fin)\j) ASR 1
		bound(nuedge)\k=!qhite{bound(nuedge)\i,bound(nuedge)\j}
	Else
		Sound 0,1
		nuedge= -1
	End If
	Function Return nuedge
End Statement

Statement SubPost{post}							:; n.b. doesn't do clean up
	Shared peg(), bound()
	*tpost.post=peg(post)
	*tpost\active=-1
	For cnt=0 To 11
		SubEdge {*tpost\dest[cnt],post}
	Next
End Statement

NEWTYPE.ij
	i.q:j:k:l
End NEWTYPE
bez.ij\i=0:*bez.ij=bez:io.l=&bez

impact.w=AddPost{}:*tpost=peg(impact)
*tpost\active=1,27.5,29.5,0,bigx/2,bigy/2
impact=AddPost{}:*tpost=peg(impact)
*tpost\active=1,27.5,33.5,0,bigx/2,bigy/2
impact=AddPost{}:*tpost=peg(impact)
*tpost\active=1,35.5,33.5,0,bigx/2,bigy/2
impact=AddPost{}:*tpost=peg(impact)
*tpost\active=1,35.5,29.5,0,bigx/2,bigy/2
For cnt.w=0 To 3
	*tpost=peg(cnt)
	*tpost\k=!qhite{*tpost\i,*tpost\j}
Next

dummy=AddEdge{0,1}
dummy=AddEdge{1,2}
dummy=AddEdge{2,3}
dummy=AddEdge{3,0}

sec=AddNgon{}:*tgon=area(sec)
For cnt.w=0 To 3
	*tgon\edge[cnt]=cnt:bound(cnt)\lgon=sec
Next
*tgon\i=(peg(0)\i+peg(1)\i+peg(2)\i+peg(3)\i) ASR 2
*tgon\j=(peg(0)\j+peg(1)\j+peg(2)\j+peg(3)\j) ASR 2
*tgon\k=!qhite{*tgon\i,*tgon\j}
bigx=#dp+1024+#dp:bigy=#dp+516+#dp
lmaxlen 0,bigx,bigy,4
BitMapOutput 0

BitPlanesBitMap 0,8,6
BitPlanesBitMap 0,9,8 ; the blue track
BitPlanesBitMap 0,10,1 ; the background
Use lmaxlen 0

#vs=16000:last.w=1:first.w=1		 :; Queue used by MapEditor
Dim verti.w(#vs),vertj.w(#vs)

Statement AddMunt{i.w,j.w}
Shared last,verti(),vertj()
	last.w+1:If last.w=#vs Then last=0
	verti(last)=i:vertj(last)=j
End Statement

ousei=31:ousej=31:ousex=mapx{ousei,ousej}:ousey=mapy{ousei,ousej}


MaxLen p$=169:MaxLen f$=64:f$="maps/Map6.Xga"
;	f$=FileRequest$("Load which Map?",p$,f$)


Dim top(4)


	Use lmaxlen 0:;Gosub DoControl
Gosub OpenUp
;LoadShapes 0,g$+"backg.shapes"

Dim h(8)

selected.w=3:#post=1:#edge=2:#ngon=3:#lcon=4:#rcon=5:#bdd=6:#grunt=7
changed.b=0:impact.w=-1:imptype.w=#edge

HiRes=Off
Gosub GetNames
t$=nam(sel.w)
Gosub GetExo

selected=3
CNIF 1=0
For cnt.w=0 To 14
	gr(cnt)\i= (cnt ##[$80B9] 3)*5 + 25
	gr(cnt)\j=(Int(cnt/3))*3 + 20
	gr(cnt)\k=102;!qhite{gr(cnt)\i,gr(cnt)\j}
	gr(cnt)\sx=mapx{gr(cnt)\i,gr(cnt)\j}
	gr(cnt)\sy=mapy{gr(cnt)\i,gr(cnt)\j}
Next
CEND

Use lmaxlen 0

;Circle 4,4,4,4,1
;GetaShape 50,0,0,8,8
:Buffer 0,8192:wi=32:wj=32
Gosub Redisplay:Goto Main


.Buttons

	If down=0
		If job =1
			tmy=my
			impact=-1:cnt=0
			##[$80BB]
				*tgon=area(cnt)
				If *tgon\active>0
					If (mx-*tgon\sx)=QLimit(mx-*tgon\sx,-8,8)
						If (my-*tgon\sy)=QLimit(my-*tgon\sy,-8,8)
							impact=cnt:imptype=#ngon
							##[$80BE] ##[$80BB]:Goto out
						EndIf
					EndIf
				EndIf
				cnt+1
			##[$80BC] cnt=#maxngon

			If mode.w<>1	;purple
				cnt=1			;funny case..
				##[$80BB]
					If (mx-con(cnt)\lsx)=QLimit(mx-con(cnt)\lsx,-8,8)
						If (my-con(cnt)\lsy)=QLimit(my-con(cnt)\lsy,-8,8)
							impact=cnt:imptype=#lcon:con(impact)\go=On
							##[$80BE] ##[$80BB]:Goto out
						EndIf
					EndIf
					If (mx-con(cnt)\rsx)=QLimit(mx-con(cnt)\rsx,-8,8)
						If (my-con(cnt)\rsy)=QLimit(my-con(cnt)\rsy,-8,8)
							impact=cnt:imptype=#rcon:con(impact)\go=On

							##[$80BE] ##[$80BB]:Goto out
						EndIf
					EndIf
					cnt+1
				##[$80BC] cnt=(pts.w+2)


				cnt=0
				##[$80BB]
					*tpost=peg(cnt)
					If *tpost\active>0
						If (mx-*tpost\sx)=QLimit(mx-*tpost\sx,-8,8)
							If (my-*tpost\sy)=QLimit(my-*tpost\sy,-8,8)
								impact=cnt:imptype=#post
								If *tpost\active=5 Then imptype=#bdd
								##[$80BE] ##[$80BB]:Goto out
							EndIf
						EndIf
					EndIf
					cnt+1
				##[$80BC] cnt=#maxpost

				cnt=0
				##[$80BB]
					If bound(cnt)\stt>-1
						*tedge=bound(cnt)
						If (mx-*tedge\sx)=QLimit(mx-*tedge\sx,-8,8)
							If (my-*tedge\sy)=QLimit(my-*tedge\sy,-8,8)
								impact=cnt:imptype=#edge
								##[$80BE] ##[$80BB]:Goto out
							EndIf
						EndIf
					EndIf
					cnt+1
				##[$80BC] cnt=#maxedge
			Else ;purple
				impact=-1
				For cnt.w=0 To 14
					*tgr=gr(cnt)
					If (mx-*tgr\sx)=QLimit(mx-*tgr\sx,-8,8)
						If (my-*tgr\sy)=QLimit(my-*tgr\sy,-8,8)
							impact=cnt:imptype=#grunt
						EndIf
					EndIf
				Next
				Goto out
			EndIf	;purple

			impact=-1:Sound 0,1			 ;MISSED!(create ngon!)
			out: ;YAY!
		EndIf
	EndIf
	If down=1
		If impact>-1			;if anything selected
			If job=1		;still held
				If imptype=#lcon OR imptype=#rcon
					If lin$="+" Then selected=impact:Gosub Split:impact=-1:Goto out
					If lin$="-" Then selected=impact:Gosub Erase:impact=-1:Goto out
					If 1=1
						Use lmaxlen 9
						dt=impact-1:col.b=0:Gosub DoCurve:Gosub FindCurve
						dt+1:Gosub DoCurve:impact=dt:Gosub FindCurve
						dt+1:Gosub DoCurve

						If imptype=#lcon
							parta=(mx-con(impact)\lsx) ASR 5
							partb=(my-con(impact)\lsy) ASR 4
							desti=parta+partb:destj=partb-parta
							con(impact)\lti+desti
							con(impact)\ltj+destj
							If mode.w=2
								con(impact)\rti=con(impact)\lti
								con(impact)\rtj=con(impact)\ltj
							EndIf

						Else
							parta=(mx-con(impact)\rsx) ASR 5
							partb=(my-con(impact)\rsy) ASR 4
							desti=parta+partb:destj=partb-parta
							con(impact)\rti+desti
							con(impact)\rtj+destj
							If mode.w=2
								con(impact)\lti=con(impact)\rti
								con(impact)\ltj=con(impact)\rtj
							EndIf
						EndIf

						If impact>-1
							col=1
							dt=impact-1:Gosub DoCurve:Gosub FindCurve
							dt+1:Gosub DoCurve:impact=dt:Gosub FindCurve
							dt+1:Gosub DoCurve:Gosub FindCurve
						EndIf
					EndIf
				EndIf
				If imptype=#post			;if a post...
					col.b=0:*tpost=peg(impact)
					Gosub FindPeg
					Gosub DrawVert		 ;erase old
					If direct=0
						cnt=0
						##[$80BB]												;if moved onto another
							If NOT cnt=impact
								*npost=peg(cnt)
								If *npost\active=1	 :; don't include 5 = the track..
									fdi=mx-*npost\sx
									If fdi=QLimit(fdi,-8,8)
										fdi=my-*npost\sy
										If fdi=QLimit(fdi,-8,8)
											nuimpact=cnt
											Gosub Sucker
										EndIf
									EndIf
								EndIf
							EndIf
							cnt+1
						##[$80BC] cnt=#maxpost

						*tpost=peg(impact)
						parta=(mx-*tpost\sx) ASR 5
						partb=(my-*tpost\sy) ASR 4
						*tpost\i+parta+partb:*tpost\j+partb-parta
						*tpost\k=!qhite{*tpost\i,*tpost\j}
					EndIf
					If direct=1 OR direct=2
						*tpost\k=Int((*tpost\k+30-direct*20)/10)*10
						impact=-1
						*tpost\blend=1
					EndIf
					If direct=3
						*tpost\k-(my-*tpost\sy)
						*tpost\blend=1
					EndIf
					If direct=4
						SubPost{impact}
					EndIf

					col=2:Gosub FindPeg
					col=1:Gosub DrawVert	 ; and plant new
				EndIf
				If imptype=#bdd			;if part of track..
					col.b=0:*tpost=peg(impact)
					Gosub FindPeg
					Gosub DrawVert		 ;erase old
					If direct=0
						cnt=0
						##[$80BB]												;if moved onto another
							If NOT cnt=impact
								*npost=peg(cnt)
								If *npost\active=1	 :; don't include 5 = the track..
									fdi=mx-*npost\sx
									If fdi=QLimit(fdi,-8,8)
										fdi=my-*npost\sy
										If fdi=QLimit(fdi,-8,8)
											dummy=AddEdge{cnt,impact}
											If dummy>-1
												impact=cnt
												*tedge=bound(dummy)
												Gosub DrawEdge
											EndIf
										EndIf
									EndIf
								EndIf
							EndIf
							cnt+1
						##[$80BC] cnt=#maxpost
					EndIf
					If direct=1 OR direct=2
						follow=On;ff
						*tpost\k=Int((*tpost\k+30-direct*20)/10)*10
						impact=-1
						*tpost\blend=1
					EndIf
					If direct=3
						*tpost\k-(my-*tpost\sy)
						*tpost\blend=1
					EndIf
					If direct=4
						For dt=0 To pts+4
							If con(dt)\lpost=impact Then con(dt)\lpost=-1
							If con(dt)\rpost=impact Then con(dt)\rpost=-1
						Next
						SubPost{impact}
					EndIf
					col=2:Gosub FindPeg
					col=1:Gosub DrawVert	 ; and plant new
				EndIf
				If imptype=#edge
					col.b=0:*tedge=bound(impact)
					Gosub DrawEdge		 ;erase old
					If direct=0
						impact=AddPost{}:imptype=#post		;CREATE!
						If impact>-1
							col.b=0:Gosub DrawEdge
							stt.w=*tedge\stt:fin.w=*tedge\fin
							*tpost=peg(impact)
							*spost=peg(stt):*fpost=peg(fin)
							*tpost\i=(*spost\i+*fpost\i) ASR 1
							*tpost\j=(*spost\j+*fpost\j) ASR 1
							*tpost\k=!qhite{*tpost\i,*tpost\j}
							SubEdge{stt,fin}
							dummy=AddEdge{stt,impact}
							dummy=AddEdge{impact,fin}
						EndIf
						Goto out
					EndIf
					If direct=1 OR direct=2
						follow=On
						*tedge\k=Int((*tedge\k+30-direct*20)/10)*10
						impact=-1
						follow=Off
					EndIf
					If direct=3
						follow=On
						*tedge\k-(my-*tedge\sy)
						follow=Off
					EndIf
					If direct=4 Then SubEdge{*tedge\stt,*tedge\fin}

					col=1:Gosub DrawEdge	 ; and plant new
				EndIf
				If imptype=#ngon		 ;if an ngon...
					col.b=0:*tgon=area(impact)
					Gosub FindArea

					If direct=0
						cnt=0
						##[$80BB]												;if moved onto another
							*npost=peg(cnt)
							If *npost\active>0
								If (mx-*npost\sx)=QLimit(mx-*npost\sx,-8,8)
									If (my-*npost\sy)=QLimit(my-*npost\sy,-8,8)
	;									 oh dear, moved onto a Point
										area(impact)\active=0
										impact=cnt:imptype=#post
										##[$80BE] ##[$80BB]:Goto damn
									EndIf
								EndIf
							EndIf
							cnt+1
						##[$80BC] cnt=#maxpost

						*tgon=area(impact)
						parta=(mx-*tgon\sx) ASR 5
						partb=(my-*tgon\sy) ASR 4
						fi=parta+partb:fj=partb-parta
						*tgon\i+fi:*tgon\j+fj
						*tgon\k=!qhite{*tgon\i,*tgon\j}
					EndIf
					If direct=1 OR direct=2
						*tgon\k=Int((*tgon\k+30-direct*20)/10)*10
						impact=-1
					EndIf
					If direct=3 Then *tgon\k-(my-*tgon\sy)
					If direct=4 Then *tgon\active=0

					col=3:Gosub FindArea	;stick it back
				EndIf

				If imptype=#grunt		 ;if a mode purple grunt
					col=0:Gosub FindGrunt
					*tgr=gr(impact)

					If direct=1 OR direct=2
						*tgr\k=Int((*tgr\k+30-direct*20)/10)*10
						impact=-1
					EndIf

					If direct=3 Then *tgr\k-(my-*tgr\sy)
;					If direct=4 Then *tgr\active=0

					Gosub ScrGrunt:col=2:Gosub FindGrunt ;stick it back
				EndIf

				damn
			EndIf
			If job=0 Then impact=-1	;HAH!
		EndIf
	EndIf

	If imptype=#grunt
		If job=0
			If down=1
				col=0:Gosub FindGrunt
				Gosub Slaughter
			EndIf
		EndIf
	EndIf



	CNIF 1=0
		If down=2								 ;RMB
			If impact>-1						;selected?
				If job=2					;still held right button..
					If imptype=#post
						col.b=0:*tpost=peg(impact)
						Gosub FindPeg
						Gosub DrawVert		 ;erase old

						*tpost=peg(impact)
						*tpost\k-(my-*tpost\sy)

						col=2:Gosub FindPeg
						col=1:Gosub DrawVert	 ; and plant new

					EndIf

					If imptype=#ngon		 ;if an ngon...
						col.b=0:*tgon=area(impact)
						Gosub FindArea
						*tgon\k-(my-*tgon\sy)
						col=3:Gosub FindArea	;stick it back
					EndIf
				EndIf
				If job=3	;ANNIHALATE
					If imptype=#edge
						*tedge=bound(impact):col=0:Gosub DrawEdge
						SubEdge{stt,fin}
						impact=-1
					EndIf
					If imptype=#post
						*tpost=peg(impact)
						col=0:Gosub DrawVert:Gosub FindPeg
						For coy.b=0 To 11
							side=*tpost\edge[coy]
							If side>-1
								*tedge=bound(side)
								stt=*tedge\stt:fin=*tedge\fin
								SubEdge{stt,fin}
							EndIf
						Next
						*tpost\active=0
						impact=-1
					EndIf
				EndIf
			EndIf
			;christ, wouldn't have a clue!
		EndIf
	CEND
Return
DoMen
	If down=2
		scrl=Off
		plax=Int((topleftx+20)/16)*16:play=Int((toplefty+20)/8)*8-1
		plbx=plax+128:plby=play+128
		Use lmaxlen 0
		GetaShape 0,plax,play,128,128
		Boxf plax,play,plbx,plby,0
		Box plax,play,plbx-1,plby-1,1
		BitMapOutput 0
		Colour 1,0
		For cnt=1 To 12:Gosub DispOpt:Next
		sel.w=-1
		##[$80BB]
			If mx>plax AND mx<plbx :nsel.w=(my-play+1)ASR 3:Else:nsel=-1:EndIf
			If nsel<>sel
				cnt=sel:Colour 1,0:Gosub DispOpt
				sel=nsel
				Colour 0,2:cnt=sel:Gosub DispOpt
			EndIf
		##[$80BC] Joyb(0)=0
		down=0:job=0
		BlitColl 0,plax,play
		scrl=On

	EndIf
	If down=3
		If (impact>-1) AND (imptype=#post) AND (job=3)
			cnt=0
			##[$80BB]												;if moved onto another
				If NOT cnt=impact					 ;add a line
					*npost=peg(cnt)
					If *npost\active>0
						If (mx-*npost\sx)=QLimit(mx-*npost\sx,-8,8)
							If (my-*npost\sy)=QLimit(my-*npost\sy,-8,8)
								dummy=AddEdge{cnt,impact}
								If dummy>-1
									impact=cnt
									*tedge=bound(dummy)
									Gosub DrawEdge
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
				cnt+1
			##[$80BC] cnt=#maxpost
		EndIf
	EndIf
	down=job
	If down=0 Then impact=-1
Return

.DispOpt
	Locate plax ASR 3+0.4,play ASR 3+cnt
	Select cnt
		Case 1:Print "(H)iRes":in$="h"
		Case 2:Print "(R)edraw":in$="r"
		Case 3:Print "(K)ill":in$="k"
		Case 4:Print "(J)oin":in$="j"

		Case 5:Print "(L)oad":in$="l"
		Case 6:Print "(S)ave":in$="s"
		Case 7:Print "(ESC)ape":in$=Chr$(27)
		Case 8:Print "(B)itmap":in$="b"
		Default:in$=""
	End Select
Return

.Keys
	omode.w=mode.w
	If RawStatus($5a) Then mode.w=3
	If RawStatus($5b) Then mode.w=0
	If RawStatus($5c) Then mode.w=2
	If RawStatus($5d) Then mode.w=1
	If mode.w=1 AND omode<>1
		Gosub Protect
		Gosub Match
	EndIf


	oldsilly=newsilly
	newsilly=0
	If RawStatus($38) Then newsilly=1
	If RawStatus($39) Then newsilly=-1
	If oldsilly=0 Then hudif+newsilly
	If hudif>pts3.w Then hudif-pts
	If hudif<2 Then hudif+pts

	If mode.w<>omode.w Then Gosub UpDateSurv

	If in$="" Then in$=Inkey$
	in.w=Asc(in$)
	If in$=Chr$(27) Then done.b=On						 ;escape
	If in$=Chr$(13) Then Gosub Slaughter

	If in$="h" Then HiRes=NOT HiRes: Gosub SetScreen
	If in$="7" Then direct=0
	If in$="4" Then direct=4
	If in$="8" Then direct=1
	If in$="2" Then direct=2
	If in$="5" Then direct=3
	If in$="6" Then direct=5
	If in$="9" Then direct=6
	If in$="3" Then direct=7

	If mode=1 ; purple
		If (in$="]") OR (in$="}") Then Gosub UnMatch:selected+1:Gosub Match
		If (in$="[") OR (in$="{") Then Gosub UnMatch:selected-1:Gosub Match
	EndIf

	If in$=" "			;ADD ngon
		sec=AddNgon{}:*tgon=area(sec):*tgon\i=32:*tgon\j=32
		col=0:Gosub FindArea
		For cnt=0 To 7
			parta=(mx-*tgon\sx) ASR 5
			partb=(my-*tgon\sy) ASR 4
			*tgon\i+parta+partb:*tgon\j+partb-parta
			*tgon\k=!qhite{*tgon\i,*tgon\j}
			Gosub FindArea
		Next
		col=3:Gosub FindArea	;stick it back
	EndIf

	If RawStatus($46)			;neutralise
		di=32:dj=32

		For cnt=0 To 7
			sx=mapx{di,dj}
			sy=100
			sy=rely{di,dj,sy}
			parta=(mx-sx) ASR 5
			partb=(my-sy) ASR 4
			di+parta+partb
			dj+partb-parta
		Next
		map(di,dj)=6400
		changed.b=2
		SetIt{di,dj}
		AddMunt{di,dj}
;		last.w+1:If last.w=#vs Then last=0
;		verti(last)=di:vertj(last)=dj
	EndIf

	If RawStatus($50)	;flatland
		For i.w=0 To 63
			For j.w=0 To 63
				map(i,j)=!fhite{i,j}
				changed(i,j)=1
				import(i,j)=7
					AddMunt{i+1,j	}
					AddMunt{i-1,j	}
					AddMunt{i	,j-1}
					AddMunt{i	,j+1}
			Next
		Next
		##[$80CA] con(cnt)
		For cnt=0 To pts+5

					\lb=0:\mb=0:\rb=0
					\lh=0:\mh=0:\rh=0
		Next
		Gosub Redisplay
	EndIf

	If RawStatus($51)	;Noisy
		For i.w=0 To 63
			For j.w=0 To 63
				map(i,j)=map(i,j)+Rnd(768) ;!fhite{i,j}
				changed(i,j)=1
				import(i,j)=7
					AddMunt{i+1,j	}
					AddMunt{i-1,j	}
					AddMunt{i	,j-1}
					AddMunt{i	,j+1}
			Next
		Next
		Gosub Redisplay
	EndIf


	If in$="f"
		*tgon=area(sec)
		cnt=0
		##[$80BB]
			*tgon=area(cnt)
			If *tgon\active>0
				If (mx-*tgon\sx)=QLimit(mx-*tgon\sx,-8,8)
					If (my-*tgon\sy)=QLimit(my-*tgon\sy,-8,8)
						sec=cnt
						##[$80BE] ##[$80BB]:Goto gotone
					EndIf
				EndIf
			EndIf
			cnt+1
		##[$80BC] cnt=#maxngon
		Sound 0,1:Goto ciao
		.gotone
		*tgon=area(sec)
		Gosub DefGon

		ciao
	EndIf
	If in$="g"
		Gosub InSide
		Gosub Redisplay
	EndIf
	If in$="s" Then Gosub PutExo
	If in$="l"
		Gosub GetNames:t$=nam(sel)
		Gosub GetExo:done=Off
		Gosub OpenUp:Gosub Redisplay
	EndIf
	If in$="r" Then Gosub Redisplay
	If in$="u" Then Gosub UpDateSurv



	If in$="bb"	;was b
		AMIGA
		VWait 20
		BitMapOutput 0
		Locate 0,0:Print t$
		tt$=UnRight$(t$,3)
		SaveBitmap 0,"d1:mp/"+tt$+".iff",0
		VWait 20
		BLITZ
	EndIf

	lin$=in$:in$=""
Return


.Main
done.b=Off:hit.w=Off
##[$80BB]
;	dth.w=pts3.w+0.5+hudif
;	If dth>pts3 Then dth-pts
;	If dth<2 Then dth+pts

;	FindLo{dth,condt,io}
;	Line 0,0,mapx{bez\i,bez\j},mapy{bez\i,bez\j},Rnd(3)

	Use lmaxlen 0:UnBuffer 0
	Use lmaxlen 10
	col.b=1
	If changed.b<>0
		For i.w=0 To 63
			For j.w=0 To 63
				If (changed(i,j)<>0) Then Gosub DrawNode
				changed(i,j)=0
			Next
		Next
		If mode.w=1 Then col=2:Gosub FindGrunt ;purple
	End If
	changed.b=0
	Use lmaxlen 9
	ojob.w=job:job=Joyb(0)
	If direct<>5 Then Gosub Buttons
	Gosub DoMen
	Gosub Keys
	Use lmaxlen 0

		If (direct=5) OR (direct=6) OR (direct=7)
			If job=0
				sx=mapx{wi,wj}
				sy=mapy{wi,wj}:bigoset=mapy{Int(wi),Int(wj)}-sy
				parta=(mx-sx) ASR 6
				partb=(my-sy) ASR 5
				wi+parta+partb
				wj+partb-parta
				Use lmaxlen 0
				BBlit 0,50,mapx{Int(wi),Int(wj)},mapy{Int(wi),Int(wj)}:VWait
			EndIf
			If (job=1)
				wi=Int(wi):wj=Int(wj)
					If direct=5
						sy=mapy{wi,wj}
						map(wi,wj)+(sy-my-bigoset) ASL 6

					EndIf
					If (direct=6)	AND (ojob=0)
						map(wi,wj)=Int((map(wi,wj)+161)/160)*160
					EndIf
					If (direct=7)	AND (ojob=0)
						map(wi,wj)=Int((map(wi,wj)-1)/160)*160
					EndIf


				If (mode.w=3) OR (mode.w=1)	 ; green/purple
					import(wi,wj)=3
					AddMunt{wi+1,wj	}
					AddMunt{wi-1,wj	}
					AddMunt{wi	,wj-1}
					AddMunt{wi	,wj+1}

;					last.w+1:If last.w=vs Then last=0
;					verti(last)=wi:vertj(last)=wj
;					last.w+1:If last.w=vs Then last=0
;					verti(last)=wi+1:vertj(last)=wj+1
;					last.w+1:If last.w=vs Then last=0
;					verti(last)=wi+1:vertj(last)=wj
;					last.w+1:If last.w=vs Then last=0
;					verti(last)=wi:vertj(last)=wj+1
				Else
;					changed(wi	,wj	)=1
;					changed(wi-1,wj	)=1
;					changed(wi	,wj-1)=1
;					changed(wi-1,wj-1)=1
					SetIt{wi	,wj	}
					SetIt{wi-1,wj	}
					SetIt{wi-1,wj-1}
					SetIt{wi	,wj-1}

				EndIf

				changed.b=2
			EndIf
		EndIf
	If last.w<>first.w Then Gosub Munt
	If RawStatus($45) Then done=On
##[$80BC] done
End

.Redisplay
	Use lmaxlen 0
	Boxf 0,0,bigx,bigy,0
;	Boxf bigx,0,bigx,bigy,0
	Use lmaxlen 10
;	Line #dp,#dp,bigx/3,#dp,2

	col=1
	For i=0 To 63:For j=0 To 63
		changed(i,j)=0:Gosub DrawNode
	Next:Next
	Box #dp,#dp,bigx-#dp,bigy-#dp,1
	changed=0
;	For dt=1 To pts.w+1
;		col.b=#unsel
;		If dt=selected Then col=#secol
;		Gosub DoCurve
;	Next

	Use lmaxlen 0
	Gosub UpDateSurv
Return

.NewMap
Return

GetMap
AMIGA

	con(0)\lti=26:con(0)\ltj=26
	con(1)\lti=40:con(1)\ltj=26
	con(2)\lti=40:con(2)\ltj=40
	con(3)\lti=26:con(3)\ltj=40
	con(4)\lti=42:con(4)\ltj=43
	con(5)\lti=28:con(5)\ltj=43
	For cnt=0 To 5
		con(cnt)\rti=con(cnt)\lti+3
		con(cnt)\rtj=con(cnt)\ltj+3
		con(cnt)\lpost=-1:con(cnt)\rpost=-1
	Next
	pts.w=5:pts1.w=pts+1:pts2.w=pts+2
	dest=pts1:src=0:CopCon{src,dest}

	For i=0 To 63
		For j=0 To 63
			If map(i,j)<5 Then map(i,j)=5
			map(i,j)=100 ASL 6
		Next
	Next
Return
BLITZ

.PutExo
BlitzKeys Off:ClrInt 5
QAMIGA:f$=t$+".Pax":p$=m$
	freest 0:##[$FFB5]
	AMIGA
	f$=FileRequest$("Save which Map?",p$,f$)
	If f$<>""
		If ReadMem(0,f$)
			FileOutput 0
			Exists 0,&map(0,0),2*64*64
			Print Mki$(pts)
			##[$80CA] con(i)
			For cnt=0 To pts
				i=cnt;-hudif
;				If i>pts Then i-pts1
;				If i<0 Then i+pts1

				Print Mkq$(\lti)	,Mkq$(\ltj)
				Print Mkq$(\rti)	,Mkq$(\rtj)
				Print Mki$(\lpost),Mki$(con(i)\rpost)
				Print Mkq$(\lb),Mkq$(\mb),Mkq$(\rb)
				Print Mkq$(\lh),Mkq$(\mh),Mkq$(\rh)
			Next
			Exists 0,&peg(0),SizeOf.post*#maxpost
			Exists 0,&bound(0),SizeOf.edge*#maxedge
			Exists 0,&area(0),SizeOf.ngon*#maxngon
			DefaultOutput
			CloseFile 0:VWait 50

		End If
	EndIf
	done=Off
	Goto OpenUp
Return
BLITZ

.GetNames

	BLITZ:FreeSlices
	Slice 0,44,320,256,$fff8,4,8,16,bigx,bigx
	Show 0:DisplayOn

	QAMIGA
	done=Off:BitMapOutput 0:Use lmaxlen 0
	Poke.l Peek.l(Peek.l(4)+276)+184,-1		:; turn errors off!

	##[$80BB]
		If WriteMem (0,"df0:Disk.ID")
			dname$="":trackid.w=0
			FileInput 0
			If NOT DosBuffLen(0)
				fi$=Edit$("",79)
				If fi$="SkidMarks Track Disk"
					done=On
					dname$=Edit$("",79)
					trackid.w=Val(UnRight$(dname$,Instr(dname$,"#")))
					m$="df0:maps/"
				EndIf
			EndIf
			CloseFile 0
			DefaultInput
		Else
			If ##[$BE15]("Maps.Here")
				done=On
				dname$="Tha Hard Disk!"
				trackid.w=999
				m$="";"Maps/"
			EndIf
		EndIf
		If NOT done
			Boxf 0,0,1025,516,0
			Locate 3,3:Print "Please Insert a Track Disk!"
			Locate 3,20:Print "press Fire to continue"

			##[$80BB]
			##[$80BC] (Joyb(0)<>0) OR (Joyb(0)<>0)
		EndIf
	##[$80BC] done=On
	If WriteMem(0,m$+"Maps.Here")
		FileInput 0
		hightrack=0
		##[$80BB]
			fi$=Edit$("",79)
			If fi$<>"-1"
				cnt=QLimit(Instr(fi$," ")-1,0,79)
				If cnt<>0
					nam.s(hightrack)=	 Left$(fi$,cnt)
					com.s(hightrack)=UnRight$(fi$,Instr(fi$,";"))	 :; we pray..
				Else
					nam.s(hightrack)=fi$:com.s(hightrack)=""
				EndIf
				hightrack+1
			EndIf
		##[$80BC] fi$="-1"
		CloseFile 0
		DefaultInput
	Else
		Free lmaxlen 0:AMIGA
		NPrint "Sorry - Could not find Track Data!"
		NPrint " pReSs mOuSebUttON tO ConTinUe.."
		MouseWait:End
	EndIf
	BLITZ
	BitMapOutput 0:Use lmaxlen 0:done=Off
	Boxf 0,0,1024,516,0
	Locate 0,1:Print Centre$(dname$,40)
	For cnt=0 To hightrack
		Locate	3,5+cnt:Print nam.s(cnt)
		Locate 20,5+cnt:Print com.s(cnt)
	Next
	Mouse On:BlitzKeys On:sel=-1:BitPlanesBitMap 0,3,4
	##[$80BB]
		Use lmaxlen 3
		ShowSprite 0,MouseX,MouseY,0
		cnt=Int((MouseY)ASR 3)-5
		If (-1<cnt) AND (cnt<(hightrack))
			Boxf 24,(cnt+5)*8,128,(cnt+5)*8+6,1
		EndIf
		If sel<>cnt
			If (-1<sel) AND (sel<(hightrack))
				Boxf 24,(sel+5)*8,128,(sel+5)*8+6,0
			EndIf
			sel=cnt
		EndIf
		If Joyb(0)<>0
			If (-1<cnt) AND (cnt< (hightrack)) Then done=On
		EndIf
		If RawStatus($45) Then Goto exit
		Use lmaxlen 0
	##[$80BC] done
	Mouse Off:BlitzKeys Off
	BLITZ
	FreeSlices
Return

BLITZ
.GetExo
BlitzKeys Off:ClrInt 5
QAMIGA
		pax.w=Off:extn$=".EXO"
		If ##[$BE15](m$+t$+".PAX") Then extn$=".PAX":pax.w=On

		If WriteMem(0,m$+t$+extn$)
			FileInput 0
			##[$BE14] 0,&map(0,0),2*64*64
			pts=Cvi(Inkey$(2)):pts1.w=pts+1
			For cnt2.w=0 To pts
				cnt.w=cnt2

				If cnt<0 Then cnt+pts1
				If cnt>pts Then cnt-pts1
				##[$80CA] con(cnt)
				\lti=Cvq(Inkey$(4))
				\ltj=Cvq(Inkey$(4))
				\rti=Cvq(Inkey$(4))
				\rtj=Cvq(Inkey$(4))
				\lpost=QLimit(Cvi(Inkey$(2)),0,50)
				\rpost=QLimit(Cvi(Inkey$(2)),0,50)

				\lpost=-1
				\rpost=-1

				If pax
					\lb=Cvq(Inkey$(4)):\mb=Cvq(Inkey$(4)):\rb=Cvq(Inkey$(4))
					\lh=Cvq(Inkey$(4)):\mh=Cvq(Inkey$(4)):\rh=Cvq(Inkey$(4))
				EndIf
;				\lb=0:\mb=0:\rb=0
;				\lh\0:\mh=0:\rh=0

				If \lti<>QLimit(\lti,0,62) Then \lti=32
				If \rti<>QLimit(\rti,0,62) Then \rti=32
				If \ltj<>QLimit(\ltj,0,62) Then \ltj=32
				If \rtj<>QLimit(\rtj,0,62) Then \rtj=32
			Next


			##[$BE14] 0,&peg(0),SizeOf.post*#maxpost
			##[$BE14] 0,&bound(0),SizeOf.edge*#maxedge
			##[$BE14] 0,&area(0),SizeOf.ngon*#maxngon
			DefaultInput
			CloseFile 0:VWait 10
		EndIf
;		For impact.w=0 To pts:Gosub Attach:Next
		dest=pts+1:src=0:CopCon{src,dest}
		dest=pts+2:src=1:CopCon{src,dest}
		dest=pts+3:src=2:CopCon{src,dest}
		dest=pts+4:src=3:CopCon{src,dest}
		pts1.w=pts+1:pts2.w=pts+2
	done=Off
	For cnt.w=0 To 63
		map(0,cnt)=6400
		map(cnt,0)=6400
		map(63,cnt)=6400
		map(cnt,63)=6400
	Next
	Goto OpenUp


BLITZ

CopCon
	con(dest)\rti=con(src)\rti:con(dest)\rtj=con(src)\rtj
	con(dest)\lti=con(src)\lti:con(dest)\ltj=con(src)\ltj
	con(dest)\lpost=con(src)\lpost:con(dest)\rpost=con(src)\rpost
Return

CNIF 1=0
DefCurve
	pts1.w=pts+1:pts2.w=pts+2
	src=pts+1:dest=0:CopCon{src,dest}
	dest=pts+2:src=1:CopCon{src,dest}
	dest=pts+3:src=2:CopCon{src,dest}
	dest=pts+4:src=3:CopCon{src,dest}
	dest=pts+1:src=0:CopCon{src,dest}
	For cnt = 1 To pts1
		mata1=HSin(con(cnt	)\ldir)*16
		mata2=HCos(con(cnt	)\ldir)*16
		matb1=HSin(con(cnt-1)\ldir)*16
		matb2=HCos(con(cnt-1)\ldir)*16
		matc1=con(cnt)\lti-con(cnt-1)\lti
		matc2=con(cnt)\ltj-con(cnt-1)\ltj
		Gosub Solve
		If cnt=2
			Locate 10,10
			NPrint lam*mata1," ",con(cnt )\lti," ",-lam*mata1+con(cnt )\lti," "
			NPrint mu*matb1," ",con(cnt-1)\lti," ",mu*matb1+con(cnt-1)\lti," "
		EndIf
		con(cnt)\ltti=-lam*mata1+con(cnt)\lti
		con(cnt)\lttj=-lam*mata2+con(cnt)\ltj
	Next
	src=pts+1:dest=0:CopCon{src,dest}
	dest=pts+2:src=1:CopCon{src,dest}
	dest=pts+3:src=2:CopCon{src,dest}
	dest=pts+4:src=3:CopCon{src,dest}
Return
CEND


.DrawNode
;Return
	If i<63
		If j<63
			basex=(i-j) ASL 4 +512+#dp
			If basex>-8 AND basex<bigx+8
				lsz0=map(i,j)ASR 6:basey=(i+j)ASL 3-148+#dp
				lsy=basey-lsz0 -8
				If lsy>-16 AND lsy<bigy
					lsz2=map(i	,j+1)ASR 6
					lsz6=map(i+1,j	)ASR 6
					lsz8=map(i+1,j+1)ASR 6

;					Line basex-16+#dp,basey-lsz2+#dp,basex+#dp,lsy+#dp,col
;					Line basex+16+#dp,basey-lsz6+#dp,col

					tri(0)\x=basex	 ,lsy
					tri(1)\x=basex+16,basey-lsz6
					tri(2)\x=basex	 ,basey-lsz8+8
					tri(3)\x=basex-16,basey-lsz2
					Polyf 4,ad.l,0
					Line basex-16,basey-lsz2,basex,lsy,1
					Line basex+16,basey-lsz6,1
				EndIf
			EndIf
		EndIf
	EndIf
Return

RemNode:col=0:changed(i,j)=1:Gosub DrawNode:Return

.OpenUp
BLITZ:BlitzKeys On
Gosub SetScreen
Show 0:Mouse On:MouseArea 0,0,bigx,bigy

SetInt 5
	If HiRes AND (Peek($dff004)>0) Then plus=1 Else plus=0
	mx=MouseX:my=MouseY
	If scrl
		If HiRes=On
			If (mx-topleftx)<32 Then topleftx=mx-32
			If (mx-topleftx)>(640-32) Then topleftx=mx-640+32
			If (my-toplefty)<32 Then toplefty=my-32
			If (my-toplefty)>(512-32) Then toplefty=my-512+32
			topleftx=QLimit(topleftx,0,bigx-640)
			toplefty=QLimit(toplefty,0,bigy-512)
		Else
			If (mx-topleftx)<32 Then topleftx=mx-32
			If (mx-topleftx)>(320-32) Then topleftx=mx-320+32
			If (my-toplefty)<32 Then toplefty=my-32
			If (my-toplefty)>(256-32) Then toplefty=my-256+32
			topleftx=QLimit(topleftx,0,bigx-320)
			toplefty=QLimit(toplefty,0,bigy-256)
		EndIf
	EndIf

	Select mode
		Case 0:Green 0,0,3,0; = Green	= friendly
		Case 3:Green 0,3,0,0; = Red		= nasty contours
		Case 2:Green 0,0,0,3; = blue	 = nasty edges
		Case 1:Green 0,3,0,3; = purple = nice track contours
	End Select

	Show 0,topleftx*hiuse,toplefty+plus
	ShowSprite direct,(mx-topleftx)*hiuse,(my-toplefty)*hiuse,0
End SetInt
Return

SetScreen
	VWait:FreeSlices:scrl=On
	If HiRes=On
		SetBPLCON0 4
		Slice 0,44,640,256,$fff9,4,8,32,bigx*2,bigx*2
		bigxfac=(bigx-640)/bigx
		bigyfac=(bigy-512)/bigy
		hiuse=0.5
	Else
		SetBPLCON0 0
		Slice 0,44,320,256,$fff8,4,8,32,bigx,bigx
		bigxfac=(bigx-320)/bigx
		bigyfac=(bigy-256)/bigy
		hiuse=1
	End If
	Green 1,8,8,8:Green 2,10,10,10
	Green 3,10,3,3:Green 4,10,6,6
	Green 8,10,10,15

Return


;*impost<=>nuimpact, *Tpost<=> impact
Sucker
	col.b=0
	*tpost=peg(nuimpact):Gosub DrawVert:Gosub FindPeg
;	*tpost=peg(	impact):Gosub DrawVert
	SubEdge{impact,nuimpact}
	For cot=0 To 11
		side.w=*npost\edge[cot]
		If side > -1
			*tedge=bound(side)
			stt=*tedge\stt:fin=*tedge\fin
			If (stt<>impact) AND (stt<>nuimpact)
				dummy=AddEdge{	impact,stt}
				SubEdge{nuimpact,stt}
			EndIf
			If (fin<>impact) AND (fin<>nuimpact)
				dummy=AddEdge{	impact,fin}
				SubEdge{nuimpact,fin}
			EndIf
		EndIf
	Next
	SubEdge{impact,nuimpact}
	peg(nuimpact)\active=0:*tpost=peg(impact)
Return

.UpDateSurv
Use lmaxlen 8:Boxf 0,0,bigx,bigy,0;:Boxf bigx ASR 1,0,bigx,bigy,0
Use lmaxlen 9:Boxf 0,0,bigx,bigy,0;:Boxf bigx ASR 1,0,bigx,bigy,0
col=1
For impact=1 To pts+1
	dt=impact:Gosub DoCurve
	dt=impact:Gosub FindCurve
Next

Use lmaxlen 8:col=3
For cnt.w=0 To #maxngon
	If area(cnt)\active=1
		*tgon=area(cnt)
		Gosub FindArea
	EndIf
Next
col=2
If mode.w<>1	;purple
	For cnt.w=0 To #maxpost
		If peg(cnt)\active=1		:;the edges are handled by FindCurve..
			*tpost=peg(cnt)
			Gosub FindPeg
		EndIf
	Next
	col=1

	For cnt.w=0 To #maxedge
		*tedge=bound(cnt)
		If *tedge\stt>-1
			If peg(*tedge\stt)\active>0
				Gosub DrawEdge
			EndIf
		EndIf
	Next
EndIf

For cnt.w=0 To #maxngon
	*tgon=area(cnt)
	If *tgon\active=2 OR *tgon\active=1 Then Gosub FindArea
Next

If mode.w=1 Then col=2:Gosub FindGrunt ;purple

Use lmaxlen 0
Return

Macro lline
	Line bez\i,bez\j,bez\k,bez\l,col
End Macro

.ScrGrunt
	For cnt=0 To 14	;sel.w=selected To selected+3
		gr(cnt)\sx=mapx{gr(cnt)\i,gr(cnt)\j}
		gr(cnt)\sy=rely{gr(cnt)\i,gr(cnt)\j,gr(cnt)\k}
	Next
Return

.FindGrunt
	Use lmaxlen 8

	For cnt=0 To 14
		Use lmaxlen 8
		bez\i=gr(cnt)\sx,gr(cnt)\sy
		bez\k=mapx{gr(cnt)\i,gr(cnt)\j},mapy{gr(cnt)\i,gr(cnt)\j}

		Line bez\i,bez\j,bez\k,bez\l,col
		Use lmaxlen 9
		Circle bez\i,bez\j,6,col ASR 1
	Next

	Use lmaxlen 8
	For cnt=0 To 4
		cntt.w=cnt*3
		bez\i=gr(cntt)\sx,gr(cntt)\sy:			 cntt+1
		bez\k=gr(cntt)\sx,gr(cntt)\sy:!lline:cntt+1
		bez\i=gr(cntt)\sx,gr(cntt)\sy:!lline

		If cnt<3
			cntt.w=cnt
			bez\i=gr(cntt)\sx,gr(cntt)\sy:			 cntt+3
			bez\k=gr(cntt)\sx,gr(cntt)\sy:!lline:cntt+3
			bez\i=gr(cntt)\sx,gr(cntt)\sy:!lline:cntt+3
			bez\k=gr(cntt)\sx,gr(cntt)\sy:!lline:cntt+3
			bez\i=gr(cntt)\sx,gr(cntt)\sy:!lline
		EndIf
	Next

	CNIF 1=0
		For cnt=0 To 2
			cntt.w=cnt*3
			bez\i=mapx{gr(cntt)\i,gr(cntt)\j},rely{gr(cntt)\i,gr(cntt)\j,gr(cntt)\k}:			 cntt+1
			bez\k=mapx{gr(cntt)\i,gr(cntt)\j},rely{gr(cntt)\i,gr(cntt)\j,gr(cntt)\k}:!lline:cntt+1
			bez\i=mapx{gr(cntt)\i,gr(cntt)\j},rely{gr(cntt)\i,gr(cntt)\j,gr(cntt)\k}:!lline

			cntt.w=cnt
			bez\i=mapx{gr(cntt)\i,gr(cntt)\j},rely{gr(cntt)\i,gr(cntt)\j,gr(cntt)\k}:			 cntt+3
			bez\k=mapx{gr(cntt)\i,gr(cntt)\j},rely{gr(cntt)\i,gr(cntt)\j,gr(cntt)\k}:!lline:cntt+3
			bez\i=mapx{gr(cntt)\i,gr(cntt)\j},rely{gr(cntt)\i,gr(cntt)\j,gr(cntt)\k}:!lline
		Next
	CEND
Return

.Attach
;	attaches left AND right To dt..
	If con(impact)\lpost=-1
		stt=AddPost{}
		If stt>-1
			con(impact)\lpost=stt
			*spost=peg(stt)
			*spost\active=5
			*spost\k=100
;			*spost\edge[0]=dt
		EndIf
	EndIf
	If con(impact)\rpost=-1
		stt=AddPost{}
		If stt>-1
			con(impact)\rpost=stt
			*spost=peg(stt)
			*spost\active=5
			*spost\k=100
;			*spost\edge[0]=dt
		EndIf
	EndIf
Return


DoCurve
	Use lmaxlen 9
	pts1.w=pts+1:pts2.w=pts+2:pts3.w=pts+3
	CopCon{pts1,0}
	For src=1 To 4:CopCon{src,src+pts1}:Next

	If dt<1 Then dt+pts1
	If dt>(pts1) Then dt-(pts1)
	dfirst.b=Off
;	dpri=(con(dt-1)\rti+con(dt)\rti)ASR 1
;	dprj=(con(dt-1)\rtj+con(dt)\rtj)ASR 1
;	dpsx=mapx{dpri,dprj}:dpsy=mapy{dpri,dprj}

	For dtf=dt-1 To dt Step 0.1
;		MOVE #-1,$dff180
		FindLo {dtf.q,condt.l,io.l}
		dtil=bez\i:dtjl=bez\j
		If mode.w=2
			dtir=dtil :dtjr=dtjl
		Else
			dtir=bez\k:dtjr=bez\l
		EndIf


;		dj=(dtj-dprj) ASL 8:di=(dti-dpri) ASL 8
;		dnorm.w=distance{0,0,di,dj}

;		dil=dil/dnorm
;		djl=djl/dnorm

		dsxl=mapx{dtil,dtjl}
		dsyl=mapy{dtil,dtjl}

		dsxr=mapx{dtir,dtjr}
		dsyr=mapy{dtir,dtjr}

		If dfirst
			Line dpsxl,dpsyl,dsxl,dsyl,col
			Line dpsxr,dpsyr,dsxr,dsyr,col
		End If
		dfirst=On

		dpsxl=dsxl:dpsyl=dsyl
		dpsxr=dsxr:dpsyr=dsyr

	Next
	Line dsxr,dsyr,dsxl,dsyl,col
Return

Solve	;solve's a 2x2 system of equations..
	det= mata1*matb2-mata2*matb1
	lam=(matc1*matb2-matc2*matb1)/det
	mu =(matc2*mata1-matc1*mata2)/det
Return

.Split
	pts+1
	For dt=pts+5 To impact Step -1
		dest=dt+1:src=dt:CopCon{src,dest}
	Next
	con(impact)\rti=(con(impact-1)\rti+con(impact)\rti) ASR 1
	con(impact)\rtj=(con(impact-1)\rtj+con(impact)\rtj) ASR 1
	con(impact)\lti=(con(impact-1)\lti+con(impact)\lti) ASR 1
	con(impact)\ltj=(con(impact-1)\ltj+con(impact)\ltj) ASR 1
	con(impact)\lpost=-1:con(impact)\rpost=-1
	col=3
;	Gosub Redisplay
	Gosub UpDateSurv
Return

Erase
	pts-1
	SubPost{con(selected)\lpost}:SubPost{con(selected)\rpost}
	For dt=selected To pts+5
		dest=dt:src=dt+1:CopCon{src,dest}
	Next

;	Gosub Redisplay
	Gosub UpDateSurv
Return

.FindCurve
	Use lmaxlen 9

	If mode.w<>1 ;purple

		con(dt)\lsx=mapx{con(dt)\lti,con(dt)\ltj}
		con(dt)\lsy=mapy{con(dt)\lti,con(dt)\ltj}
		Circle con(dt)\lsx,con(dt)\lsy,6,col

		If mode.w<>2 ;blue
			con(dt)\rsx=mapx{con(dt)\rti,con(dt)\rtj}
			con(dt)\rsy=mapy{con(dt)\rti,con(dt)\rtj}
			Circle con(dt)\rsx,con(dt)\rsy,6,col
		EndIf


		If con(dt)\lpost>-1
			stt=con(dt)\lpost
			*tpost=peg(stt)
			*tpost\i=(con(dt)\lti+con(dt+1)\lti) ASR 1
			*tpost\j=(con(dt)\ltj+con(dt+1)\ltj) ASR 1
	;		*tpost\k=!qhite{*tpost\i,*tpost\j}
			Gosub FindPeg
			If mode.w<> 1 Then Gosub DrawVert
		EndIf

		If mode.w<>2
			If con(dt)\rpost>-1
				stt=con(dt)\rpost
				*tpost=peg(stt)
				*tpost\i=(con(dt)\rti+con(dt+1)\rti) ASR 1
				*tpost\j=(con(dt)\rtj+con(dt+1)\rtj) ASR 1
		;		*tpost\k=!qhite{*tpost\i,*tpost\j}
				Gosub FindPeg
				If mode.w <> 1 Then Gosub DrawVert
			EndIf
		EndIf
	EndIf
Return

FindPeg
	Use lmaxlen 8
	If *tpost\active>0
		*tpost\sx=mapx{*tpost\i,*tpost\j}
;		*tpost\k=!qhite{*tpost\i,*tpost\j}
		*tpost\sy=rely{*tpost\i,*tpost\j,*tpost\k}
		Circle *tpost\sx,*tpost\sy,8,col
	Else
;		MOVE #$f0f,$dff180
	EndIf
Return

FindArea
	If *tgon\active>0
		Use lmaxlen 8
		If col=0
			Circle *tgon\sx,*tgon\sy,10,col
			Line *tgon\sx,*tgon\sy,*tgon\sx,mapy{*tgon\i,*tgon\j},col
		EndIf
		*tgon\sx=mapx{*tgon\i,*tgon\j}
		*tgon\sy=rely{*tgon\i,*tgon\j,*tgon\k}
		Circle *tgon\sx,*tgon\sy,10,col
		Line *tgon\sx,*tgon\sy,*tgon\sx,mapy{*tgon\i,*tgon\j},col
	EndIf
Return

DrawVert
	For corp=0 To 11
		If *tpost\edge[corp]>-1
			*tedge=bound(*tpost\edge[corp])
			Gosub DrawEdge
		End If
	Next
Return

DrawEdge
	Use lmaxlen 8
	If col=0
		Circle *tedge\sx,*tedge\sy,4,col
		Line *tedge\sx,*tedge\sy,*tedge\sx,mapy{*tedge\i,*tedge\j},col
	EndIf
	stt.w=*tedge.edge\stt:fin.w=*tedge\fin
	*spost.post=peg(stt):*fpost.post=peg(fin)
	*tedge\i=(*spost\i+*fpost\i) ASR 1
	*tedge\j=(*spost\j+*fpost\j) ASR 1
	If follow
		*tedge\k=!qhite{*tedge\i,*tedge\j}
	EndIf

	div=Int(Abs(*spost\i-*fpost\i)+Abs(*spost\j-*fpost\j))*2
	If div<2 Then div=2
	deli=(*fpost\i-*spost\i)/div
	delj=(*fpost\j-*spost\j)/div
	Line *spost\sx,*spost\sy,*spost\sx,*spost\sy,col
	fdi=*spost\i:fdj=*spost\j
	For cort=0 To div
		Line mapx{fdi,fdj},mapy{fdi,fdj},col
		fdi+deli:fdj+delj
	Next
	Line *fpost\sx,*fpost\sy,col

	*tedge\sx=mapx{*tedge\i,*tedge\j}
	*tedge\sy=rely{*tedge\i,*tedge\j,*tedge\k}
	Circle *tedge\sx,*tedge\sy,4,col
	Line *tedge\sx,*tedge\sy,*tedge\sx,mapy{*tedge\i,*tedge\j},col
Return

DefGon
	bigdist=$7000
	For cnt=0 To 11:*tgon\edge[cnt]=-1:Next
	For cnt=0 To #maxpost
		*gpost=peg(cnt)
		If *gpost\active>0
			dist1=(*tgon\i-*gpost\i) ASR 5
			dist2=(*tgon\j-*gpost\j) ASR 5
			dist=dist1*dist1+dist2*dist2 ;find closest point
			If bigdist>dist
				bigdist=dist
				*tpost=*gpost
			EndIf
		EndIf
	Next
	BitMapOutput 0:Locate 36,23
	 ; *tpost now closest point.. so edge on right forever

	*tgon\active=1:cnt=0:changed.b=1
	While *tgon\active=1
		If cnt=12
			*tgon\active=0:changed.b=1
		Else								;find next point
			near.w=$7fd7			; other side!
			cedge.w=-1
			ti=(*tgon\i-*tpost\i) ASL 4
			tj=(*tgon\j-*tpost\j) ASL 4
			trueang.w=angle{ti,tj}+20
			For cntt.w=0 To 11
				side.w=*tpost\edge[cntt]
				If side>-1
					*hpost.post=peg(*tpost\dest[cntt])
					ti=(*tpost\i-*hpost\i) ASL 4
					tj=(*tpost\j-*hpost\j) ASL 4
					currang.w=angle{ti,tj}-trueang
					If (near>currang)
						near=currang
						cedge.w=side:*gpost.post=*hpost
					EndIf
				EndIf
			Next		 ;hopefully, gpost/cedge contains next..

			If cedge=-1
				*tgon\active=0:changed.b=1
			Else
				If (cnt>0) AND (cedge.w=*tgon\edge[0])
					*tgon\active=2:changed.b=2
				Else
					*tgon\edge[cnt]=cedge
					*tpost=*gpost
				EndIf
			EndIf
		EndIf
		cnt+1
	Wend
	If *tgon\active=0
		col=0:Gosub FindArea
	EndIf

	col=3
	For cnt =0 To 11
		cedge=*tgon\edge[cnt]
		If cedge>-1 Then *tedge.edge=bound(cedge.w):Gosub DrawEdge
	Next:VWait 10:col=1
	For cnt =0 To 11
		cedge=*tgon\edge[cnt]
		If cedge>-1 Then *tedge.edge=bound(cedge.w):Gosub DrawEdge
	Next
	If *tgon\active=0 Then col=0:Else:col=3
	Gosub FindArea
Return

ProcEdge
	For side=0 To #maxedge
		*tedge=bound(side)
		If *tedge\stt>-1

			stt=*tedge\stt:fin=*tedge\fin
			*tedge\fti=(peg(stt)\i-peg(fin)\i)
			*tedge\ftj=(peg(stt)\j-peg(fin)\j)
			*tedge\a=peg(stt)\k ASL 6
			*tedge\c=peg(fin)\k ASL 6
			*tedge\b=(*tedge\a+*tedge\c) ASR 1
			*tedge\b=*tedge\k ASL 6-*tedge\b+*tedge\k ASL 6

		EndIf
	Next
Return

.InSide

			cnt=0
			##[$80BB]
				*tgon=area(cnt)
				If *tgon\active>0
					If (mx-*tgon\sx)=QLimit(mx-*tgon\sx,-8,8)
						If (my-*tgon\sy)=QLimit(my-*tgon\sy,-8,8)
							sec=cnt
							##[$80BE] ##[$80BB]:Goto woosh
						EndIf
					EndIf
				EndIf
				cnt+1
			##[$80BC] cnt=#maxngon
	Return
	woosh

		changed.b=2
		Gosub ProcEdge
		Gosub DefGon
		If changed.b=1 Then Return
		*tgon=area(sec)
		If *tgon\active>0
			For di=0 To 63:For dj=0 To 63
				changed(di,dj)=0
			Next:Next
			SetIt{*tgon\i	,*tgon\j	}
			SetIt{*tgon\i+1,*tgon\j	}
			SetIt{*tgon\i+1,*tgon\j+1}
			SetIt{*tgon\i	,*tgon\j+1}
			##[$80BB]
				changed.b=0
				For di=0 To 63:For dj=0 To 63

					If changed(di,dj)=2
;						MOVE #$0f0,$dff180
						changed.b=2
						dti=(di-*tgon\i)
						dtj=(dj-*tgon\j)
						If (dti<>0) OR (dtj<>0)
							If RawStatus($21)
								##[$80BE] For:##[$80BE] For:##[$80BE] For			;FIX ME
								Goto Bye										 ;Kludge :-)
							EndIf
							cnt=0:drawn.b=Off
							##[$80BB]
								side=*tgon\edge[cnt]
								If side>-1

									*tedge=bound(side)
									stt=*tedge\stt:fin=*tedge\fin

									ioff=(peg(stt)\i-*tgon\i)
									joff=(peg(stt)\j-*tgon\j)

									bot=dti**tedge\ftj- *tedge\fti*dtj
;									MOVE #$0f0,$dff180
									If Abs(bot)>0.01
										top=-dtj*ioff+dti*joff
										mu=top/bot
										If (0<mu) AND (mu<1)	;found seg
											top=(*tedge\ftj*ioff)-(*tedge\fti*joff)
											lambda=top/bot

											If (1<lambda)
												drawn=On

	;											crumb=peg(fin)\k*mu+peg(stt)\k*(1-mu)
												crumb=FindWid{mu,*tedge\a,*tedge\b,*tedge\c}
;												crumb=100 ASL 6
												egg=crumb*(1/lambda)+(*tgon\k ASL 5)*(1-1/lambda)
												map(di,dj)=egg ASL 1
											EndIf
										EndIf
									EndIf
								EndIf
								cnt+1
							##[$80BC] cnt=11 OR drawn
							If drawn
								SetIt{di+1,dj+1}
								SetIt{di	,dj+1}
								SetIt{di-1,dj+1}
								SetIt{di+1,dj	}
								SetIt{di-1,dj	}
								SetIt{di+1,dj-1}
								SetIt{di	,dj-1}
								SetIt{di-1,dj-1}
							EndIf
						EndIf
						changed(di,dj)=1
					EndIf
				Next:Next
			##[$80BC] changed.b=0
		EndIf
	Bye
Return



Function .w findfish{e.l,x.q}
	*f.spl=e
	h.q=*f\b*x+*f\a*(1-x)
	Function Return (h ASL 6)
End Function


.Match
	If selected<1		Then selected+pts1
	If selected>pts2 Then selected-pts1

	sel.w=selected:condt1.l=&con(sel):dtf.q=0

	sel=selected
	For cnt=0 To 14 Step 3
		FindLo{dtf,condt1,io.l}
		gr(cnt	)\i= bez\i						 :gr(cnt	)\j= bez\j
		gr(cnt+1)\i=(bez\i+bez\k) ASR 1:gr(cnt+1)\j=(bez\j+bez\l) ASR 1
		gr(cnt+2)\i=			 bez\k			 :gr(cnt+2)\j=			 bez\l
		dtf+0.5:If dtf=1 Then dtf-1:sel+1:condt1.l=&con(sel)
	Next

	cnt.w=0
	sel.w=selected
	For cnt=0 To 14	;sel.w=selected To selected+3
;		gr(cnt)\sx=mapx{gr(cnt)\i,gr(cnt)\j},mapy{gr(cnt)\i,gr(cnt)\j}
		k=!qhite{gr(cnt)\i,gr(cnt)\j}
		Select cnt ##[$80B9] 6
			Case 0:k+con(sel)\lb
			Case 1:k+con(sel)\mb
			Case 2:k+con(sel)\rb
			Case 3:k+con(sel)\lh
			Case 4:k+con(sel)\mh
			Case 5:k+con(sel)\rh:sel+1
		End Select
		gr(cnt)\k=k
	Next

;	sel.w=selected
;	For cnt=0 To 12
;		gr(cnt)\sx=mapx{gr(cnt)\i,gr(cnt)\j},mapy{gr(cnt)\i,gr(cnt)\j}
;	Next
	 col=2:Gosub ScrGrunt:Gosub FindGrunt
Return

.UnMatch
;	MOVE #-1,$dff180
	col=0:Gosub FindGrunt
	sel.w=selected:condt1.l=&con(sel):dtf.q=0

	sel.w=selected
	For cnt=0 To 14	;sel.w=selected To selected+3
;		gr(cnt)\sx=mapx{gr(cnt)\i,gr(cnt)\j},mapy{gr(cnt)\i,gr(cnt)\j}
		k=gr(cnt)\k-!qhite{gr(cnt)\i,gr(cnt)\j}
		Select cnt ##[$80B9] 6
			Case 0:con(sel)\lb=k
			Case 1:con(sel)\mb=k
			Case 2:con(sel)\rb=k
			Case 3:con(sel)\lh=k
			Case 4:con(sel)\mh=k
			Case 5:con(sel)\rh=k:sel+1
		End Select
	Next

	For cnt=selected To selected+2
		If sel<4	 Then CopCon{sel,sel+pts1}
		If sel>pts Then CopCon{sel,sel-pts1}
	Next
Return

.Slaughter:	; n.b slight bug on start/finish line.. stuffit..
;goto oldslaughter
	For i.w=0 To 63
		For j.w=0 To 63
			changed(i,j)=0
		Next
	Next
	changed(gr( 7)\i,gr( 7)\j)=2
	changed(gr( 4)\i,gr( 4)\j)=2
	changed(gr(10)\i,gr(10)\j)=2

	##[$80BB]
		changed.b=1
		For i.w=0 To 63
			For j.w=0 To 63
				If changed(i,j)=2 Then Gosub GoFish
			Next
		Next
	##[$80BC] changed.b=1

Return


.Protect
	For i.w=0 To 63
		For j.w=0 To 63
			import(i,j)=0
		Next
	Next

	For sel.w=2 To pts2 Step 2
		For i.w=0 To 63
			For j.w=0 To 63
				changed(i,j)=0
			Next
		Next
		dtf=sel+1:FindLo{dtf,condt,io.l}
		ti=(bez\i+bez\k) ASR 1:tj=(bez\j+bez\l) ASR 1

		changed(ti,tj)=2

		##[$80BB]
			changed.b=1
			For i=0 To 63
				For j=0 To 63
					If changed(i,j)=2 Then Gosub GoBait
				Next
			Next
		##[$80BC] changed.b=1
	Next

	changed.b=0
Return

.GoBait

	mindtf=sel:maxdtf=sel+2
	Gosub subdiv:Gosub subdiv:Gosub subdiv
	Gosub subdiv:Gosub subdiv:Gosub subdiv
	dtf=(mindtf+maxdtf)ASR 1
	gotim.w=1
	If mindtf=sel	 Then gotim.w=0
	If maxdtf=sel+2 Then gotim.w=0
	ti=i-bez\i:tj=j-bez\j:If (ti*difi+tj*difj)>0 Then gotim=6
	ti=i-bez\k:tj=j-bez\l:If (ti*difi+tj*difj)<0 Then gotim=8
	If gotim>0
		If gotim=1

			changed.b=5
			changed(i,j)=1

			SetIt{i-1,j-1}
			SetIt{i-1,j	}
			SetIt{i-1,j+1}
			SetIt{i	,j-1}
			SetIt{i	,j+1}
			SetIt{i+1,j-1}
			SetIt{i+1,j	}
			SetIt{i+1,j+1}
		EndIf
		import(i,j)=On
	EndIf

Return


.GoFish
	sel=selected:mindtf=sel:maxdtf=sel+2
	Gosub subdiv:Gosub subdiv:Gosub subdiv
	Gosub subdiv:Gosub subdiv:Gosub subdiv
	dtf=(mindtf+maxdtf) ASR 1
	gotim.w=1

	If mindtf=sel	 Then gotim=0
	If maxdtf=sel+2 Then gotim=0

	ti=i-bez\i:tj=j-bez\j:If (ti*difi+tj*difj)>0 Then gotim=6
	ti=i-bez\k:tj=j-bez\l:If (ti*difi+tj*difj)<0 Then gotim=8

	If gotim>0

		base.w=Int((dtf-sel)ASL 1)*3
		dtf =QFrac((dtf-sel)ASL 1)
		For cnt.w=0 To 2
			fish(cnt)\a=gr(base	)\k:fish(cnt)\b=gr(base+3)\k
			base+1
		Next

		If gotim=1
			changed.b=5
			changed(i,j)=1

			ha.w=findfish{fish(0),dtf}
			hb.w=findfish{fish(1),dtf}
			hc.w=findfish{fish(2),dtf}

			dist=(difi*difi+difj*difj)
			cross.q=(ti*difi + tj*difj)/dist
			map(i,j)=FindWid{cross,hc,hb,ha} ASL 1

			SetIt{i-1,j-1}
			SetIt{i-1,j	}
			SetIt{i-1,j+1}
			SetIt{i	,j-1}
			SetIt{i	,j+1}
			SetIt{i+1,j-1}
			SetIt{i+1,j	}
			SetIt{i+1,j+1}
		Else
			map(i,j)=findfish{fish(gotim-6),dtf}
		EndIf
		import(i,j)=On
		AddMunt{i+1,j	}:AddMunt{i-1,j	}
		AddMunt{i	,j+1}:AddMunt{i	,j-1}
	Else
;		last.w+1:If last.w=vs Then last=0
;		verti(last)=i:vertj(last)=j

	EndIf

Return

.subdiv
	dtf=(mindtf+maxdtf) ASR 1
	FindLo {dtf,condt,io.l}
	ti=bez\i-i:tj=bez\j-j
	difi=bez\i-bez\k:difj=bez\j-bez\l
	If difj*ti>difi*tj Then mindtf=dtf Else maxdtf=dtf
Return


oldslaughter
CNIF 1=0
	pts1.w=pts+1:pts2.w=pts+2
	src=pts+1:dest=0:CopCon{src,dest}
	dest=pts+2:src=1:CopCon{src,dest}
	dest=pts+3:src=2:CopCon{src,dest}
	dest=pts+4:src=3:CopCon{src,dest}

	For selected= 2 To pts2
		If peg(con(selected)\lpost)\blend=1 Then con(selected)\go=On
		If peg(con(selected)\rpost)\blend=1 Then con(selected)\go=On
		If peg(con(selected+1)\lpost)\blend=1 Then con(selected)\go=On
		If peg(con(selected+1)\rpost)\blend=1 Then con(selected)\go=On
		If con(selected)\go
			col=0:dt=selected+1:Gosub DoCurve
		EndIf
	Next

	For selected= 2 To pts2
		If con(selected)\go Then Gosub Cream:con(selected)\go=Off
		peg(con(selected	)\lpost)\blend=0
		peg(con(selected	)\rpost)\blend=0
	Next
;	Gosub Redisplay
	Gosub UpDateSurv

Return

.Cream
	FindLo{(selected+0.5),condt.l,io.l}
	desti=(bez\i+bez\k) ASR 1
	destj=(bez\j+bez\l) ASR 1
	changed(desti,destj)=2
	changed(bez\i,bez\j)=2
	changed(bez\k,bez\l)=2

	For i=1 To 63:For j=1 To 63
		 If changed(i,j)=1 Then changed(i,j)=3
	Next:Next

	stt=con(selected)\lpost:stdsta.w=-1
	If stt>-1
		*spost=peg(stt)
		changed(*spost\i	,*spost\j	)=2
		changed(*spost\i+1,*spost\j	)=2
		changed(*spost\i+1,*spost\j+1)=2
		changed(*spost\i	,*spost\j+1)=2
		For cnt=0 To 11
			If *spost\edge[cnt]>-1
				stdsta.w=*spost\dest[cnt]
			EndIf
		Next
	EndIf
	stt=con(selected+1)\lpost:fidsta.w=-1
	If stt>-1
		*spost=peg(stt)
		changed(*spost\i	,*spost\j	)=2
		changed(*spost\i+1,*spost\j	)=2
		changed(*spost\i+1,*spost\j+1)=2
		changed(*spost\i	,*spost\j+1)=2
		For cnt=0 To 11
			If *spost\edge[cnt]>-1
				fidsta.w=*spost\dest[cnt]
			EndIf
		Next
	EndIf
	If fidsta=-1 Then stdsta=-1
	happy.b=False
	If stdsta>-1
		For cnt=0 To 11
			If peg(fidsta)\dest[cnt]=stdsta Then happy=True
		Next
	EndIf
	If NOT happy Then stdsta=-1

	stt=con(selected)\rpost:stdstb.w=-1
	If stt>-1
		*spost=peg(stt)
		changed(*spost\i	,*spost\j	)=2
		changed(*spost\i+1,*spost\j	)=2
		changed(*spost\i+1,*spost\j+1)=2
		changed(*spost\i	,*spost\j+1)=2
		For cnt=0 To 11
			If *spost\edge[cnt]>-1
				stdstb.w=*spost\dest[cnt]
			EndIf
		Next
	EndIf
	stt=con(selected+1)\rpost:fidstb.w=-1
	If stt>-1
		*spost=peg(stt)
		changed(*spost\i	,*spost\j	)=2
		changed(*spost\i+1,*spost\j	)=2
		changed(*spost\i+1,*spost\j+1)=2
		changed(*spost\i	,*spost\j+1)=2
		For cnt=0 To 11
			If *spost\edge[cnt]>-1
				fidstb.w=*spost\dest[cnt]
			EndIf
		Next
	EndIf
	If fidstb=-1 Then stdstb=-1
	happy.b=False
	If stdstb>-1
		For cnt=0 To 11
			If peg(fidstb)\dest[cnt]=stdstb Then happy=True
		Next
	EndIf
	If NOT happy Then stdstb=-1


	##[$80BB]
		changed.b=1
		For i.w=1 To 62
			For j.w=1 To 62
				If changed(i,j)=2 Then Gosub Mutilate
			Next
		Next
	##[$80BC] changed.b=1 OR Joyb(0)<>0
Return


.Mutilate
	changed(i,j)=1
	lside=512:rside=512:movt=0
	dtf.q=selected+0.5
	Gosub MovIn:Gosub MovIn:Gosub MovIn:Gosub MovIn
	Gosub MovIn:Gosub MovIn:Gosub MovIn:Gosub MovIn

;	last.w+1:If last.w=vs Then last=0
;	verti(last)=i:vertj(last)=j
	If Int(dtf)=selected Then Gosub GetHth
Return

.GetHth
	changed.b=2
	dtp.q=QFrac(dtf):odtp=1-dtp:dtp:odtp
	If (lside>0) AND (rside>0)
		htha= dtp*peg(con(selected+1)\lpost)\k
		htha+odtp*peg(con(selected	)\lpost)\k
		hthb= dtp*peg(con(selected+1)\rpost)\k
		hthb+odtp*peg(con(selected	)\rpost)\k
		changed.b=1
		htha ASR 4:hthb ASR 4
		map(i,j)=(rside*htha+lside*hthb) ;(n.b. ASL 6 ASR 10)
	EndIf
	If (lside<0) AND (stdsta>-1):; aha, off the left edge.. norty
		; assumes stdsta<> fidsta
;		If stdsta=fidsta Then MOVE #$f0f,$dff180
;		If stdsta=0			Then MOVE #$f0f,$dff180
;		If fidsta=0			Then MOVE #$f0f,$dff180
		*spost=peg(fidsta):*tpost=peg(stdsta)
		htha= dtp*peg(con(selected+1)\lpost)\k
		htha+odtp*peg(con(selected	)\lpost)\k
		desti=dtp**spost\i+odtp**tpost\i
		destj=dtp**spost\j+odtp**tpost\j
		hthb =dtp**spost\k+odtp**tpost\k

		dil=desti-dtil:djl=destj-dtjl
		dist1=dil*dil+djl*djl:dil/dist1:djl/dist1

		dir=desti-i:djr=destj-j
		fac=dir*dil+djr*djl

		If (0<fac) AND (fac<1)
			htha*64:hthb*64
			map(i,j)=htha*fac+(1-fac)*hthb					:; hopefully alrady asred..
			changed.b=1
		EndIf
	EndIf

	If (rside<0) AND (stdstb>-1):; aha, off the right edge.. norty
		; assumes stdstb<> fidstb
;		If stdstb=fidstb Then MOVE #$f0f,$dff180
;		If stdstb=0 Then MOVE #$f0f,$dff180
;		If fidstb=0 Then MOVE #$f0f,$dff180
		*spost=peg(fidstb):*tpost=peg(stdstb)
		htha= dtp*peg(con(selected+1)\rpost)\k
		htha+odtp*peg(con(selected	)\rpost)\k
		desti=dtp**spost\i+odtp**tpost\i
		destj=dtp**spost\j+odtp**tpost\j
		hthb =dtp**spost\k+odtp**tpost\k

		dil=desti-dtir:djl=destj-dtjr
		dist1=dil*dil+djl*djl:dil/dist1:djl/dist1

		dir=desti-i:djr=destj-j
		fac=dir*dil+djr*djl

		If (0<fac) AND (fac<1)
			htha*64:hthb*64
			map(i,j)=htha*fac+(1-fac)*hthb					:; hopefully alrady asred..
			changed.b=1
		EndIf
	EndIf

	If changed.b=1	:; SEPERATE LINES OF CODE!!!!!!
		SetIt{i-1,j-1}
		SetIt{i-1,j	}
		SetIt{i-1,j+1}
		SetIt{i	,j-1}
		SetIt{i	,j+1}
		SetIt{i+1,j-1}
		SetIt{i+1,j	}
		SetIt{i+1,j+1}
		changed.b=2
	EndIf
Return
CEND

.MovIn

		proi=i:proj=j
		FindLo{dtf,condt,io}
		dtil=bez\i:dtjl=bez\j:dtir=bez\k:dtjr=bez\l

		lini=(dtil-dtir) ASL 4:linj=(dtjl-dtjr) ASL 4
		qnorm.q=rdistance{lini,linj} ASL 7	 :; reciprocal!
		lini*qnorm:linj*qnorm

		If lside<512
			dpri=(dtil-proi)*qnorm		 :; dist from left of line..
			dprj=(dtjl-proj)*qnorm		 :; normalized..
			lside=dpri*lini+dprj*linj
			rside=1024-lside
		Else
			dpri=(proi-dtir)*qnorm		 :; dist from left of line..
			dprj=(proj-dtjr)*qnorm		 :; normalized..
			rside=dpri*lini+dprj*linj
			lside=1024-rside
		EndIf

		dtg.q=dtf+0.03125:FindDif{dtg,condt,io}
		dil=bez\i:djl=bez\j:dir=bez\k:djr=bez\l
		dmi=(rside*dil+lside*dir)
		dmj=(rside*djl+lside*djr)	:; sum = 1024.. so asr10
		tnorm.q=rdistance{dmi,dmj} ASL 2
		dmj*tnorm:dmi*tnorm
			 :; find the projection
		dki=rside*(i-dtil) + lside*(i-dtir) :; sum = 2048.. so asr11
		dkj=rside*(j-dtjl) + lside*(j-dtjr) :; sum = 2048.. so asr11
		movt=((dki*dmi+dkj*dmj) ASR 9 *tnorm)	 :; hopefully - the distance function returned from the obtuse..
									 ;damping, asr 8 = under critical, asr 9=critical

		dtf+movt		 :; 1/32 asl 8 asr 8

		If (dtf>pts3) Then dtf-pts1
		If (dtf<	 2) Then dtf+pts1
Return



DEFTYPE.w maxsthite,minsthite,maxdghite,mindghite

.fix :
	If (0<i) AND (i<63) AND (0<j) AND (j<63)
		If maxsthite<map(i,j) Then maxsthite=map(i,j)
		If minsthite>map(i,j) Then minsthite=map(i,j)
	EndIf
Return

.fix2
	If (0<i) AND (i<63) AND (0<j) AND (j<63)
		If maxdghite<map(i,j) Then maxdghite=map(i,j)
		If mindghite>map(i,j) Then mindghite=map(i,j)
	EndIf
Return



.Munt
	While first.w<>last.w
		first.w+1:If first.w=#vs Then first=0
		baki=verti(first):bakj=vertj(first)
		If (1<baki) AND (1<bakj) AND (64>baki) AND (64>bakj)
;			MOVE #-1,$dff180
			hite.w=map(baki,bakj):nuhite.w=hite:bnuhite=hite
			SetIt{baki,bakj}
			rebuff.w=Off
			If import(baki,bakj)=0

				maxdghite=6400:mindghite=6400
				maxsthite=6400:minsthite=6400
				i=baki-1:j=bakj-1
							 :Gosub fix2
						j+1:Gosub fix
						j+1:Gosub fix2
				i+1:		Gosub fix
				i+1:		Gosub fix2
						j-1:Gosub fix
						j-1:Gosub fix2
				i-1		:Gosub fix

				If maxsthite>10000 Then maxsthite=6400
				If maxdghite>10000 Then maxdghite=6400
				If minsthite<5 Then minsthite=6400
				If mindghite<5 Then mindghite=6400


				If minsthite<6400
					bnuhite=minsthite+400:rebuff=On
					If bnuhite>6400 Then bnuhite=6400:rebuff=Off
				EndIf

				If mindghite<6400
					tuhite=mindghite+565
					If bnuhite>tuhite Then bnuhite=tuhite:rebuff=On
				EndIf

				If maxsthite>6400
					nuhite=maxsthite-400:rebuff=On
					If nuhite<6400 Then nuhite=6400:rebuff=Off
				EndIf

			 If maxdghite>6400
					tuhite=maxdghite-565
					If nuhite<tuhite Then nuhite=tuhite:rebuff=On
				EndIf


				If QAbs(bnuhite-6400)>QAbs(nuhite-6400) Then nuhite=bnuhite

				If nuhite=map(baki,bakj) Then rebuff=Off
				If nuhite=6400 Then rebuff=Off
				map(baki,bakj)=nuhite

			EndIf

			If rebuff.w
				i=baki-1:j=bakj-1
							 :AddMunt{i,j}
						j+1:AddMunt{i,j}
						j+1:AddMunt{i,j}
				i+1:		AddMunt{i,j}
				i+1:		AddMunt{i,j}
						j-1:AddMunt{i,j}
						j-1:AddMunt{i,j}
				i-1		:AddMunt{i,j}
			Else
;				SetIt{i	,j	}
				SetIt{baki	,bakj-1}
				SetIt{baki-1,bakj	}
				SetIt{baki-1,bakj-1}
			EndIf


		Else
;			MOVE #$f0f,$dff180
		EndIf
		If RawStatus($45) Then ##[$80BE] While:Goto exit
	Wend
	changed.b=2
Return

exit
QAMIGA:Free lmaxlen 0: End


CNIF 1=0
fix
	If (1<i) AND (i<64) AND (1<j) AND (j<64)
		SetIt{i,j}
		dif=hite-map(i,j)
		If Abs(dif)>501
			If import(i,j)
				If refry=0
;					last.w+1:If last.w=vs Then last=0
;					verti(last)=baki:vertj(last)=bakj
					AddMunt{baki,bakj}
					map(baki,bakj)=map(i,j)+Sgn(dif)*500
					If map(baki,bakj)<5 Then map(baki,bakj)=5
				EndIf
				If refry=1
					nuhite=map(i,j)+Sgn(dif)*500
					If hite>6400
						If nuhite<

			Else
;				last.w+1:If last.w=vs Then last=0
;				verti(last)=i:vertj(last)=j
				AddMunt{i,j}
				map(i,j)=hite-Sgn(dif)*500
				If map(i,j)<5 Then map(i,j)=5
			EndIf
		EndIf
	EndIf
Return

fix2
	If (1<i) AND (i<64) AND (1<j) AND (j<64)
		SetIt{i,j}
		dif=hite-map(i,j)
		If Abs(dif)>769
			If import(i,j)
				If refry=0
;					last.w+1:If last.w=vs Then last=0
;					verti(last)=baki:vertj(last)=bakj
					AddMunt{baki,bakj}
					map(baki,bakj)=map(i,j)+Sgn(dif)*768
					If map(baki,bakj)<5 Then map(baki,bakj)=5
				EndIf
			Else
;				last.w+1:If last.w=vs Then last=0
;				verti(last)=i:vertj(last)=j
				AddMunt{i,j}
				map(i,j)=hite-Sgn(dif)*768
				If map(i,j)<5 Then map(i,j)=5
			EndIf
		End If
	End If
Return

Munt
	While first.w<>last.w
;		MOVE #-1,$dff180
		first.w+1:If first.w=vs Then first=0
		baki=verti(first):bakj=vertj(first)

		refry=import(baki,bakj)
		If (1<baki) AND (1<bakj) AND (64>baki) AND (64>bakj)
			hite=map(baki,bakj)
			i=baki-1:j=bakj-1
						 :Gosub fix2
					j+1:Gosub fix
					j+1:Gosub fix2
			i+1:		Gosub fix
			i+1:		Gosub fix2
					j-1:Gosub fix
					j-1:Gosub fix2
					i-1:Gosub fix

		Else
;			MOVE #$f0f,$dff180
		EndIf
	Wend

Return
CEND
