; ascii translation of /Users/simon/Google Drive/amiga/w/sega/shit/dev/dev/new.bb
mytrk.w=11
;--------------------------------------------

.N



#maxcar=7
#contcomp=10
#collisions=On
#bars=Off
#maketri=Off

#uscar=3

#a=1
#j=2
#s=3
#n=4

#c=#s

CNIF #c=#j
	If Peek.w($f00004)=Peek.w($f00004)
		End
	EndIf

CEND


Statement Safe{}
	CNIF #c=#j
		MOVE.l #320000,d0
		toplup
			MOVE d0,$f0002a
			SUBQ.l #1,d0
		BGE toplup
	CEND
	CNIF #c=#a
		For cnt.w=0 To 15
			VWait:Repeat:Until VPos>50:Poke.w $dff180,cnt
		Next
		MouseWait
	CEND
	CNIF #c=#s
		uphere
		MOVE #$8701,$c00004
		MOVE #$8702,$c00004
		MOVE #$8703,$c00004
		MOVE #$8704,$c00004
		MOVE #$8705,$c00004
		MOVE #$8706,$c00004
		MOVE #$8707,$c00004
		MOVE #$8708,$c00004
		BRA uphere
	CEND

End Statement

Macro showblk
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8700,$c00004
	CEND
End Macro
Macro showwht
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8701,$c00004
	CEND
End Macro

Macro showred
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8709,$c00004
	CEND
End Macro

CNIF #c=#j
	BSR initjagos
CEND



Gosub InitOs
Gosub InitMem

Gosub InitVars
bigdone.w=Off
Repeat
	Gosub GetNewTrack
	Gosub SetUpWorld
	Gosub SkidMain
Until bigdone

End

.NTypes

NEWTYPE .quadratic ; x=at*t+bt+c :y=dt*t+et+f
	la.q:ma:lb:lc
	ld	:md:le:lf
	lb1 :lb2		 ;boundaries..
	lstraight.w
	lodd1.w:lodd3.w
	langst.q:langadd.q

	ra.q:na:rb:rc
	rd	:nd:re:rf
	rb1 :rb2
	rstraight.w
	rodd1.w:rodd3.w
	rangst.q:rangadd.q
End NEWTYPE:#hquad=SizeOf.quadratic ASR 1

NEWTYPE .xtra
	cai.q:caj:cbi:cbj:midi:midj	; just for fun
	dai	:daj:dbi:dbj:diri:dirj
	swivi:swivj
	centi:centj	;centre or part-circle
	desti:destj	; destination for computer cars..

End NEWTYPE

NEWTYPE .theader
	nmp.l						;8k+ contours NOT CRUNCHED
	blockmap.l			 ;8k crunched
	blocks.l[8]			;40k+ crunched
End NEWTYPE

NEWTYPE .view
	mx.q:my:sx:sy:px:py:dx:dy	; for new scrlnslc :-)
End NEWTYPE
DEFTYPE.view tempview
CNIF 1=0
	ibm version
	no myview.. sx, sy instead
	no channel.w...
;	CNIF #c=#s NOT in..
	ibmpad.w(10)

CEND

NEWTYPE .car
		 i.q :	 j:k:	 headi:	 headj:headk:	 movi:	 movj:
	swai.q:swaj:	swaheadi:swaheadj:			swamovi:swamovj

	myview.view
	dir.q[0]:head.w:bdir.w:rot.q:qc:qs:jox.q
	pitch.w:roll:mpitch:mroll:lap.w	:control.w:fr.w
	inair.w:channel.w:idle.w:drop.w:warp.w:pos.w:coll.w

CNIF #c=#s
	shady.w:carsn.w:dpth.w:carnum.w
	segapad.w[2]
CELSE
	spr1.l:sprnum1.w:spr2.l:sprnum2.w
CEND

	spdat.l:bnk.w:vehicle.w:carcol.l:colowner.w

	nrev.q:rev.q:vel:traction
	lasttime.w:bestlap.w:tottime.w
	accel.q:engfric:bounce:predef.w

	op1car.l:op2car.l:fp2car.l

	*towed.car:*hanged.car
	disc.w:oldpos.w	;the funky position thingee..

	q.l			 :; Quadrilateral.. the shadow
	retard.q:steering:
	curdt.w:side.w:top.w
	difi.q:difj.q:swiv		 :; normal for if there's a collision..


	score.w:newscore.w:voldpos.w:newwarps.w:numwarps.w
	gravity.q

CNIF 1=0
		 i.q :	 j:k:	 headi:	 headj:headk:	 movi:	 movj:
	swai.q:swaj:	swaheadi:swaheadj:			swamovi:swamovj

	myview.view
	dir.q[0]:head.w:bdir.w:rot.q:qc:qs:jox.q
	pitch.w:roll:mpitch:mroll:lap.w	:control.w:fr.w
	inair.w:channel.w:idle.w:drop.w:warp.w:pos.w:coll.w

	spr1.l:sprnum1.w:spr2.l

	sprnum2.w[0]:shady.w

	spdat.l:bnk.w:vehicle.w:carcol.l:colowner.w

	nrev.q:rev.q:vel:traction
	lasttime.w:bestlap.w:tottime.w
	accel.q:engfric:bounce:predef.w

	op1car.l:op2car.l:fp2car.l

	*towed.car:*hanged.car
	disc.w:oldpos.w	;the funky position thingee..

	q.l			 :; Quadrilateral.. the shadow
	retard.q:steering:
	curdt.w:side.w:top.w
	difi.q:difj.q:swiv		 :; normal for if there's a collision..


	score.w:newscore.w:voldpos.w:newwarps.w:numwarps.w
	gravity.q

;	space.w[10]
CEND
End NEWTYPE
NEWTYPE .shcar :car.w:h.w	:End NEWTYPE

NEWTYPE .ij		:i.q:j:k:l				:End NEWTYPE
NEWTYPE .frend :lti.w:ltj:rti:rtj:End NEWTYPE
NEWTYPE.guide
	mi.q:mj.q
	di:dj
	li:lj
	ri:rj:dtp.q	;is dtp needed?
End NEWTYPE


NEWTYPE .parse
	fi.q:fj:di:dj:i:j	 ; see below
	diri:dirj					 ; artificial!
	boom.w							; if impact with wall
	norm								; normal.w at point(!) (lookup in cos/sins table)
End NEWTYPE


NEWTYPE .ShadPt
	ri0.q:rj0:ri1:rj1:ri2:rj2:ri3:rj3:ri4:rj4:ri5:rj5
	rx0.w:ry0:rx1:ry1:rx2:ry2:rx3:ry3
End NEWTYPE
NEWTYPE .quad	:v0x.w:v0y:v1x:v1y:v2x:v2y:v3x:v3y:End NEWTYPE


NEWTYPE .phrase:a.l:b.l:End NEWTYPE
NEWTYPE .jbmap

	dwidth.w	 ;0
	dheight.w	;2
	iwidth.w	 ;4
	iheight.w	;6

	dtype.w		;8
	depth.w		;10
	pitch.w		;12

	idata.l		;14
	ilink.l		;18

	xpos.w		 ;22
	ypos.w		 ;24
	iscroll.w	;26
	flags.w		;28

	hscale.b	 ;30
	vscale.b	 ;31

	firstphrase.phrase ;32
	secondphrase.phrase
	thirdphrase.phrase

	pixwidth.w
	realflags.l
	bltwidth.w
	blitflags.l

End NEWTYPE





NEWTYPE .sprite
	vp.w
	size.b:splink.b
	spdata.w
	hp.w
End NEWTYPE




.DefTypes
DEFTYPE.w i,j,ipl,pl
DEFTYPE.car *p
DEFTYPE.l sincos
DEFTYPE.l trisize
DEFTYPE.ij bez
DEFTYPE.w pts,pts1,pts2,pts3,pts3
DEFTYPE.parse test

CNIF #c=#j
	DEFTYPE.l bld
	DEFTYPE.jbmap *bmr1,*bmr2,*bmr
	#framecnt=$440		;frames...

CEND

DEFTYPE.ij skidbasememory
DEFTYPE.l skbm



.Consts

	CNIF #c=#s
		;
		; sega megadrive skidmarks code
		;

		; $0000 = 64x32 map	(4096)
		; $1000 = blocks
		; $e000 = sprite pointers (2048)?
		; $f000 = sprites		(640)
		; $f200 = spdata		 (start at #$760)
		; $fc00 = scroll

		#vd=$c00000	;vdp data port
		#cp=$c00004	;vdp control port
		#hv=$c00008	;hv counter

		#wvram=$40000000:#wcram=$c0000000:#wsram=$40000010
		#vram=$0:#cram=$80000000:#vsram=$40000000
		#z80=$a11100:#z80sram=$a00000:#z80dram=$ff8000

		Macro reg #$8000+`1*256:End Macro
		Macro setreg:MOVE.w #$8000+`1*256+`2,cp:End Macro
		Macro setmem:MOVE.l `1,cp:MOVE.w `2,vd:End Macro
		Macro pokemem:MOVE.l `1,cp:Poke.w #vd,`2:End Macro

		NEWTYPE .vp
			sx.q:sy:wid:x.w:y.w			 ;top left
		End NEWTYPE

	#dpth=SizeOf .car\dpth

	Statement bbSegaSprites{vram.l,vp.l,cars.l}
			MOVEM.l a4-a6,-(a7):LEA vd,a4
			ASL.l#2,d0:LSR#2,d0:SWAP d0:BSET#30,d0:MOVE.l d0,4(a4)
			;
			MOVE.l #1,(a4):MOVE.l #0,(a4)								 ;blank link to 1
			;
			MOVE.l d1,a0:MOVE.l d2,d1:BRA gencars ;NOSORT
		sortem:
			MOVEQ#0,d0:MOVE.l d1,a1:MOVE.l(a1)+,a2:MOVE dpth(a2),d2
		nxvals:
			MOVE.l a2,a3:MOVE d2,d3
		wowo:
			MOVE.l (a1)+,d7:BEQ endlist:MOVE.l d7,a2
			MOVE dpth(a2),d2:CMP d2,d3:BPL nxvals
		flip:
			MOVEM.l a2-a3,-8(a1):MOVEQ#-1,d0:BRA wowo
		endlist:
			TST d0:BNE sortem

		Macro car SizeOf .car\`1(a2):End Macro

		gencars:
			MOVE.l d1,a1:MOVEQ#2,d7	 ;a0=vp a1=cars d7=link
		nxcar:
			MOVE.l (a1)+,d6:BEQ duncars:MOVE.l d6,a2	;a2=car
			MOVE.l a0,a3:MOVEQ#3,d5						;a3=vp d7=link
		dovp:
			MOVE #$a00,d6:MOVE.bd7,d6
			MOVEM.l !car{myview+SizeOf.view\sx},d0-d1
			ASR.l#1,d0:MOVE.l d0,d2:ASR.l#1,d2:ADD.l d2,d0
			ASR.l#1,d1:MOVE.l d1,d2:ASR.l#1,d2:ADD.l d2,d1
			ADD.l#$60000,d1:SUB.l #$80000,d0
			SUB.l 4(a3),d1:MOVE !car{carsn},d4:BTST#1,d5:BNE lefto
		righto:
			SUB.l (a3),d0:CMP.l #-24*65536,d0:BMI clipt
			CMP.l 8(a3),d0:BPL clipt:TST.l d0:BPL doit
		plop:
			SUB#$400,d6:BMI clipt:ADDQ#3,d4
			ADD.l#$80000,d0:BMI plop:BRA doit
		lefto:
			SUB.l (a3),d0:CMP.l #-16*65536,d0:BMI clipt
			MOVE.l 8(a3),d2:CMP.l d2,d0:BPL clipt
			SUB.l #16*65536,d2
		clop:
			CMP.l d2,d0:BMI doit:SUB#$400,d6:BMI clipt
			ADD.l#$80000,d2:BRA clop
		doit:
			SWAP d0:ADD 12(a3),d0:SWAP d1:ADD 14(a3),d1
			MOVE d1,(a4):MOVE d6,(a4):MOVE d4,(a4):MOVE d0,(a4)
			ADDQ#3,d6:ADD !car{shady},d1:ADD#9,d4:OR #$6000,d4
			MOVE d1,(a4):MOVE d6,(a4):MOVE d4,(a4):MOVE d0,(a4)
			ADDQ#2,d7:LEA 16(a3),a3:DBRA d5,dovp:BRA people
		clipt:
			MOVE #0,(a4):MOVE d6,(a4):MOVE d4,(a4):MOVE #0,(a4)
			ADDQ#3,d6
			MOVE #0,(a4):MOVE d6,(a4):MOVE d4,(a4):MOVE #0,(a4)
			ADDQ#2,d7:LEA 16(a3),a3:DBRA d5,dovp
		people:
			BRA nxcar
		duncars:
			MOVE.l #0,(a4):MOVE.l #0,(a4)			;end of list
			MOVE.l #0,(a4):MOVE.l #0,(a4)
			MOVE.l #0,(a4):MOVE.l #0,(a4)
			MOVE.l #0,(a4):MOVE.l #0,(a4)

			MOVEM.l (a7)+,a4-a6:AsmExit
	End Statement







	CEND
	CNIF #c=#a
		#sc=2
	CEND





Function .q jsin{a.q} ;0..1=2*pi
Shared sincos.l
	myang=##[$C383](a)ASL 9:ad.l=sincos+((myang&511) ASL 2)
	f=##[$C383](myang):qs=Peek.w(ad	)*(1-f)+Peek.w(ad+4)*f
	Function Return ##[$C583](qs) ASL 1
End Function

Function .q jcos{a.q} ;0..1
Shared sincos.l
	myang=##[$C383](a)ASL 9:ad.l=sincos+((myang&511) ASL 2)
	f=##[$C383](myang):of=1-f
	qc=Peek.w(ad+2)*of+Peek.w(ad+6)*f
	Function Return ##[$C583](qc) ASL 1
End Function


Function.q jsqr{a.q}	;worlds slowest sqr command

	If a=0 Then Function Return 0
	ntry.q=1:try=0

	While ##[$C385](try-ntry)>0.01
		try=ntry:fx=try*try-a
		ntry=try-fx/try*0.5
	Wend
	Function Return try
End Function



Function.l GetMem32{size.l}
	CNIF #c=#j
		MOVEQ #0,d1:ADD.l #16,d0:SysJsr $c002

		ADD.l #31,d0
		AND #$ffe0,d0
		AsmExit
	CELSE
		MOVEQ #0,d1:SysJsr $c002:AsmExit
	CEND
End Function



Function.l GetMem{size.l}
	MOVEQ #0,d1:SysJsr $c002:AsmExit
End Function




.InitMem
	skbm.l=&skidbasememory.ij
	sincos.l=?sincos
	Dim Pl.car(#maxcar)
	*p0.car=Pl(0)

	Dim edge.quadratic(70):*e.quadratic=edge(0)
	Dim grot.xtra(70)		 :*g.xtra		 =grot(0)
	Dim mass.guide(137),firstmass.w(70)	;,leadtime.w(70)

	Dim qsin(63),qcos(63)	 :; look up table for car motion
	For cnt.w=0 To 63
		qcos(cnt)=jcos{cnt/64}
		qsin(cnt)=jsin{cnt/64}
	Next

	*par.parse=test

	Dim shcars.shcar(7):shcar.l=&shcars(0)
	Dim tdist.shcar(7) :tdist.l=&tdist(0)


	CNIF #c=#j
		*bmr1.jbmap=GetMem32{SizeOf.jbmap}
		*bmr2.jbmap=GetMem32{SizeOf.jbmap}
		*bmr.jbmap=*bmr1

		CreateBmap{320,200,3,1,0,*bmr1.jbmap}
		CreateBmap{320,200,3,1,0,*bmr2.jbmap}



		MOVE #$ffff,$f00058
		MOVE.l #$418f418f,$f00058

		MOVE #$6c7,$f00028	 ;RGB!

	CEND

	CNIF #c=#a
		allocst 0,4
		ScreensBitMap 0,0
		BitMapOutput 0:Locate 0,0
	CEND




	CNIF #maketri
		trisize.l=(16*17/2)*8;SizeOf.xy
		tritemp.l=$f1cf80-8-trisize;GetMem{dist.l} ;internal dsp ram!
		Gosub InitLatMem
	CEND


	CNIF #c=#s
		Dim vp.vp(3)
		Dim quadverts.w(16)

		blockmap.l=GetMem{9216+64}
		tkptr.l=Peek.l($ff0004)
		tkbin.l=tkptr+960
;		clist.l=Peek.l($ff0008) ;implied..
;		cars.l=Peek.l(clist+0*4)

		Dim cptr.l(8)
		For cnt.w=0 To #uscar
			cptr(cnt)=&Pl(cnt)
		Next
		Dim spr.sprite(15)
		For ipl=0 To 7
			spr(ipl+8)\vp=$80,10,(ipl+1)&15
			spr(ipl	)\vp=$80,10,(ipl+9)&15
			spr(ipl+8)\spdata=$a770+18*ipl,$f0
			spr(ipl	)\spdata=$e779+18*ipl,$f0
			Pl(ipl)\carsn=$a770+18*ipl +(ipl&1)*$2000
			Pl(ipl)\q=GetMem{288}
		Next

	CEND

Return






;jaguar stuff

CNIF #c=#j
	Macro rungpu
		MOVE.l `1 LSL 2+$f03000,$f02110:MOVE.l #1,$ff8:MOVE.l #1,$f02114
	End Macro

	Macro waitgpu
		'w_g`@:MOVE.l $ff8,d0:BTST #0,d0:BNE 'w_g`@
	End Macro

	Macro rundsp
		MOVE.l `1 LSL 2+$f1b000,$f1a110:MOVE.l #1,$ff0:MOVE.l #1,$f1a114
	End Macro

	Macro waitdsp
		'w_d`@:MOVE.l $ff0,d0:BTST #0,d0:BNE 'w_d`@
	End Macro

	Macro waitblit
		MOVE.l $f02238,d0
		w_b`@
		MOVE.l $f02238,d0:BTST #0,d0:BEQ w_b`@
	End Macro


.JagBlitter

	Include jblit.inc

	Macro bm SizeOf .jbmap\`1(a0):End Macro
	Statement RefrBmap{*bmap.jbmap}
		;
		MOVE.l d0,a0
		;
		MOVE.l !bm{idata},d0:LSR.l#3,d0:MOVEQ#43-32,d2:ASL.l d2,d0
		MOVE.l !bm{ilink},d1:LSR.l#3,d1:MOVE.l d1,d2:LSR.l#8,d2:OR d2,d0
		MOVEQ#24,d2:LSL.ld2,d1
		MOVE !bm{dheight},d2:EXT.l d2:MOVEQ#14,d3:ASL.ld3,d2:OR.ld2,d1
		MOVE !bm{ypos},d2:ASL#3,d2:OR d2,d1:OR !bm{dtype},d1
		MOVEM.l d0-d1,!bm{firstphrase}
		;
		MOVE !bm{iscroll},d0:EXT.l d0:ASL.l#8,d0:ASL.l#3,d0
		OR !bm{flags},d0:ASL.l#6,d0
		MOVE !bm{iwidth},d1:EXT.l d1:ROR.l#4,d1:OR d1,d0
		ROL.l#8,d1:ROL.l#6,d1
		OR!bm{dwidth},d1:ASL.l#3,d1:OR!bm{pitch},d1:ASL.l#3,d1:OR!bm{depth},d1
		ASL.l#8,d1:ASL.l#4,d1:OR !bm{xpos},d1
		MOVEM.l d0-d1,!bm{secondphrase}

		MOVEQ #0,d0:MOVE.w !bm{hscale},d0:ROR.w #8,d0
		MOVE.l d0,!bm{thirdphrase+4}

		;
		AsmExit
		;
	End Statement


	Statement HeadBmap{*bmap1.jbmap}
		ADD.l #32,d0:SWAP d0:MOVE.l d0,$f00020:AsmExit
	End Statement



	Statement BlPoly{*bm.jbmap,dat.l,cols.l}
	Shared bld

		!waitblit
		!waitgpu


		Poke.l $f03f00,dat
		Poke.l $f03f04,cols

		!waitblit
		Poke.l bld		,*bm\idata											;destination
		Poke.l bld+	4,*bm\blitflags;+$10000					;
		Poke.l bld+ $8,##[$C581](*bm\bltwidth,*bm\iheight)	;clip
		Poke.l bld+$10,##[$C581](-24,1)	;step

		!rungpu{0}

	End Statement


	Statement BlRot{*bms.jbmap,*bmd.jbmap,xfac,yfac}	;a2=dest a1=source
	Shared bld

	;	srcxadd=3
	;	desxadd=1

		!waitblit

		Poke.l bld+$24,*bmd\idata					 ;dest
		Poke.l bld+$28,*bmd\blitflags +(1 ASL 16)			;flags
		Poke.l bld+$30,0										;start xy
		temp.l=1 LSL 16										 ;plus one y
		temp=temp+(-*bmd\bltwidth&$ffff)		;minus width
		Poke.l bld+$34,temp


		Poke.l bld,*bms\idata							 ;source
		Poke.l bld+$4,*bms\blitflags +(3 ASL 16)			 ;flags
		Poke.l bld+$8,jin{*bms\bltwidth,*bms\iheight} ;clip x
		Poke.l bld+$c,jin{30,30}										 ;start xy

		pw=*bmd\bltwidth

		xdif=-yfac-pw*xfac
		ydif=xfac-pw*yfac

		Poke.l bld+$10,jin{xdif,ydif}
		Poke.l bld+$14,jfr{xdif,ydif}

		Poke.l bld+$18,0 ;start value! HAH!

		Poke.l bld+$1c,jin{xfac,yfac}
		Poke.l bld+$20,jfr{xfac,yfac}

		Poke.l bld+$3c,(*bmd\iheight ASL 16) + *bmd\bltwidth ;counter

		temp.l=1 + (1 ASL 6)
		temp=temp + (1 ASL 8) +(1 ASL 9)
		temp=temp +(1 ASL 11)
		temp=temp + (1 ASL 23)+ ( 1 ASL 24)
		Poke.l bld+$38,temp


	End Statement


CEND


.IOStuff

	Statement GetJoy{x.l,y.l,butt.l,port.w}
	 CNIF #c=#j

			MOVE.l d0,a0
			MOVE.l d1,a1
			MOVE.l d2,a2
			MOVEQ #0,d3
			MOVEQ #0,d4
			MOVEQ #0,d5

			MOVE #$800e,$f14000:MOVE $f14000,d0
			BTST	#8,d0:BNE notup:ADDQ #1,d4:notup
			BTST	#9,d0:BNE notdo:SUBQ #1,d4:notdo

			BTST #10,d0:BNE notle:ADDQ #1,d3:notle
			BTST #11,d0:BNE notri:SUBQ #1,d3:notri

			MOVE #$800e,$f14000:MOVE $f14002,d0
			BTST #1,d0:BNE notbc:ADDQ #2,d5:notbc
			MOVE #$800b,$f14000:MOVE $f14002,d0
			BTST #1,d0:BNE notba:ADDQ #1,d5:notba


			MOVE.w d3,(a0)
			MOVE.w d4,(a1)
			MOVE.w d5,(a2)
			AsmExit
		CEND
		CNIF #c=#a
			Poke.l x,Joyx(1-port)
			Poke.l y,Joyy(1-port)
			Poke.l butt,Joyb(1-port)
		CEND
		CNIF #c=#s
			temp=##[$C484](port)
			Poke.l x,(temp&4=4)-(temp&8=8)
			Poke.l y,##[$C386]((temp&1=1)-(temp&2=2)+(temp&16=16),-1,1)
			Poke.l butt,0
;		If a AND 1 Then ya=-1
;		If a AND 2 Then ya=1
;		If a AND 4 Then xa=-1:fr=JLimit(fr+1,0,799)		;xa=-1
;		If a AND 8 Then xa=1:fr=JLimit(fr-1,0,799)


		CEND
	End Statement


	Statement MyVWait{}
		CNIF #c=#s
			MOVE #0,$ff0000
			myvbwaitlp:TST $ff0000:BEQ myvbwaitlp:MOVE#0,$ff0000
		CEND
		CNIF #c=#a
			VWait
		CEND

	End Statement


	##[$80CA] *p
Statement UpDateNuPlayer{lup.l} ;	 ;,diff.w ,slidmod.w,speedmod.w,accelmod.w
	Shared cvh(),Pl();*p0,*p7

	For *p.car=Pl(0) To Pl(#maxcar) Step SizeOf.car

			If *p\control=#contcomp Then nlup.l=lup+3:Else nlup=lup
			fric=(Peek.b(nlup) ASR 7)*0.98+0.01

			topspeed=(Peek.b(nlup+1)) ASR 4
			acc=topspeed*(1/fric-1)
			initacc=(Peek.b(nlup+2)) ASR 8
			reta=initacc/acc/fric

			\engfric =fric; ASL 6
			\retard	=reta ASR 3;ASL 6
			\steering=Peek.b(lup+6) ASR 5
			\bounce	=0.5
			\gravity =0.5
			\accel	 =acc	ASR 3;ASL 6
	Next

End Statement


;------------------------------------------------------




.
.SetUpWorld
	lapdir=-1:lapdir2=lapdir ASL 1:lapdir4=lapdir ASL 2
	cmpacc=-1
	cmpacc7=-0.7



	CNIF #maketri
		myang=64

		qs=0.2:qc=0.2
		delta.l=0
		deadx=2
		deady=0

		Gosub InitTris
	CEND

	CNIF #c=#a
		For dtp=2 To pts3 Step 0.1
			FindLo dtp,skbm
			Point bez\i ASL #sc,bez\j ASL #sc,1
			Point bez\k ASL #sc,bez\l ASL #sc,1
		Next
	CEND



;vram
;0=scroll map (1024)
;$1000=blocks
;$e000=spritedata
;


	CNIF #c=#s
		;
		For cnt.w=0 To 31
			##[$C482] ?blank,#vram+cnt*64*2,64				;2048 bytes
		Next

		##[$C482] ?carpalette,#cram+32,32




		For cnt.w=0 To 7
			If *ath.theader\blocks[cnt]<>0
				If Peek.l(*ath\blocks[cnt]+tkbin)<>$43724d21 Then Safe{}
				##[$C387] *ath\blocks[cnt]+tkbin,blockmap.l
				##[$C489] blockmap,#vram+$1000+cnt*8192,4096;Peek.l(*ath\blocks[cnt]+tkbin+6)/2
			Else
				If cnt<3 Then Safe{}
			EndIf
		Next
		##[$C387]	*ath\blockmap+tkbin,blockmap.l
		skidm.l=blockmap+64
		##[$C482] blockmap,#cram+0,16

;		SegaTransfer blocks			,#vram+$1000,32768/2		;32 chars
;		SegaTransfer blocks+32768,#vram+$9000,(blocklen-32768)/2		;32 chars

;		skidm=?testtrack+64

		!setmem{#wvram+$3c000003,#0}						;horizontal
		!setmem{#wvram+$3c020003,#-24*8}

		!setmem{#wsram+$00000000,#0}						;vertical
		!setmem{#wsram+$00020000,#0}

		!setreg{2,0}		 ;map location=0*8192
		!setreg{4,0}		 ;map location=0*8192
		!setreg{5,$70}	 ;sprites location=$e000
		!setreg{11,0}		;scroll=entire screen + no external interupts (8)
		!setreg{12,$89}	;32 cell mode shadows no interlace
		!setreg{13,$4}	 ;hs=$1000;$fc00
		!setreg{16,1}		;64x32 sized map
		!setreg{3,$38}	 ;windowpos= $e000
		!setreg{17,$0};$8a}
		!setreg{18,$0};$ff}

		vv=1

		x=0:y=0:xa=1:ya=0

		fr.l=750
	CEND


	Gosub DoPal

	CNIF #c=#j
		LEA vbdb(pc),a0:MOVEQ #1,d0:BSR initvbint:BSR vbinton
	CEND


	*p=Pl(0):Gosub SetStartCar
	*p=Pl(1):Gosub SetStartCar
	Gosub PlaceNorm
	UpDateNuPlayer{?cardiff+8*2}



Return

;testtrack
;IncBin "rat:track.1"



.PlaceCar	;i,j,fr,mycar.w
	CNIF #c=#a
		Circle ii ASL #sc,jj ASL #sc,3,mycar.w+2
	CEND
	CNIF #c=#s
		spr(mycar.w+8)\hp=##[$C386](116+##[$C487](*p\myview\sx)-scrx,$40,$1e9)
		spr(mycar.w+8)\vp=134+##[$C487](*p\myview\sy)-scry

		spr(mycar)\vp=spr(mycar+8)\vp+*p\shady
		spr(mycar)\hp=spr(mycar+8)\hp


	CEND

Return



.NewScrMode
CNIF #c=#s
	!setreg{0,$04} ;disable vert int

	MyVWait{}
	MyVWait{}
	MyVWait{}
	MyVWait{}
	MyVWait{}
	##[$C48A] On


	For cnt.w=0 To 31
		##[$C482] ?blank,#vram+cnt*64*2,64				;2048 bytes
	Next





	Select screenmode
		Case 0:scrw=320 :scrh=240	:blkh.w=31
		Case 1:scrw=160 :scrh=240	:blkh.w=31
		Case 2:scrw=320 :scrh=120	:blkh.w=16
		Case 3:scrw=160 :scrh=120	:blkh.w=16
	End Select

	vp(0)\wid=scrw,128		,128
	vp(2)\wid=-24,128+160,128
	vp(1)\wid=-24,128		,128+120
	vp(3)\wid=-24,128+160,128+120



	If screenmode>1
		 !setreg{0,$14}	;split vertical
		 !setreg{10,119}

		 vp(1)\wid=scrw
	Else
		 !setreg{0,$04}
		 If screenmode=1 Then vp(2)\wid=scrw
	EndIf
	If screenmode=3 Then vp(2)\wid=scrw:vp(3)\wid=scrw

	scrwh=scrw ASR 1:scrhh=scrh ASR 1

	##[$C48A] Off
	MyVWait{}
CEND

Return


#bars=On;ff
.
.SkidMain

	done.w=Off
	myfrcnt.w=3
	For ipl.w=0 To #maxcar
		Pl(ipl)\idle=-1
		Pl(ipl)\inair=Off
		Pl(ipl)\drop=On
		Pl(ipl)\control=#contcomp
		Pl(ipl)\coll=-1
		CNIF #c=#s
			Pl(ipl)\carnum=(##[$8481](ipl,blobbyish)*100)&7:blobbyish+0.325
		CEND
	Next
	Pl(0)\control=0
	Pl(1)\control=1

	Gosub NewScrMode

		MyVWait{}
		MyVWait{}
		MyVWait{}

	CNIF #c=#s
		Dim hisview.view(3)
	CEND




	Repeat


		CNIF #c=#s
			Gosub DoSegaGfx1
		CEND

		MyVWait{}

		CNIF #c=#s
			Gosub DoSegaGfx2
		CEND


;		a.l=$1f62aa:*p0\i=Peek.q(&a)
;		a.l=$1f54ef:*p0\j=Peek.q(&a)
;		a.l=$1f62aa:*p0\movi=0
;	 a.l=$1f54ef:*p0\movj=0
;		a.l=-$0d345:*p0\headi=Peek.q(&a)
;		a.l=	$54ef:*p0\headj=Peek.q(&a)


;		Locate 1,1:Print Hex$(Peek.l(&*p0\i))
;		Locate 1,2:Print Hex$(Peek.l(&*p0\j))


		GetJoy{&sjoxa.l,&sjoya.l,&sbutt.l,0}
		GetJoy{&sjoxb.l,&sjoyb.l,&sbutt.l,1}

		myfrcnt.w=(myfrcnt.w+1)&3



		CNIF #collisions
			Gosub Crash
		CEND

		For ipl.w=0 To #uscar
			*p=Pl(ipl):mynxcnt.w=(myfrcnt+ipl)&3
			Select *p\control
				Case 0:jox=sjoxa:joy=sjoya
				Case 1:jox=sjoxb:joy=sjoyb
			End Select
			If (mynxcnt&2)=0 Then Gosub SpinIt:Gosub DrawShadow
			If mynxcnt=0 Then Gosub MoveIndiv
		Next


;		*p=Pl(1):mynxcnt.w=(myfrcnt.w+0)&3:jox=sjoxb:joy=sjoyb
;		If (mynxcnt&2)=0 Then Gosub SpinIt:Gosub DrawShadow
;		If mynxcnt=0 Then Gosub MoveIndiv


		CNIF #c=#a
			If Joyb(0)<>0 Then done=On
		CEND



		Gosub CheckWallLatent

		MoveAll *p0,shcar,#uscar



;		For mycar=0 To #uscar
;			*p=Pl(mycar)
;			Gosub PlaceCar
;		Next
;		*p=Pl(1):mycar=1
;		Gosub PlaceCar



		CNIF #c=#a
			If Joyb(0)<>0 Then done=On:bigdone=On
		CEND

	Until done
	CNIF #c=#s
		!setreg{0,$04} ;disable vert int
	CEND
Return



CNIF #c=#s
	.DoSegaGfx1

		For cnt.w=0 To 3
			*v.view=hisview(cnt)
			*v\sx=##[$C487](MapX(Pl(cnt)\i,Pl(cnt)\j))
			*v\sy=##[$C487](MapY(Pl(cnt)\i,Pl(cnt)\j,skbm))
			*v\mx=((*v\sx-*v\px)ASR 1 +*v\mx)ASR 2:*v\px+*v\mx
			*v\my=((*v\sy-*v\py)ASR 1 +*v\my)ASR 2:*v\py+*v\my
			vp(cnt)\sx=##[$C386](*v\sx+*v\sx-*v\px-scrwh,0,768-scrw)
			vp(cnt)\sy=##[$C386](*v\sy+*v\sy-*v\py-scrhh,0,384-scrh)
		Next


		If screenmode=2
			Poke.w $ff0020, (vp(1)\sy &7)+8;-15*8
			Poke.w $ff0022, (vp(1)\sy &7)+8;-15*8
			Poke.w $ff0024,-(vp(1)\sx &7)
			Poke.w $ff0026,-(vp(1)\sx &7);+(64-21)*8
			Poke.l $ff0028,3	;sprite link
		EndIf
		If screenmode=3
			Poke.w $ff0020, (vp(1)\sy &7)+8;-15*8
			Poke.w $ff0022, (vp(3)\sy &7)+8;-15*8
			Poke.w $ff0024,-(vp(1)\sx &7)
			Poke.w $ff0026,-(vp(3)\sx &7)+(64-21)*8
			Poke.l $ff0028,3	;sprite link
		EndIf


		If ##[$C484](0)&128<>0
			screenmode=(screenmode+1)&3
			Gosub NewScrMode

		EndIf
		If ##[$C484](0)&32<>0
			done=On
			mytrk.w=mytrk.w+1
			If mytrk=24 Then mytrk=0
			Repeat:Until ##[$C484](0)&32=0
		EndIf

		If ##[$C484](0)&64<>0
			Pl(0)\carnum=Pl(0)\carnum+1
			If Pl(0)\carnum=8 Then Pl(0)\carnum=0
			Pl(1)\carnum=Pl(1)\carnum+1
			If Pl(1)\carnum=8 Then Pl(1)\carnum=0
			Pl(2)\carnum=Pl(2)\carnum+1
			If Pl(2)\carnum=8 Then Pl(2)\carnum=0
			Pl(3)\carnum=Pl(3)\carnum+1
			If Pl(3)\carnum=8 Then Pl(3)\carnum=0
			Repeat:Until ##[$C484](0)&64=0
		EndIf



		mptl.l=skidm+##[$C381](vp(0)\sx LSR 3)ASL1+##[$C381](vp(0)\sy LSR 3)*192;96*2

		If (screenmode&1)=1 ;split horizontal..
			mptr.l=skidm+##[$C381](vp(2)\sx LSR 3)ASL1+##[$C381](vp(2)\sy LSR 3)*192;96*2
		EndIf

		If screenmode=2
			 mptla.l=skidm+##[$C381](vp(1)\sx LSR 3)ASL1+##[$C381](vp(1)\sy LSR 3)*96*2
		EndIf
		If screenmode=3
			mptla.l=skidm+##[$C381](vp(1)\sx LSR 3)ASL1+##[$C381](vp(1)\sy LSR 3)*96*2
			mptra.l=skidm+##[$C381](vp(3)\sx LSR 3)ASL1+##[$C381](vp(3)\sy LSR 3)*96*2
		EndIf



	Return


	.DoSegaGfx2
		bbSegaSprites{$e000,&vp(0),&cptr(0)}

		If (screenmode&1)=0
			##[$C485] mptl,0,41,blkh
			!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
			!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical

			If screenmode=2
				##[$C485] mptla,16*64*2					,41,blkh
			EndIf

		Else
			##[$C485] mptl,0				,21,blkh
			##[$C485] mptr,(64-22)*2,21,blkh
			!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
			!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical
			!pokemem{#wvram+$10020000,-(vp(2)\sx AND 7)+(64-21)*8} ;horizontal
			!pokemem{#wsram+$00020000, (vp(2)\sy AND 7)}					 ;vertical

			If screenmode=3
				##[$C485] mptla,16*64*2					,21,blkh
				##[$C485] mptra,16*64*2+(64-22)*2,21,blkh
			EndIf
		EndIf





		If myfrcnt&1=0
			##[$C486] 0,Pl(0)\fr,$ee00			,0		,Pl(0)\carnum
			##[$C482]	 Pl(0)\q ,$ef20			,144
			##[$C486] 0,Pl(2)\fr,$ee00+288*4,1		,Pl(2)\carnum
			##[$C482]	 Pl(2)\q ,$ef20+288*4,144
			CNIF #uscar>4
;					SegaCar 0,Pl(4)\fr,$ee00+288*8,0
;					SegaDMA	 Pl(4)\q ,$ef20+288*8,144
			CEND

;				SegaCar 0,Pl(6)\fr,$ee00+288*6,0
;				SegaDMA	 Pl(6)\q ,$f700+288*6,144

		Else
			##[$C486] 0,Pl(1)\fr,$f040			,0		,Pl(1)\carnum
			##[$C482]	 Pl(1)\q ,$f160			,144
			##[$C486] 0,Pl(3)\fr,$f040+288*4,1		,Pl(3)\carnum
			##[$C482]	 Pl(3)\q ,$f160+288*4,144
			CNIF #uscar>3
;					SegaCar 0,Pl(5)\fr,$f040+288*8,1
;					SegaDMA	 Pl(5)\q ,$f160+288*8,144
			CEND

;				SegaCar 0,Pl(7)\fr,$ef20+288*6,1
;				SegaDMA	 Pl(7)\q ,$f820+288*6,144

		EndIf




	Return
CEND




CNIF #collisions


Macro bitme					;!hitme{*ap,*sha,cra,*rp<>*ap}
	If `4
;		If (*rp\towed<>`1) AND (`1\towed<>*rp)
			If ##[$8524](`1\i,`1\j,`1\k,*rp\i,*rp\j,*rp\k)
				`3=Off
				If (`1\coll<0)
					If FastCollide(`1,*rp,`2)
						verydum.w=-1
;						chan(*rp\channel)\reqsam=2
;						chan(`1\channel)\reqsam=2
					EndIf
				EndIf
			EndIf
;		EndIf
	EndIf
End Macro


	.Crash
;		If myfrcnt.w>1 Then Return
;		!showred
		crash.w=0

;		pla.w=ipl:*ap.car=*cp0
		pla=myfrcnt:*ap.car=Pl(pla)
		*rp.car=*p0:cra.w=On

		If *ap\coll<0
;			*sha=Bank(*ap\bnk)+*ap\head*SizeOf.ShadPt
			*sha.ShadPt=?shadowdat+*ap\head*SizeOf.ShadPt
			For *rp=*p0 To Pl(#uscar) Step SizeOf.car
				If *rp\coll<0
					!bitme{*ap,*sha,cra,*rp<>*ap}
				EndIf

			Next
		EndIf
;		!fixit{cra,*ap}

	Return
CEND


;			If myfrcnt=0
;				*ap.car=Pl(0):*rp.car=Pl(1)
;				Gosub DoMyColl
;			EndIf
;			If myfrcnt=1
;				*ap.car=Pl(1):*rp.car=Pl(0)
;				Gosub DoMyColl
;			EndIf
;
;.DoMyColl
;	*sha.ShadPt=?shadowdat+*ap\head*SizeOf.ShadPt
;	If MyRectsHit(*ap\i,*ap\j,*ap\k,*rp\i,*rp\j,*rp\k)
;		mydumvar.w=FastCollide(*ap,*rp,*sha)
;	EndIf
;Return
;CEND


.DoMainS
;Safe{}

	Repeat

CNIF #c=#s
	;	fr.l=fr+1:If fr>799 Then fr=0

	;	x+xa:y+ya
	;	If x<0 Then x=0:xa=0:ya=-1
	;	If y<0 Then y=0:ya=0:xa=1
	;	If x=768-319 Then x=768-320:xa=0:ya=1
	;	If y=384-239 Then y=384-240:ya=0:xa=-1

		a.w=##[$C484](0):xa=0:ya=0

		If a AND 1 Then ya=-1
		If a AND 2 Then ya=1
		If a AND 4 Then xa=-1:fr=##[$C386](fr+1,0,799)		;xa=-1
		If a AND 8 Then xa=1:fr=##[$C386](fr-1,0,799)

		x=##[$C386](x+xa,0,768-320)
		y=##[$C386](y+ya,0,384-240)

		vbwait:TST $ff0000:BEQ vbwait:MOVE#0,$ff0000

		!pokemem{#wvram+$3c000003,-(x AND 7)}						;horizontal
		!pokemem{#wsram+$00000000,(y AND 7)}						;vertical

		dtp=##[$C384](dtp+0.1,2,pts2)
		dtp=5;pts2-3
		FindLo dtp,skbm
		spr(0)\vp=$80 +MapY(bez\i,bez\j,skbm)*0.75
		spr(0)\hp=$80 +MapX(bez\i,bez\j)*0.75
		spr(1)\vp=$80 +MapY(bez\k,bez\l,skbm)*0.75
		spr(1)\hp=$80 +MapX(bez\k,bez\l)*0.75


		MOVE #$8710,$c00004

CEND

	Until 1=0

CNIF 1=0
;		BRA poka

		mypoly:Dc.w 8,0,20,10,10,20,3,6

		MOVE #$8708,$c00004

		vb+vv:If vb>16 OR vb<-16 Then vv=-vv

		!pokemem{#wsram+$00000000,vb}
		!pokemem{#wsram+$00020000,-vb}
		!pokemem{#wvram+$3c000003,vb}
		!pokemem{#wvram+$3c020003,-vb-24*8}

		While Peek.w($c00008)<$6f00:Wend

		!pokemem{#wsram+$00000000,-vb}
		!pokemem{#wsram+$00020000,vb}
		!pokemem{#wvram+$3c000003,-vb}
		!pokemem{#wvram+$3c020003,vb-24*8}

		MOVE #$8700,$c00004

		MOVE #$8704,$c00004

CEND






.
.DoMainJ

CNIF #c=#j

	Repeat

		!waitdsp:!waitgpu:!waitblit	;wait till previous frame rendered!

		Exchange *bmr1.jbmap,*bmr2.jbmap
		MOVE framecnt,d7:'wdb:CMP framecnt,d7:BEQ 'wdb

		*bmr=*bmr1

		BlCls{*bmr,0,0};$1010101,$10101010}

		CNIF #bars
			Poke.w $f0002a,0
		CEND

		!waitgpu
		!waitblit
		!waitdsp

;		Poke.l *bmr\idata+320+8,$ffffffff

		Gosub PlaceCarold

		stt=jint{(mytau-2)*2}
		For gt=stt To stt+8 ;Step 2
			t=gt

			If t<2 Then t+pts
;			If t>pts2 Then t-pts
			Exchange mapa.l,mapb.l
			map.l=mapa
			Gosub RotObj

			!waitdsp
			!waitgpu
			!waitblit
			BlCopyMem{tritemp.l,map.l,trisize.l }

			Gosub Draw
		Next

		!waitgpu
		!waitblit

		CNIF #bars
			Poke.l $f0002a,$ffff
			Poke.w $f0002a,mysilly.w:mysilly+1
		CEND

		GetJoy{&jox.l,&joy.l,&butt.l}

	Until 1=0
CEND
Return

.
CNIF #c=#a
	.DoMainA


		Repeat
			VWait
		Until Joyb(0)<>0


	Return
CEND



Macro calc
	`1=base(t)+(`2+ ((`3)*((`3)+1)) ASR 1)*SizeOf.vec
End Macro

Macro mpc
	`1=map+(`2+ ((`3)*((`3)+1)) ASR 1)*SizeOf.xy
End Macro



.trijunk

NEWTYPE .vec
	x.q:y:z
End NEWTYPE

NEWTYPE.xy
	y.w:x.w
End NEWTYPE

NEWTYPE .tri
	a.w:b.w:c.w
End NEWTYPE


DEFTYPE.vec *dest,*dest2,*dest3,*dest4

.InitTris

CNIF #c=#j
		mapa.l=GetMem32{65536}
		mapb.l=GetMem32{65536}

		colbase.l=GetMem32{32768}
		map.l=mapa

	Dim vec.vec(10000):vecs.l=-1
	Dim tri.tri(10000)
	Dim base.l(100)


		sx1=-10:sy1=-30:sz1=30
		sx2=-10:sy2=30 :sz2=30
		sx3=20:sy3=0	 :sz3=30
		Gosub Generate
		For t=0 To tri.l
			base(t)=GetMem32{SizeOf.vec*9*10/2}
			a=tri(t)\a
			b=tri(t)\b
			c=tri(t)\c
			sx1=vec(a)\x; ASL 6
			sy1=vec(a)\y; ASL 6
			sz1=vec(a)\z; ASL 6
			sx2=vec(b)\x; ASL 6
			sy2=vec(b)\y; ASL 6
			sz2=vec(b)\z; ASL 6
			sx3=vec(c)\x; ASL 6
			sy3=vec(c)\y; ASL 6
			sz3=vec(c)\z; ASL 6
			Gosub Make
		Next

		For h.w=0 To 18*18
			col.q=(##[$8481](h,0)+1)*127+1:temp.l=col&255
			temp=temp ASL 8 + temp
			Poke.l colbase+h ASL 2,temp ASL 16+temp
		Next
	CEND

Return




.Make
CNIF #c=#j
	!calc{*dst.vec,0,0}:xx=sx1:yy=sy1:zz=sz1:Gosub Split
	!calc{*dst.vec,0,8}:xx=sx2:yy=sy2:zz=sz2:Gosub Split
	!calc{*dst.vec,8,8}:xx=sx3:yy=sy3:zz=sz3:Gosub Split

	scal=8:hscal=scal ASR 1
	For cnt.w=0 To 2

		For y=hscal To 7 Step scal
			For x=hscal To y Step scal

				!calc{*dest2,x-hscal,y-hscal}
				!calc{*dest3,x-hscal,y+hscal}
				!calc{*dest4,x+hscal,y+hscal}

				x2=*dest2\x:y2=*dest2\y:z2=*dest2\z
				x3=*dest3\x:y3=*dest3\y:z3=*dest3\z
				x4=*dest4\x:y4=*dest4\y:z4=*dest4\z

				!calc{*dest,x,y}
				!calc{*dest2,x-hscal,y}
				!calc{*dest3,x,y+hscal}

				xx=(x2+x4) ASR 1
				yy=(y2+y4) ASR 1
				zz=(z2+z4) ASR 1
				*dst.vec=*dest:Gosub Split

				xx=(x2+x3) ASR 1
				yy=(y2+y3) ASR 1
				zz=(z2+z3) ASR 1
				*dst.vec=*dest2:Gosub Split

				xx=(x3+x4) ASR 1
				yy=(y3+y4) ASR 1
				zz=(z3+z4) ASR 1
				*dst.vec=*dest3:Gosub Split

			Next
		Next
		scal ASR 1:hscal ASR 1
	Next
CEND

CNIF 1=0
	For y=0 To 8
		For x=0 To y
			!calc{*dst,x,y}
			xx=*dst\x ASR 6
			yy=*dst\y ASR 6
			zz=*dst\z ASR 6
			dist=(10 ASL 2)/jsqr{xx*xx+yy*yy+zz*zz}
;			*dst\x=Sin(ang1)*10;xx*dist
;			*dst\y=Cos(ang1)*10;yy*dist
;			*dst\z=0;zz*dist



			ad.l=?sincos+((x ASL 4) ASL 2)
			qs=Peek.w(ad	)ASR 15
			qc=Peek.w(ad+2)ASR 15

			ad.l=?sincos+(((8-y) ASL 4) ASL 2)
			ps=Peek.w(ad	)ASR 15
			pc=Peek.w(ad+2)ASR 15

			*dst\x=qs*30*pc
			*dst\y=qc*30*pc
			*dst\z=-ps*30
		Next
	Next
CEND
Return


.Split
CNIF #c=#j
	*dst\x=xx
	*dst\y=yy
	*dst\z=zz
CEND

Return




NEWTYPE .vert
	t.q:plus.w
	dx.q:dy.q
End NEWTYPE

CNIF #c=#a
		#sc=2
CEND




.InitLatMem

	Dim latchl(31),latchr(31)
	latls.w=-1:latrs.w=-1
	Dim vert.vert(240)
	vecs.l=-1:tri.l=-1
Return


	Function.w FindNext{mmin,mmax,plus.w}
	Shared vert(),verts
		mptr=-1
		For cnt.w=0 To verts
			If vert(cnt)\plus=plus
				If mmin<vert(cnt)\t
					If vert(cnt)\t<mmax
						mmax=vert(cnt)\t
						mptr=cnt
					EndIf
				EndIf
			EndIf
		Next

		Function Return mptr
	End Function

	Function.w FindNextLat{mmin,mmax,plus.w}
	Shared latchl(),latchr(),latls.w,latrs.w
		mptr=-1
		If plus
			For cnt.w=0 To latls
				If mmin<latchl(cnt)
					If latchl(cnt)<mmax
						mmax=latchl(cnt)
						mptr=cnt
					EndIf
				EndIf
			Next
		Else
			For cnt.w=0 To latrs
				If mmin<latchr(cnt)
					If latchr(cnt)<mmax
						mmax=latchr(cnt)
						mptr=cnt
					EndIf
				EndIf
			Next
		EndIf
		Function Return mptr
	End Function



.Generate

	mystp=1 ASR 5
	For mycnt.w=0 To 7
		plusa.w=(mycnt&1=1)
		plusb.w=(mycnt&2=2)
		If mycnt>3
			tau1=31
			tau2=19
		Else
			tau1=12
			tau2=3
		EndIf

		For k=1 To 5

			FindLo tau1
			If plusa
				x1=bez\i:y1=bez\j
			Else
				x1=bez\k:y1=bez\l
			EndIf
			FindDif tau1+mystp
			If plusa
				dx1=bez\i ASL 5:dy1=bez\j ASL 5
			Else
				dx1=bez\k ASL 5:dy1=bez\l ASL 5
			EndIf

			FindLo tau2
			If plusb
				x2=bez\i:y2=bez\j
			Else
				x2=bez\k:y2=bez\l
			EndIf
			FindDif tau2+mystp
			If plusb
				dx2=bez\i ASL 5:dy2=bez\j ASL 5
			Else
				dx2=bez\k ASL 5:dy2=bez\l ASL 5
			EndIf


			mag1=jsqr{dx1*dx1+dy1*dy1}
			mag2=jsqr{dx2*dx2+dy2*dy2}
			dista=((x1-x2)*dy2-(y1-y2)*dx2)/mag2
			distb=((x2-x1)*dy1-(y2-y1)*dx1)/mag1
			tau1=jwrap{tau1+dista/mag1,2,pts3}
			tau2=jwrap{tau2-distb/mag2,2,pts3}
		Next
		If plusa
			latls+1:latchl(latls)=tau1
		Else
			latrs+1:latchr(latrs)=tau1
		EndIf
		If plusb
			latls+1:latchl(latls)=tau2
		Else
			latrs+1:latchr(latrs)=tau2
		EndIf

	CNIF #c=#a
		FindLo tau1
		If plusa
			Circle bez\i ASL #sc,bez\j ASL #sc,4,3
		Else
			Circle bez\k ASL #sc,bez\l ASL #sc,4,3
		EndIf
		FindLo tau2
		If plusb
			Circle bez\i ASL #sc,bez\j ASL #sc,4,4
		Else
			Circle bez\k ASL #sc,bez\l ASL #sc,4,4
		EndIf
	CEND

	Next

	basel=latchl(FindNextLat{2,pts4,On})
	baser=latchr(FindNextLat{2,pts4,Off})

	For hiscnt.w=0 To 6

		verts=-1
		plus.w=On
		tau1=basel;
		tau2=latchl(FindNextLat{tau1 ,pts4,plus})	:	basel=tau2
		Gosub FryIt

		plus.w=Off
		tau1=baser;latchr(FindNextLat{baser,pts4,plus})
		tau2=latchr(FindNextLat{tau1 ,pts4,plus})	:	baser=tau2
		Gosub FryIt


		Gosub MakeGoodTri
	Next

Return



.MakeGoodTri
CNIF #c=#a
	curl=FindNext{1,pts4,On}
	curr=FindNext{1,pts4,Off}
		mminl=vert(curl)\t
		mminr=vert(curr)\t

	FindLo mminl
	x1=bez\i:y1=bez\j
	FindLo mminr
	x2=bez\k:y2=bez\l

	done.w=Off
	Repeat
		Line x1 ASL #sc, y1 ASL #sc, x2 ASL #sc, y2 ASL #sc,5

		mminl=vert(curl)\t
		mminr=vert(curr)\t
		nxl=FindNext{mminl,pts4,On}
		nxr=FindNext{mminr,pts4,Off}

		If (nxl>-1) OR (nxr>-1)

			x3=-200:y3=-200
			x4=-200:y4=-200
			If nxl>-1
				FindLo vert(nxl)\t
				x3=bez\i:y3=bez\j
			EndIf
			If nxr>-1
				FindLo vert(nxr)\t
				x4=bez\k:y4=bez\l
			EndIf


			dx=(x4-x1) ASR 3
			dy=(y4-y1) ASR 3
			distl=dx*dx+dy*dy
			dx=(x3-x2) ASR 3
			dy=(y3-y2) ASR 3
			distr=dx*dx+dy*dy

			If distl>distr
				Line x1 ASL #sc, y1 ASL #sc, x3 ASL #sc, y3 ASL #sc,6
				x1=x3:y1=y3:curl=nxl
			Else
				Line x4 ASL #sc, y4 ASL #sc, x2 ASL #sc, y2 ASL #sc,7
				x2=x4:y2=y4:curr=nxr
			EndIf

		Else
			done.w=On
		EndIf
	Until done

CEND

Return


.FryIt
CNIF #c=#a
;	FindLo tau2
;	x1=bez\k ASL #sc:y1=bez\l ASL #sc
;	Line x1,y1,x1+10,y1+10,5

;	verts=0
	verts+1
	vert(verts)\t=tau1
	vert(verts)\plus=plus
	verts+1
	vert(verts)\t=tau2
	vert(verts)\plus=plus



	For pass.w=0 To 1
		dtp=tau1
		dista=0

		While dtp<tau2

			dtp+0.05
			FindLo dtp
				If plus
					newi=bez\i:newj=bez\j
				Else
					newi=bez\k:newj=bez\l
				EndIf
			FindDif dtp+0.02

			If plus
				dx=bez\i*(50*0.05)
				dy=bez\j*(50*0.05)
			Else
				dx=bez\k*(50*0.05)
				dy=bez\l*(50*0.05)
			EndIf

			dista=dista+jsqr{dx*dx+dy*dy}
			If pass=1
				If dista>myidt
CNIF #c=#a
					Point newi ASL #sc,newj ASL #sc,1
CEND
					dista-myidt
					verts+1:vert(verts)\t=dtp
					vert(verts)\plus=plus
				EndIf
			EndIf

		Wend

		If pass=0
			myidt=(dista+0.01)/(##[$C381](dista/7)+1)
		EndIf

	Next
CEND


Return







.PlaceCarold

CNIF #c=#j
;	If butt&1 Then rotang+1
;	If butt&2 Then rotang-1



	mytau=mytau+joy*0.1

	FindLo mytau
	quikx=(bez\i+bez\k) ASR 1
	quiky=(bez\j+bez\l) ASR 1
	FindDif mytau+1



	fredang=Angle((bez\i+bez\k) ASL 4,(bez\j+bez\l) ASL 4) ASR 16
	qs=-jsin{fredang} ASR 2
	qc=-jcos{fredang} ASR 2
;	rotang*0.98
;	fredang=fredang+rotang



;	ad.l=?sincos+((fredang&1023) ASL 2)
;	f=jfrac{fredang}:of=1-f
;	qs=Peek.w(ad	)*of+Peek.w(ad+4)*f
;	qc=Peek.w(ad+2)*of+Peek.w(ad+6)*f
CEND

Return



.RotObj


CNIF 1=0
	myscal=2;1.3
	qqs=jext{qs}*2*myscal
	qqc=jext{qc}*2*myscal
	*dest=base(0)
	*mp.xy=map

	For y=0 To 16
		For x=0 To y
;			!calc{*dest,x,y}
;			!mpc{*mp.xy,x,y}

			*mp\x=(*dest\x*qqc-*dest\y*qqs +160)ASL 4

			hgh=*dest\x*qqs+*dest\y*qqc +100
			If hgh<0 Then hgh=0
			*mp\y=(hgh&$ffff) ASL 2
			*dest+SizeOf.vec
			*mp+SizeOf.xy
		Next
	Next
CEND



CNIF #c=#j

	!waitdsp

;	BlCopyMem{map.l,tritemp.l,trisize.l }
	mytemp.l=$f1cf80

	Poke.l mytemp	,tritemp.l	;dest
	Poke.l mytemp+4,base(t)		;src

	Poke.l mytemp+	8,jfr{qs ASR 1,qc ASR 1}
;	quikx.q=(5-jfrac{deadx}) ASL 6
;	quiky.q=(5-jfrac{deady}) ASL 6

	Poke.q mytemp+ $c,quikx
	Poke.q mytemp+$10,quiky

	!rundsp{0}

;	!waitdsp

;	BlCopyMem{tritemp.l,map.l,trisize.l }
	Return
CEND



Return



.Draw
CNIF #c=#j

	BlPoly{*bmr,map,colbase}
CEND

CNIF #c=#a
	For y=0 To 15
		!mpc{*mp.xy,0,y}
		*mpn.xy=*mp+SizeOf.xy*(y+1)
		*dt2.xy=*mpn+SizeOf.xy


;		fred(0)=*mp\x:fred(1)=*mp\y
;		fred(2)=*mpn\x:fred(3)=*mpn\y
;		fred(4)=*dt2\x:fred(5)=*dt2\y
;		Polyf 3,&fred(0),*mp\c2


		For x=0 To y-1
			*mp+SizeOf.xy

;			fred(2)=*mp\x:fred(3)=*mp\y
;			Polyf 3,&fred(0),*mp\c1
			*mpn=*dt2:*dt2+SizeOf.xy

;			fred(0)=*mp\x:fred(1)=*mp\y
;			fred(2)=*mpn\x:fred(3)=*mpn\y
;			fred(4)=*dt2\x:fred(5)=*dt2\y
;			Polyf 3,&fred(0),*mp\c2

;			BlLin{*bmr,*mpn\x ASR 4,*mpn\y ASR 2,*mp\x ASR 4,*mp\y ASR 2,x+1}

		Next
	Next

CEND
Return


;			BlLin{*bmr,*dt4\x ASR 4,*dt4\y ASR 2,*dt2\x ASR 4,*dt2\y ASR 2,*mp\c}
;			BlLin{*bmr,*dt2\x ASR 4,*dt2\y ASR 2,*dt3\x ASR 4,*dt3\y ASR 2,*mp\c}

























.
.
.
.
.
.
.

.Skidroutines

##[$80CA] *p
.SpinIt
;	If jox=2 Then chan(\channel)\reqsam=3:jox=0
	If \inair
		\rot=##[$C386](\rot,-1,1)
	Else
		If \idle<0
			If \control=#contcomp
				\rot=(\rot+*p\jox*\steering) ASR 1
			Else
				\rot=(\rot+	 jox*\steering) ASR 1
			EndIf
		EndIf
	EndIf

	oldk=\k
	If \drop
		\headk-\gravity:newk=\k+\headk+\headk
		tx=\i+\headi+\headi:tz=\j+\headj+\headj
		soonk=QHite(tx,tz,skbm)
		If newk >soonk
;			Stop
			\inair=On:\traction=1
;			Select (Peek.w($dff006) AND 7)=0	;quick random..
;			 Case 0:\pitch=QLimit(\pitch+\mpitch,0,4)
;			 Case 1:\roll =QLimit(\roll +\mroll ,0,4)
;			End Select
		Else

			\headk=(soonk-oldk)ASR 1:\inair=Off

			pitch.w=##[$C386]((QHite(tx,tz+0.2,skbm)-soonk)+2.5,0,4)
			\mpitch=##[$C382](pitch-\pitch):\pitch+\mpitch

			roll.w=##[$C386]((QHite(tx-0.2,tz,skbm)-soonk)+2.5,0,4)
			\mroll=##[$C382](roll-\roll):\roll+\mroll
;			If (pitch<>2) OR (roll<>2) Then Stop
		EndIf
	EndIf

	\dir=##[$851A](\dir+\rot)
	\qc=qcos(\head):\qs=qsin(\head)
	\fr=\roll*160+\pitch ASL 5+\head ASR 1
Return



Macro FindScr
	*s\v`1x=(*sha\rx`1																					 )
	*s\v`1y=(*sha\ry`1-##[$C487](QHite(\i+*sha\ri`1,\j+*sha\rj`1,skbm)-oldk))
;	*s\v`1y=IOP(MapY(\i+*sha\ri`1,\j+*sha\rj`1,skbm))

End Macro


##[$80CA] *p
.DrawShadow

	CNIF #c=#s

		oldk=\k

		*s.quad=&quadverts(0);\q
		*sha.ShadPt=?shadowdat+SizeOf.ShadPt*\head
		!FindScr{0}:!FindScr{1}:!FindScr{2}:!FindScr{3}
		*p\shady=##[$C483] (&quadverts(0),*p\q)
	CEND


Return






Statement bounce{result.w,*e.quadratic,*par.parse}
	Shared sqlu.l

;result obtained from TestNew..
;fi,fj are the params to be changed...
;di,dj,i,j are just for fun..

	here.w=Off ; in case we crash more than once?

	result+16
	Repeat
		If ( (result & 1)=1)
			If *e\lstraight
				here+FixHitLine(*e,*par)
			Else
				here+FixHitQuad(*e,*par,sqlu)
			EndIf
		EndIf	 ;noimpact
		result ASR 1
		*e+#hquad
		*par\norm+32
	Until (result=1) ; OR (here=On)
	*par\norm AND 63
	*par\boom=(here<0)
End Statement	;end of bounce

Statement Damage{result.w,*e.quadratic,*par.parse}
	Repeat
		If ( (result & 1)=1)
			If *e\lstraight
				deli=*par\fi-*e\lc
				delj=*par\fj-*e\lf
				fac=*e\lb*deli+*e\le*delj
				*par\i=*e\lc+*e\lb*fac
				*par\j=*e\lf+*e\le*fac	;				here+bouncenew{*e,*par}
			Else
				deli=*par\fi-*e\lc
				delj=*par\fj-*e\lf
				fac=*e\lb*deli+*e\le*delj
				*par\i=*e\lc+fac*(*e\lb+*e\ma*fac)
				*par\j=*e\lf+fac*(*e\le+*e\md*fac) ;				here+bouncepod{*e,*par,sqlu}
			EndIf
		EndIf	 ;noimpact
		result ASR 1
		*e+#hquad
	Until (result=0)
End Statement	;end of Damage


#mung=On; ff
#clip=On; ff

##[$80CA] *p
.MoveIndiv
;	If \towed<>0 Then Return

	If \control=#contcomp Then comp=True:Else:comp=False	;computer override!

	If \idle<0 ;be strict!

		\movi=0:\movj=0

	CNIF #mung
		*par\fi=\i:*par\fj=\j
		*par\i =\i:*par\j =\j
		dt=\curdt
		*e=edge(dt):result.w=CheckCollQuad(*e,*par):*g.xtra=grot(dt+1)
		If result.w>0
			If (result&5)>0
				If (*g\cai-*par\fi)**g\swivj > (*g\caj-*par\fj)**g\swivi
					result&14
				Else
					result&11
				EndIf
			EndIf
			If (result&10)>0
				If (*g\cai-*par\fi)**g\swivj > (*g\caj-*par\fj)**g\swivi
					result&13
				Else
					result&7
				EndIf
			EndIf

			If result>0
				Damage{result,*e,*par}
				\i=*par\i:\j=*par\j:\headi=0:\headj=0
			EndIf

		EndIf
		;mung walls (fin)
	CEND


		If \inair
			\nrev=0
		Else

			If comp

				\jox=0
				ni=*p\i+*p\headi ASL 2
				nj=*p\j+*p\headj ASL 2

				mess.w=firstmass(##[$C384](*p\curdt,2,pts3))
				*first.guide=mass(mess)
				safe=On
				While safe
					mess=##[$C384](mess+1,0,nxmass.w)
					*guide.guide=mass(mess)
					dif=(*guide\dtp-\curdt)
					If dif<0 Then dif+pts1
					If (dif>-2 AND dif<8)
						difi=*guide\mi-ni
						difj=*guide\mj-nj
						If (*guide\di*difj-*guide\dj*difi)<0
							cur.w=mess:maxout=dist:safe=Off
						EndIf
					EndIf
				Wend

				desti=0
				*guide	 =mass(			cur						)
				*lg.guide=mass(##[$C384](cur-1,0,nxmass))

				If lapdir=1
					difi=*guide\li-ni:normi=*guide\li-*lg\li
					difj=*guide\lj-nj:normj=*guide\lj-*lg\lj
					If difi*normj<difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\ri:destj=*rg\rj:joy=cmpacc7
					EndIf

					difi=*guide\ri-ni:normi=*guide\ri-*lg\ri
					difj=*guide\rj-nj:normj=*guide\rj-*lg\rj
					If difi*normj>difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\li:destj=*rg\lj:joy=cmpacc7
					EndIf
				Else
					Exchange *lg,*guide

					difi=*guide\li-ni:normi=*guide\li-*lg\li
					difj=*guide\lj-nj:normj=*guide\lj-*lg\lj
					If difi*normj>difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\ri:destj=*rg\rj:joy=cmpacc7
					EndIf

					difi=*guide\ri-ni:normi=*guide\ri-*lg\ri
					difj=*guide\rj-nj:normj=*guide\rj-*lg\rj
					If difi*normj<difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\li:destj=*rg\lj:joy=cmpacc7
					EndIf

				EndIf


				If desti=0
					*rg.guide=mass(##[$C384](cur+lapdir4,0,nxmass))
					desti=*rg\mi:destj=*rg\mj:joy=cmpacc
				EndIf
				difi=desti-\i
				difj=destj-\j
				\jox=##[$C382](difi*\qs-difj*\qc)
			EndIf

			\vel=\headi*\qc+\headj*\qs

									;	*****	 HILL	 ******
			tx=\i-\qc:tz=\j-\qs
			If \vel<0
				joy+(\headk ASR 1)	;hmmmm
			Else
				joy-(\headk ASR 1)	;hmmmm
			EndIf
;			joy+(!qhite{tx,tz}-\k) ASR 3
			\nrev=(\rev+joy*\accel)*(\engfric)

			\movi+(\qc*\nrev)-\headi
			\movj+(\qs*\nrev)-\headj
			\nrev=(\nrev-\rev) ASR 2

			\traction=##[$C385](\qc*\movj-\qs*\movi)

			\movi*\retard
			\movj*\retard

		EndIf

		ddi1=\headi ASL 2+(\movi ASL 2+ \movi) ASL 1
		ddj1=\headj ASL 2+(\movj ASL 2+ \movj) ASL 1
		proi=\i+ddi1
		proj=\j+ddj1

		*g=grot(\curdt)
		ni=proi-*g\midi:nj=proj-*g\midj
		If *g\dirj*ni < *g\diri*nj	;n.b. qwrap (2,pts3)
			\curdt-1
			If (\curdt<		2) Then \curdt+pts1:lapinc.w=-lapdir:Gosub DrawLaps
;			If leadtime(\curdt)<tim Then leadtime(\curdt)=tim

		Else
			*g=grot(\curdt+1):ni=proi-*g\midi:nj=proj-*g\midj
			If *g\dirj*ni > *g\diri*nj
				\curdt+1
				If (\curdt>pts2) Then \curdt-pts1:lapinc=lapdir:Gosub DrawLaps
;				If leadtime(\curdt)<tim Then leadtime(\curdt)=tim
			EndIf
		EndIf


	CNIF #clip
		test\boom=Off
		ddi1=-ddi1
		ddj1=-ddj1
		test\i =*p\i:test\j =*p\j
		test\fi=proi:test\fj=proj
		test\di=ddi1:test\dj=ddj1

		\side=0:\top=0
		If (##[$C385](ddi1) < 0.02) AND (##[$C385](ddj1) < 0.02) ;goslo
			\headi=0:\headj=0:\movi=0:\movj=0
			ddi1=0:ddj1=0
		Else
			ro=ddi1 ASL 6:ger=ddj1 ASL 6
			qfac.q=RDistance(ro,ger) ASL 7
			test\diri=ddi1*qfac
			test\dirj=ddj1*qfac

			dt=\curdt:							;*g=grot(dt)
			*e=edge(dt)
			result.w=CheckCollQuad(*e,*par)
			If result<>0
				*par\boom=Off
				bounce{result,*e,*par}
				If test\boom
					\swai=test\fi
					\swaj=test\fj

					\headi=-ddi1 ASR 2:\movi=0
					\headj=-ddj1 ASR 2:\movj=0


					\swiv=##[$851A]((\dir-*par\norm)*2)

					\difi=qcos(*par\norm)
					\difj=qsin(*par\norm)	;Hooway!

;					If *p=*p0
;						Use BitMap 0
;						Line MapX(\swai,\swaj),MapY(\swai,\swaj),MapX(\swai+\difi,\swaj+\difj),MapY(\swai+\difi,\swaj+\difj),14
;					EndIf

					If ddi1<0 Then \side=1 Else \side=2
					If ddj1<0 Then \top=3 Else \top=4
				EndIf
			EndIf
		EndIf
	CEND

	Else
		##[$80CA] *p

	EndIf

	\vel=\headi*\qc+\headj*\qs

Return


.DrawLaps
Return

CheckWallLatent
	##[$80CA] *p
	For *p=Pl(0) To Pl(#uscar) Step SizeOf.car	; if in a collision, \movi=0=\movj

		*p\rev+*p\nrev

		Select \side
			Case 0:impact.w=Off
			Case 1:impact.w=(\i+\headi) >= \swai
			Case 2:impact.w=(\i+\headi) <= \swai
		End Select
		If NOT impact
			Select \top
				Case 3:impact.w=(\j+\headj) >= \swaj
				Case 4:impact.w=(\j+\headj) <= \swaj
			End Select
		EndIf
		If impact
			\i=\swai:\j=\swaj
			fac=(\headi*\difj-\headj*\difi);ASL 1 ; do the wild vel
			fac=fac+ fac ASR 1
			\headi-(fac*\difj)
			\headj+(fac*\difi)

			If (##[$C385](\headi)>0.03) OR (##[$C385](\headj)>0.03)	;so bounce ain't excessive..
				blah=RDistance(\headi ASL 7,\headj ASL 7) ASL 4	;was 3
				If blah<1
					\headi*blah:\headj*blah
				EndIf
			Else
				\headi= \difj ASR 5
				\headj=-\difi ASR 5
			EndIf

			blah=qsin(\swiv)	;do the wild spin after bounce..
			\dir=##[$851A](\dir-blah)
			\rot-blah ;ASL 1

			\side=0:\top=0:\swai=-1	;reset so ain't happen 'gin
			\swiv=0 ;:\rev ASR penalty
		EndIf

	Next

Return







.
.
.
.
.




CNIF #c=#j
	;********************** JAGOS SUBS ******************************

.jagos ;(thanx mark!)
	;
	;OK, well need some zero page locations...
	;
	#allocat=$200
	#stopat=$204
	#vbint=$208
	#gpint=$20c
	#obint=$210
	#tiint=$214
	#dsint=$218
	#_INT1=$21c

	#superstacksize=256
	#userstacksize=256


	copymem		 ;a0=src, a1=srcf, a2=dest
	;
	CMP.l a1,a0:BCC 'done:MOVE.l (a0)+,(a2)+:BRA copymem
	'done:RTS

	initjagos
	;
	CLR.l $ff0:CLR.l $ff8:
	MOVE.l #$200000,allocat:MOVE.l (a7),a0
	MOVE.l allocat,a7:SUB.l #superstacksize,allocat
	MOVE #$0,sr
	MOVE.l allocat,a7:SUB.l #userstacksize,allocat:MOVE.l a0,-(a7)
	;
	MOVE #$1f00,_INT1:LEA inthandler(pc),a0:MOVE.l a0,$100
	;
	MOVEQ #8,d0:BSR alloc:CLR.l (a0):MOVE.l #4,4(a0):MOVE.l a0,stopat
	MOVE.l a0,d0:SWAP d0:MOVE.l d0,$f00020:RTS


	alloc ;d0=size, return a0=mem
	MOVE.l 4,a6:MOVEQ #0,d1:JSR -204(a6):MOVE.l d0,a0:RTS

	vbinton:OR #1,_INT1:MOVE _INT1,$f000e0:RTS
	vbintoff:ANDI #$fffe,_INT1:MOVE _INT1,$f000e0:RTS

	inthandler
	;
	MOVEM.l d0-d7/a0-a6,-(a7)
	;
	MOVE $f000e0,d2:ANDI #$1f,d2:MOVE d2,d0
	LSL #8,d0:OR d2,d0:MOVE d0,$f000e0
	;
	LSR #1,d2:BCC 'novbint:MOVE.l vbint,a0:JSR (a0):'novbint
	LSR #1,d2:BCC 'nogpint:MOVE.l gpint,a0:JSR (a0):'nogpint
	LSR #1,d2:BCC 'noobint:MOVE.l obint,a0:JSR (a0):'noobint
	LSR #1,d2:BCC 'notiint:MOVE.l tiint,a0:JSR (a0):'notiint
	LSR #1,d2:BCC 'nodsint:MOVE.l dsint,a0:JSR (a0):'nodsint
	;
	MOVE d0,$f000e2
	;
	MOVEM.l (a7)+,d0-d7/a0-a6:RTE


	initvbint	;d0=scanline, a0=address of code
	MOVE d0,$f0004e:MOVE.l a0,vbint

	If a=a
		MOVE.l a5,global
		MOVE.l a3,local
	EndIf
	RTS



	vbdb	;vertical blank double buffer...
		MOVEM.l d0/d2,-(a7)
		MOVE.l global,a5
		MOVE.l local,a4

		ADDQ #1,framecnt

		RefrBmap{*bmr2.jbmap}
		HeadBmap{*bmr2}

	;	HeadBmap{Peek.l($204)-32}

		MOVEM.l (a7)+,d0/d2
	RTS



global :Dc.l 0
local	:Dc.l 0
CEND



CNIF 1=0

.printd2
;
;RTS
;
;print d2 at d0,d1
;
MOVEM.l d2-d4/a2,-(a7)
;
MOVE.l bmap1,a0							;where it goes
MULU #320,d1:ADD.l d1,a0:LSL #2,d0:AND #$fff0,d0:ADD d0,a0
MOVE.l d2,d0
;
MOVEQ #7,d4
'loop
ROL.l #4,d0:MOVE d0,d2:AND #15,d2
LEA digs(pc),a1:LSL #4,d2:ADD d2,a1						 ;start of digit
MOVEQ #7,d3:MOVE.l a0,a2
'loop2
MOVE.l (a1),(a2):MOVE.l 4(a1),4(a2)
MOVE.l 8(a1),16(a2):MOVE.l 12(a1),20(a2)
;
LEA 576(a1),a1:LEA 1280(a2),a2
DBF d3,'loop2
LEA 32(a0),a0:DBF d4,'loop
;
MOVEM.l (a7)+,d2-d4/a2:RTS

Event
CEND



	Event

CNIF #c=#j
	gpu_1
	IncBin "gpu"
	gpu_1f

	dsp_1
	IncBin "dsp"
	dsp_1f
CEND


	sincos:		IncBin "sincos.bin"

	shadowdat: IncBin "shadow.dat"

CNIF #c<>#s
	mytrack:	 IncBin "maps:f5.nmp"
CEND


CNIF #c=#s

	blank:Dcb.w 64,$80

	spites:
		Dc.w $0b0,$a04,$e790,$90
		Dc.w $0c0,$a05,$e790,$f0
		Dc.w $0d0,$a00,$e790,$90
		Dc.w $0e0,$a07,$e790,$e0
		Dc.w $0f0,$a08,$e790,$90
		Dc.w $100,$a09,$e790,$f0
		Dc.w $110,$a0a,$e790,$90
		Dc.w $120,$a0b,$e790,$f0
		Dc.w $130,$a0c,$e790,$90
		Dc.w $140,$a0d,$c790,$f0
		Dc.w $150,$a0e,$c790,$90
		Dc.w $160,$a0f,$c790,$f0
		Dc.w $080,$a10,$c790,$120			;palette 1
		Dc.w $090,$a11,$c790,$150
		Dc.w $0a0,$a12,$c790,$120
		Dc.w $0b0,$a13,$c790,$150
		Dc.w $0c0,$a14,$c790,$120
		Dc.w $0d0,$a15,$c790,$150
		Dc.w $0e0,$a16,$c790,$120
		Dc.w $0f0,$a17,$c790,$150			;23

		Dc.w $100,$a18,$a790,$120
		Dc.w $110,$a19,$a790,$150
		Dc.w $120,$a1a,$a790,$120
		Dc.w $130,$a1b,$a790,$150

		Dc.w $140,$a1c,$a790,$120
		Dc.w $150,$a1d,$a790,$150
		Dc.w $160,$a1e,$a790,$120
		Dc.w $170,$a00,$a790,$150


	carpalette:
		IncBin "car.palette"



CEND










.InitOs
	CNIF #c=#j
;		BSR initjagos
		MOVE.l #$00a600a6,$f00038:MOVE #$656,$f0003c
		;MOVE #ypos,$f00046:MOVE #ypos+hite+hite,$f00048
		MOVE #$2e,$f00046
		;MOVE #$2e+240+240,$f00048
		MOVE #$2e+199+199,$f00048

		bld.l=$f02200
		!waitgpu
		!waitdsp

		Poke.l $f1a100,(Peek.l($f1a100)&$f) OR (1 ASL 14)
		BlCopyMem{?gpu_1,$f03000,?gpu_1f-?gpu_1}
		BlCopyMem{?dsp_1,$f1b000,?dsp_1f-?dsp_1}

	CEND

Return


;	nmp.l						;8k+ contours NOT CRUNCHED
;	blockmap.l			 ;8k crunched
;	blocks.l[8]			;40k+ crunched
.InitVars




	mytau=6

	scrx=80:scry=0

Return



.GetNewTrack
	CNIF #c=#s
		*ath.theader=tkptr + SizeOf.theader*mytrk.w
		maptr.l=*ath\nmp+tkbin
	CELSE
		maptr.l=?mytrack
	CEND

	condt.l=maptr+64*64*2 + 2
	pts.w=Peek.w(maptr+64*64*2):pts1.w=pts+1:pts2.w=pts+2:pts3=pts+3:pts4=pts+4
	SetMaptr maptr.l,skbm
	SetConDt condt.l,skbm
	SetIO &bez.ij,skbm
	Gosub PreProcess

Return




.DoPal
	CNIF #c=#j
			palbase.l=$f00400
			For tr.w=0 To 255
				mycol=tr ASL 1

				blah.q=(##[$8481](15*tr+2.3,tr)+1)*127:mr=blah
				blah.q=(##[$8481](tr,tr*7+3242)+1)*127:mg=blah
				blah.q=(##[$8481](tr*31+32.6,tr*9+324)+1)*127:mb=blah

				temp.l=(jint{mr ASR 3} ASL 5 + jint{mb ASR 3}) ASL 6+ jint{mg ASR 2}
		;		temp.l=$ffff;3333
				Poke.w palbase+mycol,temp
			Next
	CEND
Return



##[$80CA] *p
.SetStartCar
	\idle=0:\drop=Off:\inair=On
	\coll=0:\warp=0:\lap=0:\jox=0
	\pitch=2:\roll=2:\mpitch=0:\mroll=0:\rot=0:\movi=0:\movj=0
	\headi=0:\headj=0:\headk=0:\rev=0:\nrev=0:\vel=0:\traction=0

	\swaheadi=0:\swaheadj=0:\swamovi=0:\swamovj=0
	\side=0:\top=0:\swai=0:\swaj=0:\difi=1:\difj=0:\swiv=0
	\bestlap=32000:\lasttime=10000:\tottime=-1
Return


.PlaceNorm

	dtp.q=pts3+0.5:If lapdir=-1 Then dtp=2.5
	signmovst=dtp
	FindLo dtp,skbm:dti =(bez\i+bez\k)ASR 1:dtj =(bez\j+bez\l)ASR 1:dtp-(0.1*lapdir)
	FindLo dtp,skbm:dpri=(bez\i+bez\k)ASR 1:dprj=(bez\j+bez\l)ASR 1

	dj=(dtj-dprj) :di=(dti-dpri):width=1.2
	qnorm.q=0.1/jsqr{di*di+dj*dj}

	signmov=2.5:If trailer Then signmov=4.5

	di*10*qnorm*1.25:dj*10*qnorm*1.25
	tdir=##[$851A](Angle(dj ASL 6,di ASL 6) ASR 10+32)




	mycnt.w=0
	For *p=Pl(0) To Pl(#maxcar) Step SizeOf.car
		*p\i=dti+dj*width*((mycnt&1)-0.5)*2 - 0.5*di*width*mycnt;dback
		*p\j=dtj-di*width*((mycnt&1)-0.5)*2 - 0.5*dj*width*mycnt;dback
		*p\k=QHite(*p\i,*p\j,skbm)+10

		*p\dir=tdir:*p\qc=qcos(tdir):*p\qs=qsin(tdir)
		*p\curdt=dtp
		mycnt+1
	Next

Return


Statement CopGrot{src.w,dest.w}
Shared grot(),edge()
	*gs.xtra		 =grot(src):*gd.xtra		 =grot(dest)
	*es.quadratic=edge(src):*ed.quadratic=edge(dest)

	For i=0 To SizeOf.quadratic:Poke.b *ed+i,Peek.b (*es+i):Next
	For i=0 To SizeOf.xtra		 :Poke.b *gd+i,Peek.b (*gs+i):Next

End Statement



PreProcess

	oldi=100:oldj=100
	For dt=0 To pts3

		*g=grot(dt):*e=edge(dt)

		FindLo dt+0	,skbm:A1=bez\i:A2=bez\j:bA1=bez\k:bA2=bez\l
		FindLo dt+0.5,skbm:B1=bez\i:B2=bez\j:bB1=bez\k:bB2=bez\l
		FindLo dt+1	,skbm:C1=bez\i:C2=bez\j:bC1=bez\k:bC2=bez\l


		*g\swivi=A1-bA1:*g\swivj=A2-bA2

;		*g\desti=(A1+	 C1+bA1+		bC1)ASR 2
;		*g\destj=(A2+	 C2+bA2+		bC2)ASR 2
;		*g\desti=(A1+B1+C1+bA1+bB1+bC1)/6
;		*g\destj=(A2+B2+C2+bA2+bB2+bC2)/6
;		*g\desti=(B1+bB1)ASR 1
;		*g\destj=(B2+bB2)ASR 1
		*g\desti=(B1+bB1) ASR 1 +(C1-B1+bC1-bB1)+(A1-B1+bA1-bB1)
		*g\destj=(B2+bB2) ASR 1 +(C2-B2+bC2-bB2)+(A2-B2+bA2-bB2)

		cai=A1:caj=A2
		cbi=C1:cbj=C2	;keep em in - why not?
		*g\midi=B1	:*g\midj=B2
		*g\cai=A1	 :*g\caj=A2
		*g\dai=A1-C1:*g\daj=A2-C2

		ni	=A1-C1:nj	=A2-C2:pdist=jsqr{ni	*ni	+nj	*nj	}:ni	/pdist:nj	/pdist
		difi=A1-B1:difj=A2-B2:pdist=jsqr{difi*difi+difj*difj}:difi/pdist:difj/pdist
		fac=(ni*difj-nj*difi)
		If ##[$C385](fac)<0.13
			*e\lstraight=On
		Else
			*e\lstraight=Off
			*e\lodd1=(fac<0)
			*e\lodd3=(fac>0)
		EndIf


		plussage.w=0:Gosub DoQuadratic

		*e+#hquad
		A1=bA1:A2=bA2:B1=bB1:B2=bB2:C1=bC1:C2=bC2

		*g\cbi=A1	 :*g\cbj=A2
		*g\dbi=A1-C1:*g\dbj=A2-C2

		dai =A1-cai:daj =A2-caj
		dbi =C1-cbi:dbj =C2-cbj		;ya never know.. might come in handy!
		*g\diri=B1-*g\midi:*g\dirj=B2-*g\midj

		mu=(cbj*dai-caj*dai+cai*daj-cbi*daj)/(dbi*daj-dbj*dai)

		ni	=A1-C1:nj	=A2-C2:pdist=jsqr{ni	*ni	+nj	*nj	}:ni	/pdist:nj	/pdist
		difi=A1-B1:difj=A2-B2:pdist=jsqr{difi*difi+difj*difj}:difi/pdist:difj/pdist
		fac=ni*difj-nj*difi
		If ##[$C385](fac)<0.13
			*e\lstraight=On
		Else
			*e\lstraight=Off
			*e\lodd1=(fac>0)
			*e\lodd3=(fac>0)
		EndIf
		plussage.w=32:Gosub DoQuadratic
	Next



	CopGrot{pts1,0}
	For src=1 To 7:CopGrot{src,src+pts1}:Next

	nxmass.w=0:stp=0.25:dtp=2:FindLo dtp,skbm:Gosub getnew:oi=ni:oj=nj

	While dtp<(pts+3)
		dist=0:stpmax=80:stpmin=0
		While (dist<3.8) OR (dist>4.2)
			ndt=dtp+stp:FindLo ndt,skbm:Gosub getnew
			dist=(oi-ni)*(oi-ni)+(oj-nj)*(oj-nj)
			If dist<4
				stpmin=stp
				If stpmax=80 Then stp+0.1: Else stp=(stpmax+stpmin) ASR 1
			Else
				stpmax=stp
				If stpmin=0 Then stp=##[$C386](stp-0.1,0,80):Else stp=(stpmax+stpmin) ASR 1
			EndIf
		Wend
		dtp=ndt:oi=ni:oj=nj

		difi=bez\k-bez\i:difj=bez\l-bez\j:proj.q=1/jsqr{difi*difi+difj*difj}:difi*proj:difj*proj

		li=bez\i+difi:lj=bez\j+difj
		ri=bez\k-difi:rj=bez\l-difj
		mass(nxmass)\mi=ni,nj
		mass(nxmass)\di=difi,difj
		mass(nxmass)\li=li,lj
		mass(nxmass)\ri=ri,rj
		mass(nxmass)\dtp=ndt:nxmass+1
;		Circle MapX(ni,nj),MapY(ni,nj),3,14
;		Line MapX(ni+difi,nj+difj),MapY(ni+difi,nj+difj),MapX(ni,nj),MapY(ni,nj),14
;		Circle MapX(li,lj),MapY(li,lj),3,14
;		Circle MapX(ri,rj),MapY(ri,rj),3,14

	Wend


	mess.w=0
	For dtp=2 To pts2

		mess=##[$C384](mess-20,0,nxmass)
		dif=mass(mess)\dtp-dtp
		If dif>5 Then dif-pts1
		While dif<0
			mess=##[$C384](mess+1,0,nxmass)
			dif=mass(mess)\dtp-dtp
			If dif>5 Then dif-pts1
		Wend
		firstmass(dtp)=##[$C384](mess-1,0,nxmass)

	Next
	If maxmess<nxmass Then maxmess=nxmass

Return

.getnew
	ni=(bez\i+bez\k) ASR 1
	nj=(bez\j+bez\l) ASR 1
Return

DoQuadratic
	If *e\lstraight	;one straight.. comin right up!
		difi=(C1-A1)	:difj=(C2-A2)
		pdist=jsqr{difi*difi+difj*difj}
		difi/pdist:difj/pdist:*e\lb=difi:*e\le=difj

		*e\lc=(A1+C1)ASR 1:*e\lf=(A2+C2)ASR 1
		b1=(A1-*e\lc)*difi+(A2-*e\lf)*difj
		b2=(C1-*e\lc)*difi+(C2-*e\lf)*difj
;		If b2<b1 Then Exchange b1,b2
		mid=(b1+b2) ASR 1:dif=##[$C385](b1-b2)*0.52
		b1=mid-dif:b2=mid+dif
		*e\lb1=b1:*e\lb2=b2

		*e\langst=##[$851A](Angle(difj ASL 6,difi ASL 6) ASR 10+32)
		*e\langadd=0
;		Circle MapX(*e\lc,*e\lf),MapY(*e\lc,*e\lf),5,8


	Else
		pc=A1:B1-pc:B1*2:C1-pc:pa=(C1-B1)*2:pb=C1-pa
		pf=A2:B2-pf:B2*2:C2-pf:pd=(C2-B2)*2:pe=C2-pd

		t=-0.5*(pa*pb+pd*pe)/(pa*pa+pd*pd)

		ob=2*t*pa+pb:oc=t*t*pa+t*pb+pc
		oe=2*t*pd+pe:of=t*t*pd+t*pe+pf
		pdist=jsqr{ob*ob+oe*oe}
		ob/pdist:oe/pdist
		od=-ob	:oa=oe	; to be modified along this line..

		t+1
		tc=t*t*pa+t*pb+pc-oc
		tf=t*t*pd+t*pe+pf-of

		dt1=tc*ob+tf*oe	 ;now, dot2*dot2=dot1...
		dt2=tc*oa+tf*od
		fac=(dt1*dt1/dt2)
		ma=oa/fac:md=od/fac
		oa*fac:od*fac

		*e\la=oa:*e\ld=od
		*e\ma=ma:*e\md=md
		*e\lb=ob:*e\le=oe
		*e\lc=oc:*e\lf=of

		t=0:tc=t*t*pa+t*pb+pc-oc
				tf=t*t*pd+t*pe+pf-of
				b1=tc*ob+tf*oe
		t=1:tc=t*t*pa+t*pb+pc-oc
				tf=t*t*pd+t*pe+pf-of
				b2=tc*ob+tf*oe
		dif=##[$C385](b1-b2)*0.52:mid=(b1+b2) ASR 1
		b1=mid-dif:b2=mid+dif
		*e\lb1=b1:*e\lb2=b2

		t=b1
		difi=2*t*ma+ob		 ;strictly optional..
		difj=2*t*md+oe		 ;differientiate it
		fang=(Angle(difj ASL 6,difi ASL 6) ASR 10+32)

		t=b2
		difi=2*t*ma+ob		 ;strictly optional..
		difj=2*t*md+oe		 ;differientiate it
		stang =(Angle(difj ASL 6,difi ASL 6) ASR 10+32)

		dang.q=(stang-fang)
		If dang<-32 Then dang+64
		If dang>32 Then dang-64	;take the smaller..

		dang/(b2-b1)

		*e\langst=fang-(b1*dang)
		*e\langadd=dang ASR 4


	EndIf
Return





##[$80D3]
	champs
	mini:Dc.w	-8, 15, 20,-13,-10,-24
	pors:Dc.w	 7, -5,	4,	3,-18, -9
	midg:Dc.w -20, 18, -7, -4, 10, 13
	beet:Dc.w	 2,-14,-21,	1, -6,-17
	truk:Dc.w	 8, 23, 24, 22,-11,-12
	musc:Dc.w -16,-22, 19,	5,	9, 11
	ccow:Dc.w	12, -3, -1, -2,	6,-23
	f1f1:Dc.w	16, 21, 17, 14,-15,-19

champcars
	Dc.w	0,1,7,2,4,3,6,5

;	Dc.w -10,-13, 20, 16, 22, -8
;	Dc.w	 4,	7,-18,	3, -5, -9
;	Dc.w	-4, -7, 10, 13, 18,-20
;	Dc.w	 2, -6,-14,	1,-11,-17
;	Dc.w -12, 23, 15,	8,-21, 24
;	Dc.w	-3,	5,	9, 11,-16,-22
;	Dc.w	-2,	6, 12,-23, 19, -1
;	Dc.w	14, 17,-15, 21,-19,-24







.LostCode

	CNIF 1=0


		jj=0
		If butt&1 Then jj+1
		If butt&2 Then jj-1
		myangvel=(myangvel+jj) *0.98
		myang=myang+myangvel ASR 4
		If myang<0 Then myang+1024
		If myang>=1024 Then myang-1024


		ad.l=?sincos+((myang&1023) ASL 2)
		f=jfrac{myang}:of=1-f



		qs=Peek.w(ad	)*of+Peek.w(ad+4)*f
		qc=Peek.w(ad+2)*of+Peek.w(ad+6)*f

		qqs=jext{qs}
		qqc=jext{qc}


		xvel=(xvel+jox) *0.95
		yvel=(yvel+joy) *0.95

		xdif=xvel*qqc + yvel*qqs
		ydif=xvel*-qqs + yvel*qqc
		deadx=jlimit{deadx+xdif ASR 3 ,1,63-#sqs}
		deady=jlimit{deady+ydif ASR 3 ,1,63-#sqs}

		delta.l=jint{deadx} +jint{deady}ASL 6
	CEND







	CNIF 1=0
		Use On

		SUB Init
		peat
		VWait:DisplayBitMap 0,db:db=1-db:Use lmaxlen db:BlockScroll
		BitMapOutput db
		 sx3=MouseX:sy3=MouseY
		Gosub Make
		Gosub Rot
		Gosub Draw

	 Until Joyb(0)<>0
	End
	CEND


	CNIF 1=0
;		If (jcos{0}<0.9) OR (jcos{0}>1.1)
			For i.w=0 To 320
				hgh=i/320
				BlLin{*bmr,i,128,i,jcos{hgh}*64+128,$ffffffff}
			Next
;		EndIf
	CEND


Return

##[$80D3]
Event
cardiff
Dc.b	98,26,24,	 98,24,24,	44,0		;classic
Dc.b	92,40,30,	 108,33,25 ,60	,0 ;grunty		2
Dc.b	102,61,47,	115,59,45,64,0	 ;zippy
Dc.b	100,80,60,	110,50,60,72,0	 ;nippy
Dc.b	25,127,101, 29,45,122,68,0	;slippery
Dc.b	117,23,17,	104,17,10 ,30	,0 ;pathetic	2
Event





