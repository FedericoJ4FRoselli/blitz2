; ascii translation of /Users/simon/Google Drive/amiga/w/abc/sega/old.bb,/Users/simon/Google Drive/amiga/w/sega/old.bb
;big things
;	password/champs etc
;	options page
;	turbo mode
;	pause mode

;medium things
;	headers for ugly things.. ("options")
;	starting grids
;	major shadow glitches
;	wall bounce
;	scoreboard
;	collision strength depends on speed ?

;small things
;	#skipval..
;	signside is crap..
;	wipes
;	#wcram dma frame synched
;	bonus point for best lap


;simons list
;	need sprite which says "PTS", "LAPS"


;misc
;	samples
;	smoke/dust





DEFTYPE.l temp
DEFTYPE.q blah

.N


#upload=Off
rsd=Peek.w($c00008)
retch.w=Off



CNIF #upload
	#loadtime=5
	#animtime=2
	#titletime=1000
	#title=On
	#frontend=On
	#race=On
	#bilbo=On

	#collisions=On
	#mus=Off
	#snd=Off


CELSE
	#loadtime=3
	#animtime=8
	#titletime=100

	#title=On
	#frontend=On
	#race=Off
	#bilbo=On

	#collisions=On
	#mus=Off
	#snd=Off

CEND

#maxcar=7
#contcomp=10


#spoon=63



#bars=Off
#maketri=Off

#uscar=5

#a=1
#j=2
#s=3
#n=4

#c=#s

#hicol=7
;#selcol=6
;#deselcol=5
#selcol=0;6
#deselcol=2;5

CNIF #c=#j
	If Peek.w($f00004)=Peek.w($f00004)
		End
	EndIf
CEND


Statement Safe{}
	CNIF #c=#j
		MOVE.l #320000,d0
		toplup
			MOVE d0,$f0002a
			SUBQ.l #1,d0
		BGE toplup
	CEND
	CNIF #c=#a
		For cnt.w=0 To 15
			VWait:##[$80BB]:##[$80BC] VPos>50:Poke.w $dff180,cnt
		Next
		MouseWait
	CEND
	CNIF #c=#s
		uphere
		MOVE #$8701,$c00004
		MOVE #$8702,$c00004
		MOVE #$8703,$c00004
		MOVE #$8704,$c00004
		MOVE #$8705,$c00004
		MOVE #$8706,$c00004
		MOVE #$8707,$c00004
		MOVE #$8708,$c00004
		BRA uphere
	CEND

End Statement

Macro showblk
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8700,$c00004
	CEND
End Macro
Macro showwht
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8701,$c00004
	CEND
End Macro

Macro showred
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8709,$c00004
	CEND
End Macro

Macro showyel
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8708,$c00004
	CEND
End Macro

Macro showgre
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8707,$c00004
	CEND
End Macro


CNIF #frontend
	#delay1=15
	#delay2=3

	#raceit=-1
	#options=0
	#main=1
	#pause=2
	#change=3
	#finish=4
	#scoreb=5
	#rego=6
	#option=7
;	#champsel=8
	#leaderb=9
CEND



CNIF #c=#j
	BSR initjagos
CEND

;Safe{}

Gosub InitOs
Gosub InitMem

Gosub InitVars

CNIF #title
	##[$80BB]
		Gosub SetUpCloud
		Gosub DoCloud

		Gosub SetFirst
		Gosub NextRace

;				Gosub SetFirst
;				Gosub SetUpFront
;				Gosub DoFront
;			CEND
;		Else
;			Gosub DoAttract
;		EndIf

	##[$80BC] 1=0
CEND


CNIF #frontend

	Gosub SetUpFront

	Gosub DoFront
CELSE

	lapdir.w=-1
	bigdone.w=Off
	##[$80BB]
		Gosub GetNewTrack

		Gosub SetUpWorld

		Gosub SkidMain
		mytrk.w=mytrk.w+1
		If mytrk=24 Then mytrk=0
	##[$80BC] bigdone







;	End
CEND


.NTypes

NEWTYPE .quadratic ; x=at*t+bt+c :y=dt*t+et+f
	la.q:ma:lb:lc
	ld	:md:le:lf
	lb1 :lb2		 ;boundaries..
	lstraight.w
	lodd1.w:lodd3.w
	langst.q:langadd.q

	ra.q:na:rb:rc
	rd	:nd:re:rf
	rb1 :rb2
	rstraight.w
	rodd1.w:rodd3.w
	rangst.q:rangadd.q
End NEWTYPE:#hquad=SizeOf.quadratic ASR 1

NEWTYPE .xtra
	cai.q:caj:cbi:cbj:midi:midj	; just for fun
	dai	:daj:dbi:dbj:diri:dirj
	swivi:swivj
	centi:centj	;centre or part-circle
	desti:destj	; destination for computer cars..

End NEWTYPE

NEWTYPE .theader
	nmp.l						;8k+ contours NOT CRUNCHED
	blockmap.l			 ;8k crunched
	blocks.l[8]			;40k+ crunched
	info.l
End NEWTYPE

NEWTYPE .view
	mx.q:my:sx:sy:px:py:dx:dy	; for new scrlnslc :-)
End NEWTYPE
NEWTYPE .scr
	scrw.q:scrwh:scrh:scrhh
End NEWTYPE
;	scr.scr\scrw=scrw,scrwh,scrh,scrhh


DEFTYPE.view tempview
CNIF 1=0
	ibm version
	no myview.. sx, sy instead
	no channel.w...
;	CNIF #c=#s NOT in..
	ibmpad.w(10)

CEND


NEWTYPE .segasp					 ;sort points here
	dpth.w
	sy.w:l.w:spdata.w:sx.w:wptr.l	;points to ?mytable+spwid*8

	h0.w:p0.w[3]
	h1.w:p1.w[3]
	h2.w:p2.w[3]
	h3.w:p3.w[3]

;	dpth.w:car.w						;car=0 for car or numsprites for bridge
;	binfo.l[0]							;ptr to bridge info in rom
;	shady.w:rshady						;
;	sx:sy:spdata.w			;bridge
End NEWTYPE


NEWTYPE .newp
	nam1.l:nam2.l
	humnam1.l:humnam2.l
	sel.w:ed.w:moved.w:del.w:score.w
	car.w:col.w:humcol.w
	pl.w
End NEWTYPE

NEWTYPE .car
		 i.q :	 j:k:	 headi:	 headj:headk:	 movi:	 movj:
	swai.q:swaj:	swaheadi:swaheadj:			swamovi:swamovj

	myview.view
	dir.q[0]:head.w:bdir.w:rot.q:qc:qs:jox.q
	pitch.w:roll:mpitch:mroll:lap.w	:control.w:fr.w
	inair.w:channel.w:idle.w:drop.w:warp.w:pos.w:coll.w

CNIF #c=#s
	shady.w:upd.w:dpth.w:carnum.w
	*segasp.segasp
;	rshady.w:segapad.w
CELSE
	spr1.l:sprnum1.w:spr2.l:sprnum2.w
CEND

	spdat.l:bnk.w:vehicle.w:carcol.l:colowner.w

	nrev.q:rev.q:vel:traction
	lasttime.w:bestlap.w:tottime.w
	accel.q:engfric:bounce:predef.w[0]:newp.w

	op1car.l:op2car.l:fp2car.l

	*towed.car:*hanged.car
	disc.w:oldpos.w	;the funky position thingee..

	q.l			 :; Quadrilateral.. the shadow
	retard.q:steering:
	curdt.w:side.w:top.w
	difi.q:difj.q:swiv		 :; normal for if there's a collision..


	score.w:newscore.w[0]:shv.w
	voldpos.w[0]:tune.w	 ;<= sega
	newwarps.w[0]:peak.w
	numwarps.w
	gravity.q

CNIF 1=0
		 i.q :	 j:k:	 headi:	 headj:headk:	 movi:	 movj:
	swai.q:swaj:	swaheadi:swaheadj:			swamovi:swamovj

	myview.view
	dir.q[0]:head.w:bdir.w:rot.q:qc:qs:jox.q
	pitch.w:roll:mpitch:mroll:lap.w	:control.w:fr.w
	inair.w:channel.w:idle.w:drop.w:warp.w:pos.w:coll.w

	spr1.l:sprnum1.w:spr2.l

	sprnum2.w[0]:shady.w

	spdat.l:bnk.w:vehicle.w:carcol.l:colowner.w

	nrev.q:rev.q:vel:traction
	lasttime.w:bestlap.w:tottime.w
	accel.q:engfric:bounce:predef.w

	op1car.l:op2car.l:fp2car.l

	*towed.car:*hanged.car
	disc.w:oldpos.w	;the funky position thingee..

	q.l			 :; Quadrilateral.. the shadow
	retard.q:steering:
	curdt.w:side.w:top.w
	difi.q:difj.q:swiv		 :; normal for if there's a collision..


	score.w:newscore.w:voldpos.w:newwarps.w:numwarps.w
	gravity.q

;	space.w[10]
CEND
End NEWTYPE
NEWTYPE .shcar :car.w:h.w	:End NEWTYPE

NEWTYPE .ij		:i.q:j:k:l				:End NEWTYPE
NEWTYPE .frend :lti.w:ltj:rti:rtj:End NEWTYPE
NEWTYPE.guide
	mi.q:mj.q
	di:dj
	li:lj
	ri:rj:dtp.q	;is dtp needed?
End NEWTYPE


NEWTYPE .parse
	fi.q:fj:di:dj:i:j	 ; see below
	diri:dirj					 ; artificial!
	boom.w							; if impact with wall
	norm								; normal.w at point(!) (lookup in cos/sins table)
End NEWTYPE


NEWTYPE .ShadPt
	ri0.q:rj0:ri1:rj1:ri2:rj2:ri3:rj3:ri4:rj4:ri5:rj5
	rx0.w:ry0:rx1:ry1:rx2:ry2:rx3:ry3
End NEWTYPE
NEWTYPE .quad	:v0x.w:v0y:v1x:v1y:v2x:v2y:v3x:v3y:End NEWTYPE


NEWTYPE .phrase:a.l:b.l:End NEWTYPE
NEWTYPE .jbmap

	dwidth.w	 ;0
	dheight.w	;2
	iwidth.w	 ;4
	iheight.w	;6

	dtype.w		;8
	depth.w		;10
	pitch.w		;12

	idata.l		;14
	ilink.l		;18

	xpos.w		 ;22
	ypos.w		 ;24
	iscroll.w	;26
	flags.w		;28

	hscale.b	 ;30
	vscale.b	 ;31

	firstphrase.phrase ;32
	secondphrase.phrase
	thirdphrase.phrase

	pixwidth.w
	realflags.l
	bltwidth.w
	blitflags.l

End NEWTYPE







;NEWTYPE .sprite
;	vp.w
;	size.b:
;	spdata.w
;	hp.w
;End NEWTYPE




.DefTypes
DEFTYPE.w i,j,ipl,pl
DEFTYPE.car *p
DEFTYPE.l sincos
DEFTYPE.l trisize
DEFTYPE.ij bez
DEFTYPE.w pts,pts1,pts2,pts3,pts3
DEFTYPE.parse test

CNIF #c=#j
	DEFTYPE.l bld
	DEFTYPE.jbmap *bmr1,*bmr2,*bmr
	#framecnt=$440		;frames...

CEND

DEFTYPE.ij skidbasememory
DEFTYPE.l skbm



.Consts

	CNIF #c=#s

		DEFTYPE.l myinfo
		;
		; sega megadrive skidmarks code
		;

		; $0000 = 64x32 map	(4096)
		; $1000 = blocks
		; $e000 = sprite pointers (2048)?
		; $f000 = sprites		(640)
		; $f200 = spdata		 (start at #$760)
		; $fc00 = scroll

		#vd=$c00000	;vdp data port
		#cp=$c00004	;vdp control port
		#hv=$c00008	;hv counter

		#wvram=$40000000:#wcram=$c0000000:#wsram=$40000010
		#vram=$0:#cram=$80000000:#vsram=$40000000
		#z80=$a11100:#z80sram=$a00000:#z80dram=$ff8000

		Macro reg #$8000+`1*256:End Macro
		Macro setreg:MOVE.w #$8000+`1*256+`2,cp:End Macro
		Macro setmem:MOVE.l `1,cp:MOVE.w `2,vd:End Macro
		Macro pokemem:MOVE.l `1,cp:Poke.w #vd,`2:End Macro


		NEWTYPE .vp
			sx.w:sy.w:wid:x.w:y.w			 ;top left
		End NEWTYPE

		NEWTYPE.nvp
			y0.w:l0:s0:x0
			y1.w:l1:s1:x1
			y2.w:l2:s2:x2
			y3.w:l3:s3:x3
		End NEWTYPE



		NEWTYPE.batman
			numblocks.w
			pal.w[16]
			mmap.w[1200]
			bloks.w[10000]
		End NEWTYPE





	Statement NewName{dest.l,fin.w}
		Shared rsd



		blah=(?compnamf-?compnam)
		blah.q=(##[$8481](2836.183,rsd)+1)*blah

		blah=##[$C381](blah/12)
		base.l=?compnam+blah*6
		Poke.l dest,Peek.l(base):dest+4:base+4
		Poke.w dest,Peek.w(base):dest+2:base+2
		Poke.w dest,fin

		rsd+35.479


		Goto doneit
		compnam	:Dc.b "SIMONS","RAFAEL"
						 :Dc.b "GRAHAM","YELLOW"
						 :Dc.b "RADISH","RACHEL"
						 :Dc.b "BARNEY","ENNZED"
						 :Dc.b "RICHIE","PROLOG"
						 :Dc.b "CODIES"
						 :Dc.b "PERDIE"
						 :Dc.b "ACIDIC"
						 :Dc.b "CICADA"
						 :Dc.b "NEWTON"
						 :Dc.b "GENGIS"
						 :Dc.b "CHIRAC"


		compnamf
		doneit


	End Statement




CNIF #race
;	#dpth=SizeOf .car\dpth




	Macro car SizeOf .segasp\`1(a2):End Macro





Statement doSortSprites{cars.l}
	MOVE.l d0,d1
	sortem:MOVEQ#0,d0:MOVE.l d1,a1:MOVE.l(a1)+,a2:MOVE (a2),d2
	nxvals:MOVE.l a2,a3:MOVE d2,d3
	wowo:MOVE.l (a1)+,d7:BEQ endlist:MOVE.l d7,a2:MOVE (a2),d2
	CMP d2,d3:BPL nxvals
	flip:MOVEM.l a2-a3,-8(a1):MOVEQ#-1,d0:BRA wowo
	endlist:TST d0:BNE sortem:AsmExit
End Statement




Statement doSegaSprites{cars.l,vp.l,vram.l,flip.w}
	;
	MOVEM.l a4-a6,-(a7):MOVE d3,-(a7)
	MOVE.l d2,a2:LEA 640(a2),a3													;a2a3=ptrs
	MOVE.l d0,a0:MOVE.l d1,a1:MOVEM.l(a1),d0-d5/a4-a5		;d7
	;
nxtspri:																												 ;a6=?
	MOVE.l (a0)+,a1:CMP.l #0,a1:BEQ dunspri:MOVEM.l 2(a1),d6-d7/a6 ;a4-a6
	MOVEM.l d0-d1,-(a7)
	;
dotl:
	ADD.l d0,d6:ADD d1,d7:MOVEM.l d6-d7,(a2):ADDQ#8,a2
	CMP#448,d7:BCC cltl:CMP#96,d7:BCS cltl
	CMP (a6),d7:BCS dobl:MOVE d7,d0:SUB #288,d0:BCC cltl
	;
	NEG d0:TST8(a7):BEQ now0:MOVE d0,d1:
	AND#$fff8,d1:MOVE 14(a1,d1),d1:ADD d1,-4(a3):now0
	;
	ADD d0,d0:MOVE d6,d1:AND #$3ff,d1:OR mytab(pc,d0),d1
	MOVE d1,-6(a2):BRA dobl:cltl:MOVE#0,-8(a2)
dobl:
	ADD.l d2,d6:ADD d3,d7:MOVEM.l d6-d7,(a3):ADDQ#8,a3
	CMP#448,d7:BCC clbl:CMP#96,d7:BCS clbl
	CMP (a6),d7:BCS dotr:MOVE d7,d0:SUB #288,d0:BCC clbl
	;
	NEG d0:TST8(a7):BEQ now1:MOVE d0,d1:
	AND#$fff8,d1:MOVE 14(a1,d1),d1:ADD d1,-4(a3):now1
	;
	ADD d0,d0:MOVE d6,d1:AND #$3ff,d1:OR mytab(pc,d0),d1
	MOVE d1,-6(a3):BRA dotr:clbl:MOVE#0,-8(a3)
	BRA dotr
	;
	;Dc.w 288-24,16

mytab:Dc.w 0,0,0,0,0,0,0,0
			Dc.w $400,$400,$400,$400,$400,$400,$400,$400
			Dc.w $800,$800,$800,$800,$800,$800,$800,$800
			Dc.w $c00,$c00,$c00,$c00,$c00,$c00,$c00,$c00
	;
dotr:
	ADD.l d4,d6:ADD d5,d7:MOVEM.l d6-d7,(a2):ADDQ#8,a2
	CMP #449,d7:BCC cltr:CMP #288,d7:BCC dobr
	MOVE #288,d0:SUB d7,d0:CMP 2(a6),d0:BPL cltr
	TST8(a7):BNE now2:AND#$fff8,d0:MOVE 14(a1,d0),d1:ADD d1,-4(a2):now2
	MOVEM mytab2(pc,d0),d0-d1
	SUB d0,-6(a2):ADD d1,-2(a2):BRA dobr:cltr:MOVE#0,-8(a2)
	;
dobr:
	ADD.l a4,d6:ADD a5,d7:MOVEM.l d6-d7,(a3):ADDQ#8,a3
	CMP #449,d7:BCC clbr:CMP #288,d7:BCC donx
	;
	MOVE #288,d0:SUB d7,d0:CMP 2(a6),d0:BPL clbr
	TST8(a7):BNE now3:AND#$fff8,d0:MOVE 14(a1,d0),d1:ADD d1,-4(a3):now3
	MOVEM mytab2(pc,d0),d0-d1
	SUB d0,-6(a3):ADD d1,-2(a3):BRA donx:clbr:MOVE#0,-8(a3):BRA donx
	;
mytab2:Dc $400,8,0,0,$800,16,0,0,$c00,24,0,0
	;
donx:
	MOVEM.l (a7)+,d0-d1:ADDQ#2,d0:BRA nxtspri
	;
dunspri:
	MOVE.b #0,-5(a2):MOVE.b #0,-5(a3):MOVE(a7)+,d3:MOVEM.l (a7)+,a4-a6:AsmExit
	;
End Statement

Statement dodoSegaSprites{cars.l,vp.l,vram.l}
	;
	MOVEM.l a4-a6,-(a7):MOVE.l d2,a2:LEA 640(a2),a3			;a2a3=ptrs
	MOVE.l d0,a0:MOVE.l d1,a1:MOVEM.l(a1),d0-d5/a4-a5		;d7
	;
nxtspri2:																												 ;a6=?
	MOVE.l (a0)+,a1:CMP.l #0,a1:BEQ dunspri2:MOVEM.l 2(a1),d6-d7/a6	;a4-a6
dotl2:
	ADD.l d0,d6:ADD d1,d7:MOVEM.l d6-d7,(a2):ADDQ#8,a2
	CMP#96,d7:BCS cltl2:CMP #448,d7:BCS dobl2:cltl2:MOVE#0,-8(a2)
dobl2:
	ADD.l d2,d6:ADD d3,d7:MOVEM.l d6-d7,(a3):ADDQ#8,a3
	CMP#96,d7:BCS clbl2:CMP #448,d7:BCS donx2:clbl2:MOVE#0,-8(a3)
donx2:
	ADDQ#1,d0:BRA nxtspri2
dunspri2:
	MOVE.b #0,-5(a2):MOVE.b #0,-5(a3):MOVEM.l (a7)+,a4-a6:AsmExit
	;
End Statement


CEND

mytable:
	Dc.w 288-08,0
	Dc.w 288-16,8
	Dc.w 288-24,16
	Dc.w 288-32,24




Statement setupvps{nvbase.l,vpbase.l}
	MOVE.l d0,a0:MOVE.l d1,a1

	MOVEM SizeOf.vp\sx(a1),d2-d3
	MOVE #$80,d0:MOVE.w #$80,d1
	SUB d2,d0:SUB d3,d1:MOVE d0,SizeOf.nvp\x0(a0):MOVE d1,SizeOf.nvp\y0(a0)


	MOVEQ #0,d0:MOVE #120,d1:ADD d2,d0:ADD d3,d1
	LEA SizeOf.vp(a1),a1:MOVEM SizeOf.vp\sx(a1),d2-d3
	SUB d2,d0:SUB d3,d1:MOVE d0,SizeOf.nvp\x1(a0):MOVE d1,SizeOf.nvp\y1(a0)


	MOVE #168,d0:MOVE #-120,d1:ADD d2,d0:ADD d3,d1
	LEA SizeOf.vp(a1),a1:MOVEM SizeOf.vp\sx(a1),d2-d3
	SUB d2,d0:SUB d3,d1:MOVE d0,SizeOf.nvp\x2(a0):MOVE d1,SizeOf.nvp\y2(a0)

	MOVEQ #0,d0:MOVE #120,d1:ADD d2,d0:ADD d3,d1
	LEA SizeOf.vp(a1),a1:MOVEM SizeOf.vp\sx(a1),d2-d3
	SUB d2,d0:SUB d3,d1:MOVE d0,SizeOf.nvp\x3(a0):MOVE d1,SizeOf.nvp\y3(a0)




	AsmExit
End Statement


;		*nv0\x0= $80-vp(0)\sx
;		*nv0\y0= $80-vp(0)\sy
;
;		*nv1\x0=	 0-vp(1)\sx+vp(0)\sx
;		*nv1\y0= 120-vp(1)\sy+vp(0)\sy
;
;		*nv2\x0= 160-vp(2)\sx+vp(1)\sx
;		*nv2\y0=-120-vp(2)\sy+vp(1)\sy
;
;		*nv3\x0=	 0-vp(3)\sx+vp(2)\sx
;		*nv3\y0= 120-vp(3)\sy+vp(2)\sy



;;		*nv1\y0= 120,1,0,0
;;		*nv2\y0=-120,0,0,160
;;		*nv3\y0= 120,1,0,0








	CEND
	CNIF #c=#a
		#sc=2
	CEND





Function .q jsin{a.q} ;0..1=2*pi
Shared sincos.l
	myang=##[$C383](a)ASL 9:ad.l=sincos+((myang&511) ASL 2)
	f=##[$C383](myang):qs=Peek.w(ad	)*(1-f)+Peek.w(ad+4)*f
	Function Return ##[$C583](qs) ASL 1
End Function

Function .q jcos{a.q} ;0..1
Shared sincos.l
	myang=##[$C383](a)ASL 9:ad.l=sincos+((myang&511) ASL 2)
	f=##[$C383](myang):of=1-f
	qc=Peek.w(ad+2)*of+Peek.w(ad+6)*f
	Function Return ##[$C583](qc) ASL 1
End Function


Function.q jsqr{a.q}	;worlds slowest sqr command

	If a=0 Then Function Return 0
	ntry.q=1:try=0

	While ##[$C385](try-ntry)>0.01
		try=ntry:fx=try*try-a
		ntry=try-fx/try*0.5
	Wend
	Function Return try
End Function



Function.l GetMem32{size.l}
	CNIF #c=#j
		MOVEQ #0,d1:ADD.l #16,d0:##[$80C2] $c002

		ADD.l #31,d0
		AND #$ffe0,d0
		AsmExit
	CELSE
		MOVEQ #0,d1:##[$80C2] $c002:AsmExit
	CEND
End Function



Function.l GetMem{size.l}
	MOVEQ #0,d1:##[$80C2] $c002:AsmExit
End Function


CNIF #c=#s
			Function.w mycloset{cola.w,colb.w}
				 MOVE d0,d2:MOVE d1,d3:AND	#$e,d2:AND	#$e,d3:CMP d2,d3:BEQ dogren:ADDQ #2,d0:AsmExit
	dogren:MOVE d0,d2:MOVE d1,d3:AND #$e0,d2:AND #$e0,d3:CMP d2,d3:BEQ dored :ADD #32,d0:AsmExit
	dored :MOVE d0,d2:MOVE d1,d3:AND#$e00,d2:AND#$e00,d3:CMP d2,d3:BEQ dunit:ADD #512,d0:dunit:AsmExit
			End Function
			Function.w myfurther{col.w}
				CMP #$100,d0:BMI togren:SUB.w #$200,d0:AsmExit
 togren:CMP #$10 ,d0:BMI tored:SUB.w #$20,d0:AsmExit
 tored :CMP #1	 ,d0:BMI tonon:SUBQ #2,d0:tonon:AsmExit
			End Function

	Statement MyCopy{src.l,dest.l,siz.l} ;in words
		While siz>0
			Poke.w dest,Peek.w(src):src+2:dest+2:siz-1
		Wend
	End Statement
CEND

;NEWTYPE .char
;	y.w:t.w:l.w:x.w
;	sx.w:sy.w
;End NEWTYPE
NEWTYPE .chara
	y.w:t.w:l.w:x.w
End NEWTYPE

NEWTYPE.charb
	id.w:dx.w:dy.w:l.w
	fx.w:fy.w:cx.q:cy.q
End NEWTYPE



.InitMem
	skbm.l=&skidbasememory.ij
	sincos.l=?sincos
	sqlu.l=?sqludat
	CNIF #frontend
		fsize.l=?fsize
	CEND

	Dim chara.chara(80)
	Dim charb.charb(80)

	Dim Pl.car(#maxcar)
	*p0.car=Pl(0):*p1.car=Pl(1):*p2.car=Pl(2):*p3.car=Pl(3):*maxp.car=Pl(#uscar)
	CNIF #uscar>3:*p4.car=Pl(4):*p5.car=Pl(5):CEND

	Dim newp.newp(#maxcar)
	For cnt.w=0 To #uscar
		base.l=&newp(cnt)
;		If cnt&1
;			GetReg a0,base
;			MOVE.l #"AMIK",(a0):MOVE.l #"SHHH",4(a0)
;		Else
;			GetReg a0,base
;			MOVE.l #"AANA",(a0):MOVE.l #"NDDD",4(a0)
;		EndIf
;		newp(cnt)\nam1=$52414345
;		newp(cnt)\nam2=$525d0001+cnt ASL 16
		NewName{&newp(cnt)\nam1,1}
		newp(cnt)\humnam1=$40404040
		newp(cnt)\humnam2=$40404040
		newp(cnt)\sel=0:newp(cnt)\ed=-32
		newp(cnt)\col=cnt
		newp(cnt)\humcol=newp(cnt)\col
		CNIF #frontend
;		newp(cnt)\moved=-1
		newp(cnt)\del=#delay2
		CEND
		newp(cnt)\pl=cnt
	Next


	Dim edge.quadratic(70):*e.quadratic=edge(0)
	Dim grot.xtra(70)		 :*g.xtra		 =grot(0)
	Dim mass.guide(137),firstmass.w(70)	;,leadtime.w(70)
	Dim fram.w(64)
	Dim spoon.w(#spoon)

	Dim qsin(63),qcos(63)	 :; look up table for car motion
	For cnt.w=0 To 63
		qcos(cnt)=jcos{cnt/64}
		qsin(cnt)=jsin{cnt/64}
	Next

	*par.parse=test

	CNIF #c<>#s
		Dim shcars.shcar(7):shcar.l=&shcars(0)


	CEND

	Dim tdist.shcar(7) :tdist.l=&tdist(0)
	Dim startline.shcar(7)

	CNIF #c=#j
		*bmr1.jbmap=GetMem32{SizeOf.jbmap}
		*bmr2.jbmap=GetMem32{SizeOf.jbmap}
		*bmr.jbmap=*bmr1

		CreateBmap{320,200,3,1,0,*bmr1.jbmap}
		CreateBmap{320,200,3,1,0,*bmr2.jbmap}



		MOVE #$ffff,$f00058
		MOVE.l #$418f418f,$f00058

		MOVE #$6c7,$f00028	 ;RGB!

	CEND

	CNIF #c=#a
		allocst 0,4
		ScreensBitMap 0,0
		BitMapOutput 0:Locate 0,0
	CEND




	CNIF #maketri
		trisize.l=(16*17/2)*8;SizeOf.xy
		tritemp.l=$f1cf80-8-trisize;GetMem{dist.l} ;internal dsp ram!
		Gosub InitLatMem
	CEND


	CNIF #c=#s
		*nv0.nvp=GetMem32{SizeOf.nvp}
		*nv1.nvp=*nv0+8
		*nv2.nvp=*nv0+16
		*nv3.nvp=*nv0+24


		*nv0\y0= $80,0,0,$80
		*nv1\y0= 120,0,0,0
		*nv2\y0=-120,1,0,160
		*nv3\y0= 120,0,0,0

		Dim vp.vp(#uscar) ;don't ask me...
		Dim quadverts.w(16)
		buffa1.l=GetMem32{640*4}
		buffb1.l=buffa1+ 640*1
		buffa2.l=buffa1+ 640*2
		buffb2.l=buffa1+ 640*3


;		Dim map.w(63,63)


		Dim map.w(63,127)	;16K
		blockmap.l=&map(0,0)

;;		hmmmmmmmmmmm
;		Dim map.w(63,72)	;0..72 = 2*64*73= 9344..
;		blockmap.l=&map(0,0)
;;		blockmap.l=GetMem{9216+64}


		tkptr.l=Peek.l(Peek.l($ff0004))
		tkbin.l=tkptr+1056
;		clist.l=Peek.l($ff0008) ;implied..
;		cars.l=Peek.l(clist+0*4)

; y.w:l.w:d.w:x.w:wptr.l	;points to ?mytable+spwid*8

		Dim spr.segasp(64)
		For ipl=0 To #uscar
			Pl(ipl)\segasp=&spr(ipl)
			CNIF #uscar<4
				dkt.w=(ipl&2)ASR 1 + (ipl&1) ASL 1
			CELSE
				dkt.w=(ipl&1)*3+(ipl&6)ASR 1
			CEND

			spr(ipl)\wptr=?mytable+3*4-4

			spr(ipl)\l=$b05
			CNIF #uscar<4
				spr(ipl)\spdata=$a798+21*dkt+(ipl&1)*$2000
			CELSE
				spr(ipl)\spdata=$a762+21*dkt+(ipl&1)*$2000 ;ASR 1
			CEND

			spr(ipl)\h0=3
			spr(ipl)\h1=6
			spr(ipl)\h2=8
			spr(ipl)\h3=12

			spr(ipl+#uscar+1)\wptr=spr(ipl)\wptr
			spr(ipl+#uscar+1)\l=$a05
			spr(ipl+#uscar+1)\h0=spr(ipl)\h0
			spr(ipl+#uscar+1)\h1=spr(ipl)\h1
			spr(ipl+#uscar+1)\h2=spr(ipl)\h2
			spr(ipl+#uscar+1)\h3=spr(ipl)\h3
			spr(ipl+#uscar+1)\spdata=(spr(ipl)\spdata&$1fff) + $e00c
			spr(ipl+#uscar+1)\dpth=0


;			spr(ipl)\spdata=$a798+18*dkt+(ipl&1)*$2000

;			Pl(ipl)\carsn=$a770+18*ipl +(ipl&1)*$2000	;bit $2000


			If ipl<2
				CNIF #uscar<4
					Pl(ipl)\q=GetMem{672*2}
				CELSE
					Pl(ipl)\q=GetMem{672*3}
				CEND
			Else
				Pl(ipl)\q=Pl(ipl&1)\q+672*(ipl&6) ASR 1
			EndIf

		Next
		Pl(0)\bnk=0
		Pl(1)\bnk=0
		Pl(2)\bnk=1
		Pl(3)\bnk=1
		Pl(4)\bnk=3
		Pl(5)\bnk=2


		Dim cptr.l(64)
		Dim hisview.view(#uscar)


	CEND

	CNIF #frontend
		Dim maxit(15)	;cardinal number..
		maxit(#main)=3
		maxit(#pause)=4
		maxit(#change)=8
		maxit(#finish)=4
		maxit(#scoreb)=0
		maxit(#rego)=0
		maxit(#option)=5
;		maxit(#champsel)=4
		maxit(#leaderb)=2
	CEND


Return






;jaguar stuff

CNIF #c=#j
	Macro rungpu
		MOVE.l `1 LSL 2+$f03000,$f02110:MOVE.l #1,$ff8:MOVE.l #1,$f02114
	End Macro

	Macro waitgpu
		'w_g`@:MOVE.l $ff8,d0:BTST #0,d0:BNE 'w_g`@
	End Macro

	Macro rundsp
		MOVE.l `1 LSL 2+$f1b000,$f1a110:MOVE.l #1,$ff0:MOVE.l #1,$f1a114
	End Macro

	Macro waitdsp
		'w_d`@:MOVE.l $ff0,d0:BTST #0,d0:BNE 'w_d`@
	End Macro

	Macro waitblit
		MOVE.l $f02238,d0
		w_b`@
		MOVE.l $f02238,d0:BTST #0,d0:BEQ w_b`@
	End Macro


.JagBlitter

	Include jblit.inc

	Macro bm SizeOf .jbmap\`1(a0):End Macro
	Statement RefrBmap{*bmap.jbmap}
		;
		MOVE.l d0,a0
		;
		MOVE.l !bm{idata},d0:LSR.l#3,d0:MOVEQ#43-32,d2:ASL.l d2,d0
		MOVE.l !bm{ilink},d1:LSR.l#3,d1:MOVE.l d1,d2:LSR.l#8,d2:OR d2,d0
		MOVEQ#24,d2:LSL.ld2,d1
		MOVE !bm{dheight},d2:EXT.l d2:MOVEQ#14,d3:ASL.ld3,d2:OR.ld2,d1
		MOVE !bm{ypos},d2:ASL#3,d2:OR d2,d1:OR !bm{dtype},d1
		MOVEM.l d0-d1,!bm{firstphrase}
		;
		MOVE !bm{iscroll},d0:EXT.l d0:ASL.l#8,d0:ASL.l#3,d0
		OR !bm{flags},d0:ASL.l#6,d0
		MOVE !bm{iwidth},d1:EXT.l d1:ROR.l#4,d1:OR d1,d0
		ROL.l#8,d1:ROL.l#6,d1
		OR!bm{dwidth},d1:ASL.l#3,d1:OR!bm{pitch},d1:ASL.l#3,d1:OR!bm{depth},d1
		ASL.l#8,d1:ASL.l#4,d1:OR !bm{xpos},d1
		MOVEM.l d0-d1,!bm{secondphrase}

		MOVEQ #0,d0:MOVE.w !bm{hscale},d0:ROR.w #8,d0
		MOVE.l d0,!bm{thirdphrase+4}

		;
		AsmExit
		;
	End Statement


	Statement HeadBmap{*bmap1.jbmap}
		ADD.l #32,d0:SWAP d0:MOVE.l d0,$f00020:AsmExit
	End Statement



	Statement BlPoly{*bm.jbmap,dat.l,cols.l}
	Shared bld

		!waitblit
		!waitgpu


		Poke.l $f03f00,dat
		Poke.l $f03f04,cols

		!waitblit
		Poke.l bld		,*bm\idata											;destination
		Poke.l bld+	4,*bm\blitflags;+$10000					;
		Poke.l bld+ $8,##[$C581](*bm\bltwidth,*bm\iheight)	;clip
		Poke.l bld+$10,##[$C581](-24,1)	;step

		!rungpu{0}

	End Statement


	Statement BlRot{*bms.jbmap,*bmd.jbmap,xfac,yfac}	;a2=dest a1=source
	Shared bld

	;	srcxadd=3
	;	desxadd=1

		!waitblit

		Poke.l bld+$24,*bmd\idata					 ;dest
		Poke.l bld+$28,*bmd\blitflags +(1 ASL 16)			;flags
		Poke.l bld+$30,0										;start xy
		temp.l=1 LSL 16										 ;plus one y
		temp=temp+(-*bmd\bltwidth&$ffff)		;minus width
		Poke.l bld+$34,temp


		Poke.l bld,*bms\idata							 ;source
		Poke.l bld+$4,*bms\blitflags +(3 ASL 16)			 ;flags
		Poke.l bld+$8,jin{*bms\bltwidth,*bms\iheight} ;clip x
		Poke.l bld+$c,jin{30,30}										 ;start xy

		pw=*bmd\bltwidth

		xdif=-yfac-pw*xfac
		ydif=xfac-pw*yfac

		Poke.l bld+$10,jin{xdif,ydif}
		Poke.l bld+$14,jfr{xdif,ydif}

		Poke.l bld+$18,0 ;start value! HAH!

		Poke.l bld+$1c,jin{xfac,yfac}
		Poke.l bld+$20,jfr{xfac,yfac}

		Poke.l bld+$3c,(*bmd\iheight ASL 16) + *bmd\bltwidth ;counter

		temp.l=1 + (1 ASL 6)
		temp=temp + (1 ASL 8) +(1 ASL 9)
		temp=temp +(1 ASL 11)
		temp=temp + (1 ASL 23)+ ( 1 ASL 24)
		Poke.l bld+$38,temp


	End Statement


CEND


.IOStuff

	Statement GetJoy{x.l,y.l,butt.l,port.w}
	 CNIF #c=#j

			MOVE.l d0,a0
			MOVE.l d1,a1
			MOVE.l d2,a2
			MOVEQ #0,d3
			MOVEQ #0,d4
			MOVEQ #0,d5

			MOVE #$800e,$f14000:MOVE $f14000,d0
			BTST	#8,d0:BNE notup:ADDQ #1,d4:notup
			BTST	#9,d0:BNE notdo:SUBQ #1,d4:notdo

			BTST #10,d0:BNE notle:ADDQ #1,d3:notle
			BTST #11,d0:BNE notri:SUBQ #1,d3:notri

			MOVE #$800e,$f14000:MOVE $f14002,d0
			BTST #1,d0:BNE notbc:ADDQ #2,d5:notbc
			MOVE #$800b,$f14000:MOVE $f14002,d0
			BTST #1,d0:BNE notba:ADDQ #1,d5:notba


			MOVE.w d3,(a0)
			MOVE.w d4,(a1)
			MOVE.w d5,(a2)
			AsmExit
		CEND
		CNIF #c=#a
			Poke.l x,Joyx(1-port)
			Poke.l y,Joyy(1-port)
			Poke.l butt,Joyb(1-port)
		CEND
		CNIF #c=#s
			temp=##[$C484](port)
			Poke.l x,(temp&4=4)-(temp&8=8)
			Poke.l y,(temp&16=16);JLimit((temp&1=1)-(temp&2=2)+(temp&16=16),-1,1)
			Poke.l butt,0
;		If a AND 1 Then ya=-1
;		If a AND 2 Then ya=1
;		If a AND 4 Then xa=-1:fr=JLimit(fr+1,0,799)		;xa=-1
;		If a AND 8 Then xa=1:fr=JLimit(fr-1,0,799)


		CEND
	End Statement

	Function.w trx{pl.w}
		Shared segjoy.w

		If segjoy=-2 Then pl+4
		If segjoy=-4
			If pl<2 Then pl+4:Else pl+6
		EndIf

		Function Return pl
	End Function


Macro MyVWait
		CNIF #c=#s
			MOVE #0,$ff0000
			myvbwaitlp`@:TST $ff0000:BPL myvbwaitlp`@:MOVE#0,$ff0000
		CEND
		CNIF #c=#a
			VWait
		CEND
End Macro

Macro MyQWait
		CNIF #c=#s
;			MOVE #0,$ff0000
			mywaitlp`@:TST $ff0000:BPL mywaitlp`@:MOVE#0,$ff0000
		CEND
		CNIF #c=#a
			VWait
		CEND
End Macro



	##[$80CA] *p
CNIF #race
Statement UpDateNuPlayer{lup.l} ;	 ;,diff.w ,slidmod.w,speedmod.w,accelmod.w
	Shared cvh(),Pl(),newp();*p0,*p7
	Shared champ.w,racenum.w,super.w,champtyp.w

	If champtyp=1
		If super Then lup+8
		t=racenum
		t=##[$C386](t/5,0,1)
		s=1-t
	Else

		s=1:t=0
	EndIf


	base.l=lup

	For pl=0 To #uscar
		*p.car=Pl(pl)


		If champtyp=0
			lup=base+32+*p\carnum*40
			For cnt=1 To 8
				If Peek.b(lup)<>cnt Then Safe{}
				lup+1
			Next


			lup=base+*p\carnum*40+champ*8
		EndIf



		If *p\control=#contcomp Then nlup.l=lup+3:Else nlup=lup
		blah.q=Peek.b(nlup)*s+Peek.b(nlup+8)*t
		fric=(blah ASR 7)*0.98+0.01

		blah.q=Peek.b(nlup+1)*s+Peek.b(nlup+1+8)*t
		topspeed=(blah) ASR 4

		acc=topspeed*(1/fric-1)

		blah.q=Peek.b(nlup+2)*s+Peek.b(nlup+2+8)*t
		initacc=(blah) ASR 8
		reta=initacc/acc/fric

		\engfric =fric; ASL 6
		\retard	=reta ASR 3;ASL 6

		blah.q=Peek.b(lup+6)*s+Peek.b(lup+6+8)*t
		\steering=blah ASR 5
		\bounce	=0.5
		\gravity =0.5
		\accel	 =acc	ASR 3;ASL 6
		If newp(pl)\nam1=$53415641 Then \accel*1.2




	Next

End Statement
CEND



;------------------------------------------------------


CNIF #frontend OR #title

Statement addmini{id.w,x.q,y.q,t.w,c.w}
	Shared chara(),charb(),minioff.w,nxlink.w,rsd
	rev=t&8:t&7
	sn.w=minioff+$8000+(c AND 6)ASL 12+(t+t+(c AND 1))*5*4
	If rev Then sn+2048
	x=(x LSL 3)+128:y=(y LSL 3)+124

	hit.w=-1:i.w=0
	##[$80BB]

		If charb(i)\id=id Then hit=i
		i+1
		If i=nxlink
			hit=nxlink:nxlink+2
			charb(hit	)\id=id
			charb(hit+1)\id=id
		EndIf
	##[$80BC] hit>-1

	ld.w=hit+1+$f00
	chara(hit)\y=y,ld,sn,x
	charb(hit)\fx=x,y
	hit+1:sn+16
	If t<6 Then ld.w=hit+1+$300 Else ld.w=hit+1+$f00
	chara(hit)\y=y,ld,sn,x+32
	charb(hit)\fx=x+32,y

	If hit+1=insert
		If ##[$8481](324,rsd)<0
			charb(hit)\cx=(##[$8481](rsd,324)*20+20)*8+128
			charb(hit)\cy=376
			If ##[$8481](7328,rsd)<0 Then charb(hit)\cy=112
		Else
			charb(hit)\cy=(##[$8481](rsd,12)*15+15)*8+128
			charb(hit)\cx=456
			If ##[$8481](7328,rsd)<0 Then charb(hit)\cx=112
		EndIf
		rsd+23.235
	EndIf

	charb(hit-1)\cx=charb(hit)\cx-32
	charb(hit-1)\cy=charb(hit)\cy


End Statement


Statement dofence{x.w,y.w,w.w,c.w,p1.w,p2.w}
	Shared map(),numchars.w
	DEFTYPE.w choff,hi,ch,cc,i
	;
	c+1
	If (c&7)=0 Then c-8
	ch=c AND 7:c=c ASR 3:hi=2+c+c
	;
	choff=$8180+numchars
	While ch>2:choff+$2000:ch-2:Wend
	;
	If c=1 Then choff+30
	If c=2 Then choff+90
	;
	map(x	+4,y+hi)=choff+90
	map(x+w-5,y+hi)=choff+90

	For i=0 To w-1
		Select i
			Case 0:		 co=ch*5+0
			Case 1:		 co=ch*5+1
			Case w-1:	 co=ch*5+4
			Case p1-1:	If c<2 Then co=ch*5+3
			Case p1:		co=2
			Case p1+1:	co=1
			Case p2-1:	If c<2 Then co=3
			Case p2:		co=ch*5+2
			Case p2+1:	co=ch*5+1

		End Select
		cc=choff+co*hi:For j=0 To hi-1:map(x,y+j)=cc+j:Next:x+1
	Next



End Statement


home:nxlink.w=0:Return

Function.w translate{ch.w}
	blah.w=-1
	If ch=64 Then blah=30;
	If ch=91 Then blah=91 ;AHHAHA
	If ch>64 AND ch<91 Then blah=ch-65
	If ch>91 AND ch<102 Then blah=ch-59
	If ch>47 AND ch<58 Then blah=ch-15
	If ch=46 Then blah=26 ;.
	If ch=43 Then blah=27 ;!
	If ch=63 Then blah=28 ;?
	If ch=58 Then blah=29 ;:
;	If ch=95 Then blah=30 ;_
	If ch=40 Then blah=31 ;(
	If ch=41 Then blah=32 ;)
	Function Return blah
End Function





Statement movechars{}
Shared chara(),charb(),nxlink.w
	*ca.chara=&chara(0)
	*cb.charb=&charb(0)
	For cnt.w=0 To nxlink-1

		cx=(*cb\fx+0.5-*cb\cx) ASR 3 +*cb\cx
		*ca\x=cx:*cb\cx=cx
		cy=(*cb\fy+0.5-*cb\cy) ASR 3 +*cb\cy
		*ca\y=cy:*cb\cy=cy

		*ca+SizeOf.chara
		*cb+SizeOf.charb
	Next
End Statement


Statement displaychars{vmem.l}
	Shared chara(),charb(),nxlink,fps.w
	temp.l=0



;	!MyVWait
;	For cnt.w=0 To nxlink-1
;		If charb(cnt)\fps AND fps
;			chara(cnt)\l+8*43
;			SegaTransfer &chara(cnt),vmem,4:vmem+8
;			chara(cnt)\l-8*43
;		Else
;			SegaTransfer &chara(cnt),vmem,4:vmem+8
;		EndIf
;	Next
	If nxlink>0
		##[$C482] &chara(0),#wvram+vmem,(nxlink) ASL 2
		vmem+(nxlink ASL 3)
	EndIf
	##[$C489] &temp,vmem,2:##[$C489] &temp,vmem+4,2


End Statement



##[$80CA] chara(i)
Statement colourstring{id,col,hil,y.q}
	Shared chara(),charb(),fsize.l,nxlink.w,fps,fontptr.w

	If fps&4
		osn.w=((col AND 6) ASL 12) + $8002+fontptr
		If col AND 1 Then osn+8*43 ;was 5
	Else
		osn=$c002+fontptr
	EndIf

	If hil>-1
		sn.w=$c002+8*43+fontptr
	Else
		sn.w=((col AND 6) ASL 12) + $8002+fontptr
		If col AND 8 Then big.w=1 Else big=0:sn+4*43;:y-2
		If col AND 1 Then sn+8*43 ;was 5
	EndIf


	mybase.w=-1
	If y>-1 Then y=y ASL 3 +128


	For i.w=0 To nxlink-1

		If charb(i)\id=id
			If mybase=-1 Then mybase=i:hil+i

			this.w=charb(i)\l
			If this>-1
				If (hil=i)
					chara(i)\l=this+osn
					If y>-1 Then charb(i)\fy=y -7
				Else
					chara(i)\l=this+sn
					If y>-1 Then charb(i)\fy=y
				EndIf
			EndIf
		EndIf
	Next
End Statement

Statement remapstring{id1.w,l.w,id2.w}
	Shared charb(),nxlink

	done.w=0:insert=-1
	##[$80BB]
		insert+1
		If charb(insert)\id=id1 Then done=1
		If insert=nxlink Then done=2
	##[$80BC] done<>0

	If done=1
		For i=0 To l-1
			charb(insert+i)\id=id2
		Next
	EndIf

End Statement

Statement positionstring{id.w,x.q,y.q}
	Shared chara(),charb(),fsize.l,nxlink.w
	x=(x LSL 3)+128:y=(y LSL 3)+124
	For i.w=0 To nxlink-1
		If charb(i)\id=id
			charb(i)\fx=charb(i)\dx+x
			charb(i)\fy=charb(i)\dy+y
		EndIf
	Next
End Statement


Statement segaprint{charbase.l,l,x,y,col}
	Shared fsize,map(),fontptr.w
;	sn.w=((col AND 6) ASL 12) + $8182
	sn.w=((col AND 6) ASL 12) + $8002+fontptr


	If col AND 8 Then big.w=1 Else big=0:sn+4*43:y-2
	If col AND 1 Then sn+8*43 ;was 5

	For look.l=charbase To charbase+l
		blah.w=translate{Peek.b(look)}
		If blah<0
			x+6*(1+big)
		Else
			oldx=x
			If blah=91 ;hard space
				x+2:blah=$180
			Else
				x+2;eek.w(fsize+blah+blah+(1-big)*86)+2
				blah ASL 2 +sn
			EndIf
			map(x,y)	=blah	:map(x+1,y	)=blah+2
			map(x,y+1)=blah+1:map(x+1,y+1)=blah+3

		EndIf
	Next

End Statement

Statement addstring{id.w,charbase.l,l.w,col.w}
	Shared chara(),charb(),fsize.l,nxlink.w,rsd.q,fontptr

	done.w=0:insert=-1
	##[$80BB]
		insert+1
		If charb(insert)\id=id Then done=1
		If insert=nxlink Then done=2
	##[$80BC] done<>0

	x.q=0:y.q=0
	sn.w=((col AND 6) ASL 12) + $8002+fontptr

	If col AND 8 Then big.w=1 Else big=0:sn+4*43:y-2
	If col AND 1 Then sn+8*43 ;was 5

	osn=$c002+fontptr:;If fps&4 Then osn+8*43

	ld.w=insert+1+$500:xx=x:ll=insert	;was big*$500
	For look.l=charbase To charbase+l
		blah.w=translate{Peek.b(look)}
		If blah<0
			x+6*(1+big)
		Else
			If insert<79
				oldx=x
				If blah=91 ;hard space
					x+6*(1+big):blah=$180
				Else
					x+Peek.w(fsize+blah+blah+(1-big)*86)+2
					blah ASL 2 +sn
				EndIf
				chara(insert)\y=y,ld,blah,oldx
				charb(insert)\id=id
				charb(insert)\l=blah-sn


				If blah=$180 Then chara(insert)\t=ld&$ff:charb(insert)\l=-1 ;hard space

				ld+1:insert+1
			EndIf
		EndIf
	Next
	ww.w=(xx-x) ASR 1
	For i=ll To insert-1
		charb(i)\dx=chara(i)\x+ww
		charb(i)\dy=chara(i)\y

		If done=2
			If i&1
				charb(i)\cx=(##[$8481](rsd,324)*20+20)*8+128
				charb(i)\cy=376
				If i&2 Then charb(i)\cy=112
			Else
				charb(i)\cy=(##[$8481](rsd,12)*15+15)*8+128
				charb(i)\cx=456
				If i&2 Then charb(i)\cx=112
			EndIf
			rsd+23.235
		EndIf

	Next

	If done=2 Then nxlink=insert

End Statement



CEND



CNIF #bilbo

	Statement squigd{dest.l,count.w,start.q,adder.q}

		MOVE.l d0,a0:SUBQ#1,d1:MOVE.l d3,d6:MOVE.l d2,d5

		nxlin6:MOVE.l d5,d7:SWAP d7:ADD.l d6,d5:MOVE d7,(a0):ADDQ #4,a0
		DBRA d1,nxlin6
		AsmExit

	End Statement

	;	 base.l=?selmap +item*17*12*2
	;					roll=12+(item&1) ASL 5
	;					For y=10 To 10+11
	;						For x=roll To roll+16
	;
	;							map(x,y)=Peek.w(base)+$8000+selptr:base+2
	;						Next
	;					Next


	Statement redoitem{map.l,item.w,base.l,selptr.w}
		;

		MOVE.l d0,a0
		AND #1,d1:ASL#6,d1:ADD d1,a0

		MOVE.l d2,a1:MOVEQ#11,d4
	nxyr:
		MOVEQ#16,d5:MOVE.l a0,a2:ADD #64*2,a0
	nxxr:
		MOVE (a1)+,d0:ADD d3,d0:MOVE d0,(a2)+:DBRA d5,nxxr:
		DBRA d4,nxyr:AsmExit
	End Statement


	Macro myr
	;	redoitem{&map(8,10),`1,?selmap +`1*17*12*2,selptr+$8000}
	End Macro



	NEWTYPE .rect
		map.l:ww.w:wh.w:x:y:w:h
	End NEWTYPE

	Macro s SizeOf .rect\`1(a0):End Macro
	Macro d SizeOf .rect\`1(a1):End Macro

	Statement sblat{src_rect.l,dest_rect.l}
		MOVEM.l a4-a6,-(a7):MOVE.l d0,a0:MOVE.l d1,a1
		MOVE.l !s{map},a2:MOVE !s{y},d0:ASL#2,d0:ADD d0,a2
		MOVE.l !d{map},a3:MOVE !d{y},d0:ASL#2,d0:ADD d0,a3
		MOVE !s{x},d0:MOVE !d{x},d1:MOVE !s{w},d6:LSR #1,d6:SUBQ #1,d6
	nxrow:
		MOVE d0,d2:LSR#3,d2:MULU !s{wh},d2:ASL#5,d2:LEA 0(a2,d2),a4
		MOVE d1,d2:LSR#3,d2:MULU !d{wh},d2:ASL#5,d2:LEA 0(a3,d2),a5
		MOVE d0,d2:AND#7,d2:LSR#1,d2:ADD d2,a4
		MOVE d1,d2:AND#7,d2:LSR#1,d2:ADD d2,a5
		MOVE !s{h},d7:SUBQ#1,d7
	nxbb:
		MOVE.b (a4),(a5):ADDQ#4,a5:ADDQ#4,a4:DBRA d7,nxbb
		ADDQ#2,d0:ADDQ#2,d1:DBRA d6,nxrow
		MOVEM.l (a7)+,a4-a6:AsmExit
	End Statement



	Statement sblot{src_rect.l,dest_rect.l}
		MOVEM.l a4-a6,-(a7):MOVE.l d0,a0:MOVE.l d1,a1
		MOVE.l !s{map},a2:MOVE !s{y},d0:ASL#2,d0:ADD d0,a2
		MOVE.l !d{map},a3:MOVE !d{y},d0:ASL#2,d0:ADD d0,a3
		MOVE !s{x},d0:MOVE !d{x},d1:MOVE !s{w},d6:SUBQ #1,d6
	nxrow2:
		MOVE d0,d2:LSR#3,d2:MULU !s{wh},d2:ASL#5,d2:LEA 0(a2,d2),a4
		MOVE d1,d2:LSR#3,d2:MULU !d{wh},d2:ASL#5,d2:LEA 0(a3,d2),a5
		MOVE #$f0,d3:MOVE d0,d2:AND#7,d2:LSR#1,d2:BCC ko:MOVEQ#15,d3:ko:ADD d2,a4
		MOVE d1,d2:AND#7,d2:LSR#1,d2:ADD d2,a5
		MOVE !s{h},d7:SUBQ#1,d7
	nxbb2:
		MOVE.b (a4),d4:AND d3,d4:BEQ nopix:MOVE.b (a5),d5
		NOT d3:AND d3,d5:NOT d3:OR d4,d5:MOVE.b d5,(a5):nopix
		ADDQ#4,a5:ADDQ#4,a4:DBRA d7,nxbb2
		ADDQ#1,d0:ADDQ#1,d1:DBRA d6,nxrow2
		MOVEM.l (a7)+,a4-a6:AsmExit
	End Statement

	Statement segaprintprint{src.l,l.l,x,y}
	Shared map(),myfontdat.l,fsize


		big =1

		sn.l=8
		If big Then sn+(8*43) ASL 1;2
		win.rect\map=&map(0,0),32,16,x,y
		big=0

		mysrc.rect\map=myfontdat,1024,2,ch ASL 4+8,0,16,16
		For cnt.l=0 To l-1
			x=(x+1)&$fffe
			blah=translate{Peek.b(src) }

			If blah<0 OR blah=91
				x+6*(1+big)
			Else
				mysrc\x=blah ASL 4 +sn
				win\x=x

				sblot{&mysrc,&win}
;				sblat{&mysrc,&win}
				x=x+Peek.w(fsize+blah+blah+(1-big)*86)+2
			EndIf

			src+1
		Next


	;	mysrc.rect\map=?seldat,16,44,0,88*item,128,88
	;	SegaDMA &map(0,0),#wvram+billptr*32,8192


	;	mysrc.rect\map=?seldat,16,44,0,0,128,88
	;			sblat{&mysrc,&win}
	;			SegaDMA &map(0,0),#wvram+billptr*32,8192


	End Statement


CEND





CNIF #bilbo


	Statement docount{bill.l,count.w,open.w,closed.w}		 ;bill=64x64
		MOVE.l d0,a0:MULU #11*16,d1:LEA countdown(pc,d1),a1
		MOVE.w d2,d0:SWAP d2:MOVE d0,d2
		MOVE.w d3,d0:SWAP d3:MOVE d0,d3
		MOVEQ#15,d7:nxydc:MOVEQ#10,d6:nxxdc
		MOVE.b(a1)+,d0:BEQ clos:MOVE.l d2,(a0)+:BRA nclo:clos:MOVE.l d3,(a0)+:nclo
		DBRA d6,nxxdc:ADD #128-11*4,a0:DBRA d7,nxydc
		AsmExit

	countdown:									 ;11x16
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,1,1,1,1,1,1,1,1,0
		Dc.b 0,0,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,0,1,1,1,1,1,1,1,1,1
		Dc.b 0,0,1,1,1,1,1,1,1,1,1
		Dc.b 0,0,0,0,1,1,1,1,1,1,0
		Dc.b 0,0,0,0,0,0,1,1,1,1,0
		Dc.b 0,0,0,0,0,1,1,1,1,0,0
		Dc.b 0,0,0,0,0,1,1,1,1,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,1,1,1,1,0,0,0,0
		Dc.b 0,0,0,1,1,1,1,1,0,0,0
		Dc.b 0,0,1,1,1,1,1,1,1,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,0,1,1,1,1,0
		Dc.b 0,1,1,1,0,0,0,1,1,1,0
		Dc.b 0,1,1,1,0,0,0,1,1,1,0
		Dc.b 0,0,1,1,1,0,1,1,1,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 1,1,1,1,1,0,1,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 1,1,1,1,1,0,1,1,1,1,1
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,0,0,1,1,1,1,1,0,0,0
		Dc.b 1,1,1,1,1,1,1,1,1,1,1
		Dc.b 1,1,1,1,1,1,1,1,1,1,0
		Dc.b 1,1,1,1,1,1,1,1,1,1,0
		Dc.b 1,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,0,0,0,0,1,1,1,1,0,0
		Dc.b 0,0,0,0,0,1,1,1,1,0,0
		Dc.b 0,0,0,0,1,1,1,1,1,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,1,1,1,1,1,0,0,0
		Dc.b 0,0,0,1,1,1,1,1,0,0,0
		Dc.b 0,0,0,1,1,1,1,0,0,0,0
		Dc.b 0,0,1,1,1,1,1,0,0,0,0
		Dc.b 0,0,1,1,1,1,1,0,0,0,0
		Dc.b 0,0,1,1,1,1,0,0,0,0,0
		Dc.b 0,1,1,1,1,1,0,0,0,0,0
		Dc.b 0,1,1,1,1,1,0,0,0,0,0
		Dc.b 0,0,0,0,0,1,1,1,1,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,1,1,1,1,0,0,0,0
		Dc.b 0,0,0,1,1,1,1,0,0,0,0
		Dc.b 0,0,1,1,1,1,0,0,0,0,0
		Dc.b 0,0,1,1,1,1,1,1,0,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,1,1,1,1,0,0,1,1,1,1
		Dc.b 0,0,1,1,1,1,1,1,1,1,0
		Dc.b 0,0,1,1,1,1,1,1,1,1,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,0,0,0,0,0,0
		Dc.b 0,1,1,1,1,0,0,0,0,0,0
		Dc.b 0,1,1,1,1,0,0,0,0,0,0
		Dc.b 0,1,1,1,1,1,1,1,0,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,0,0,0,0,0,1,1,1,1,1
		Dc.b 0,0,0,0,0,0,0,1,1,1,1
		Dc.b 1,0,0,0,0,0,0,1,1,1,1
		Dc.b 1,1,0,0,0,0,1,1,1,1,1
		Dc.b 1,1,1,1,1,1,1,1,1,1,0
		Dc.b 1,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,1,1,0
		Dc.b 0,0,0,0,1,1,1,1,1,1,0
		Dc.b 0,0,0,1,1,1,1,1,1,1,0
		Dc.b 0,0,0,1,1,1,1,1,1,1,0
		Dc.b 0,0,0,1,1,0,1,1,1,1,0
		Dc.b 0,0,1,1,1,0,1,1,1,1,0
		Dc.b 0,0,1,1,1,0,1,1,1,1,0
		Dc.b 0,1,1,1,0,0,1,1,1,1,0
		Dc.b 0,1,1,1,0,0,1,1,1,1,0
		Dc.b 0,1,1,1,0,0,1,1,1,1,0
		Dc.b 1,1,1,1,1,1,1,1,1,1,1
		Dc.b 1,1,1,1,1,1,1,1,1,1,1
		Dc.b 1,1,1,1,1,1,1,1,1,1,1
		Dc.b 0,0,0,0,0,0,1,1,1,1,0
		Dc.b 0,0,0,0,0,0,1,1,1,1,0
		Dc.b 0,0,0,0,0,0,1,1,1,1,0
		Dc.b 0,0,0,1,1,1,1,0,0,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,0,0
		Dc.b 1,1,1,1,0,0,1,1,1,1,0
		Dc.b 1,1,1,1,0,0,1,1,1,1,0
		Dc.b 0,0,0,0,0,0,1,1,1,1,0
		Dc.b 0,0,0,1,0,1,1,1,1,0,0
		Dc.b 0,0,0,1,1,1,1,1,0,0,0
		Dc.b 0,0,0,1,1,1,1,1,1,0,0
		Dc.b 0,0,0,0,0,0,1,1,1,1,0
		Dc.b 0,0,0,0,0,0,1,1,1,1,0
		Dc.b 1,1,1,1,0,0,1,1,1,1,0
		Dc.b 1,1,1,1,0,0,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,1,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,0,0
		Dc.b 0,0,0,1,1,1,1,0,0,0,0
		Dc.b 0,0,0,1,1,1,1,1,1,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 1,1,1,1,1,0,1,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 0,0,0,0,0,0,0,1,1,1,1
		Dc.b 0,0,0,0,0,0,0,1,1,1,1
		Dc.b 0,0,0,0,0,0,1,1,1,1,1
		Dc.b 0,0,0,0,0,0,1,1,1,1,0
		Dc.b 0,0,0,0,0,1,1,1,1,1,0
		Dc.b 0,0,0,0,1,1,1,1,1,0,0
		Dc.b 0,0,0,1,1,1,1,1,0,0,0
		Dc.b 0,0,0,1,1,1,1,0,0,0,0
		Dc.b 0,0,1,1,1,1,1,1,1,1,1
		Dc.b 0,1,1,1,1,1,1,1,1,1,1
		Dc.b 1,1,1,1,1,1,1,1,1,1,1
		Dc.b 0,0,1,1,1,1,1,1,0,0,0
		Dc.b 0,0,1,1,1,1,1,1,0,0,0
		Dc.b 0,0,1,1,1,1,1,1,0,0,0
		Dc.b 0,0,1,1,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,0,1,1,1,1,0,0,0
		Dc.b 0,0,0,1,1,1,1,1,0,0,0
		Dc.b 0,0,1,1,1,1,1,1,1,0,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,1,1,1,1,0,1,1,1,1,0
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 1,1,1,1,0,0,0,1,1,1,1
		Dc.b 0,1,1,1,1,0,1,1,1,1,0
		Dc.b 0,1,1,1,1,1,1,1,1,1,0
		Dc.b 0,0,1,1,1,1,1,1,1,0,0
		Dc.b 0,0,0,1,1,1,1,1,0,0,0

	End Statement





	Statement squiggle{frame.w}
		MOVE d0,d2
		MOVEQ#0,d0
		MOVE.l #cp,a1:MOVE.l#vd,a2


		MOVEQ #0,d3

		MOVE d2,d3:LSL.l #8,d3:LSL.l #1,d3
		MOVE #240,d4:SUB d2,d4:MULU d2,d4:LSL.l #8,d4
		MOVEQ #0,d6

	nxlin
		wl1:MOVE.w $c00008,d1:LSR#8,d1:CMP d1,d0:BPL wl1


		BSR DoUpper
		ADDQ #1,d0
		wl2:MOVE.w $c00008,d1:LSR#8,d1:CMP d1,d0:BPL wl2
		BSR DoLower

		;
	;	MOVE d2,d1:ADD d0,d1:AND#1023,d1:ASL#2,d1:MOVE 0(a0,d1),d1
	;	ASR#8,d1:ASR#1,d1

		;
	;	MOVE d0,d1:AND#15,d1:OR.w#$8700,d1:MOVE d1,$c00004
		ADDQ#1,d0:CMP #240,d0:BNE nxlin


	:AsmExit

	.DoLower
		CMP d2,d0
			BLE half
			SUB.l d3,d6
			MOVE.l d6,d1:SWAP d1
			MOVE.l d2,d5:ADD d5,d5:SUB d0,d5

			CMP #0,d5
			BLE whole
			SUB d0,d5
			BRA twice


	.DoUpper
		MOVE #240,d7:SUB d2,d7

		CMP d7,d0
		BGE half
	;		MOVEQ #4,d1


			SUB.l d3,d4
			MOVE.l d4,d1:SWAP d1
			MOVE #480,d5
			SUB d2,d5:SUB d2,d5
			SUB d0,d5


			CMP #31*8,d5
			BGE whole
			SUB d0,d5


	twice:MOVEQ #0,d7
				MOVE.l #wvram+$38000003,(a1):MOVE d1,(a2)
				MOVE.l #wvram+$38020003,(a1):MOVE d7,(a2)
				MOVE.l #wsram+$00000000,(a1):MOVE d5,(a2)
				MOVE.l #wsram+$00020000,(a1):MOVE #0,(a2)
				RTS

	whole:MOVEQ #0,d7
				MOVE.l #wvram+$38000003,(a1):MOVE d7,(a2)
				MOVE.l #wvram+$38020003,(a1):MOVE d7,(a2)
				MOVE.l #wsram+$00000000,(a1):MOVE d7,(a2)
				MOVE.l #wsram+$00020000,(a1):MOVE d7,(a2)
				RTS

		half
			MOVEQ #0,d1:MOVE #32*8,d7

			MOVE.l #wvram+$38000003,(a1):MOVE d1,(a2)
			MOVE.l #wvram+$38020003,(a1):MOVE d1,(a2)
			MOVE.l #wsram+$00000000,(a1):MOVE d7,(a2)
			MOVE.l #wsram+$00020000,(a1):MOVE d7,(a2)
			RTS

	End Statement


	.
	.SetUpCloud


		!MyVWait
		!setreg{2,0}		 ;map location=0*8192
		!setreg{4,0}		 ;map location=0*8192
		!setreg{5,$7e}	 ;sprites location=$fc00
		!setreg{11,0}		;scroll=entire screen + no external interupts (8)
;		!setreg{12,$89}	;32 cell mode shadows no interlace
		!setreg{12,$81}	;32 cell mode no shadows no interlace

		!setreg{13,$3e}	;hs=$f800

		!setreg{16,1+48} ;64x64 sized map
		!setreg{3,$38}	 ;windowpos= $e000
		!setreg{17,$0};$8a}
		!setreg{18,$0};$ff}
		!setreg{7,0}


;		!setreg{11,3}		;h-scroll line by line

		MOVE.l #cp,a1:MOVE.l#vd,a2
		MOVEQ #0,d3
		MOVE.l #wvram+$3c000003,(a1):MOVE d3,(a2) ;sprites
		MOVE.l #wvram+$3c020003,(a1):MOVE d3,(a2)
		MOVE.l #wvram+$3c040003,(a1):MOVE d3,(a2)
		MOVE.l #wvram+$3c060003,(a1):MOVE d3,(a2)
		MOVE.l #wvram+$38000003,(a1):MOVE d3,(a2) ;scroll reg
		MOVE.l #wvram+$38020003,(a1):MOVE d3,(a2)
		MOVE.l #wsram+$00000000,(a1):MOVE d3,(a2)
		MOVE.l #wsram+$00020000,(a1):MOVE d3,(a2)


;		!setreg{5,$7c}	 ;sprites location=$fa00
;		!pokemem{#wvram+$20000000,0}					 ;horizontal
;		!pokemem{#wsram+$00000000,0}					 ;vertical
;		!pokemem{#wvram+$20020000,0}					 ;horizontal
;		!pokemem{#wsram+$00020000,0}			 ;vertical


		##[$C489] ?blank,#vram+$ffe0,16				;32 bytes

		##[$C489] ?miniat,#vram+$de00,(?miniatf-?miniat) ASR 1
		minioff.w=$de00 ASR 5

	Return





	.DoCloud ;use titcol, not mycurplay

		*batman.batman=?clouddat

		##[$C482] &*batman\pal ,#wcram,16

		base.l=&*batman\mmap
		For j=0 To 29:For i=0 To 63
			map(i,j)=Peek.w(base)+$8100:base+2
		Next:Next
		##[$C489] &*batman\bloks+2*24*30,#vram+$2000,*batman\numblocks*16
		##[$C482] &map(0,0),#wvram+$1000,2048


		*batman.batman=?cmdat
		##[$C482] &*batman\pal	 ,#wcram+32,16

		base.l=&*batman\mmap
		For j=0 To 29:For i=0 To 39
			map(i,j)=Peek.w(base)+$a500:base+2
		Next:Next
		##[$C489] &*batman\bloks,#vram+$a000,*batman\numblocks*16
		##[$C482] &map(0,0),#wvram,2048



;about to break codemasters logo
		count.w=-50*#loadtime
		##[$80BB]
			!MyQWait


			MOVE.l #cp,a1:MOVE.l#vd,a2
			MOVEQ #0,d3
			MOVE.l #wvram+$38000003,(a1):MOVE d3,(a2)
			MOVE.l #wvram+$38020003,(a1):MOVE d3,(a2)
			MOVE.l #wsram+$00000000,(a1):MOVE d3,(a2)
			MOVE.l #wsram+$00020000,(a1):MOVE d3,(a2)

			base.l=buffa1:temp=&*batman\pal


			cc3:MOVE $c00004,d0:BTST #3,d0:BNE cc3

			If count>0 Then squiggle{##[$C386](count,0,300)}
			count+#animtime


		##[$80BC] count>300
		count=0
;broken..




;copy playfield a to playfield b.. (cloud image)
		*batman.batman=?clouddat

		base.l=&*batman\mmap
		For j=0 To 29:For i=0 To 63
			map(i,j)=Peek.w(base)+$8100:base+2
		Next:Next
		!MyVWait
		!pokemem{#wsram+$00000000,-32*8}			 ;vertical
		!pokemem{#wsram+$00020000,0}			 ;vertical
		##[$C482] &map(0,0),#wvram,2048


		For cnt.w=0 To 30
			!MyVWait
		Next


		numchars=(?fontf-?font)/32
		fontptr.w=$500;billptr+1
		##[$C489] ?font,#vram+fontptr*32,(?fontf-?font) ASR 1


		billptr.w=$2c0 ;500
		##[$C489] ?billdat,#vram+billptr*32,(?billdatf-?billdat)/2
		billptr+(?billdatf-?billdat) ASR 5

;draw billboard.

		roll.w=1
		Gosub SetUpBill


		!MyVWait
		##[$C482] &map(0,0),#wvram+$1000			,2048
;the billboard is now on the screen..



 ;			!MyVWait
 ;
 ;		 SegaDMA ?carpalette,#wcram+ 32,8
 ;		 SegaDMA ?carpalette,#wcram+ 64,8
 ;		 SegaDMA ?carpalette,#wcram+ 96,8
 ;		 SegaDMA ?clouddat+SizeOf.batman\pal	 ,#wcram,16





.dodocloud
		stt.q=0:velx=0:done.w=-3
		stt2.q=0

		win.rect\map=&map(0,0),32,16,0,24
		redlev.w=0:tobd.w=16384

		item.w=0:nxchamp.w=0:myselchamp.w=0:moved.w=0:nxlink.w=-1

		##[$80BB]
			movechars{}
			!MyVWait
			##[$C482] buffa1,#wvram+$f800,240*2*2/2

			displaychars{$fc00}

			Gosub RedCrap


			If done<0
				done+1:If done=-1 Then !setreg{11,3}		;h-scroll line by line
			EndIf



			temp.l=##[$C484](trx{0})

			Select done
			Case -1
				If temp&$d0=0 Then done=0	;initial debounce
			Case 0
				If temp&$d0
					menu.w=1
					Gosub HandleOptions
					done=1
					nxlink.w=0
					addstring{-6,?scordat,5,#selcol+8}
					positionstring{-6,25,3}

;					Poke.l buffb1,Peek.l(?racedat)
;					cnt.w=racenum.w+48
;					Poke.b buffb1+5,cnt

;					addstring{-5,buffb1,3,#selcol+8}
 ;				 positionstring{-5,15,15}



				EndIf
			Case 1:

				temp=0

			End Select


			delx=0
			If (temp&4=4) Then delx-1
			If (temp&8=8) Then delx+1


			If moved=0

				If temp&$20
					menu.w=0
					Gosub HandleOptions
					moved=50
				EndIf

				If delx<>0
					myselchamp.w=myselchamp+delx
					moved=50
				EndIf

			Else
				If (delx=0) AND (temp&$20=0) Then moved=0

			EndIf



			If tobd.w=16384
				nu.w=myselchamp-nxchamp
				If nu>0
					signside.w=On:stt-512
					nxchamp+1:tobd=0:redlev=-64
				EndIf
				If nu<0
					signside.w=Off:stt+512
					nxchamp-1:tobd=0:redlev=-64
				EndIf
			EndIf




			velx=velx *.8 - ##[$C386](stt,-50,50) ASR 5

			stt+velx
			stt2+velx

			squigd{buffa1+2,176,-stt2 ASR 3,0}		 ;sky
			squigd{buffa1+2+176*4,4,-stt2,0}			 ;red/white stipes
			squigd{buffa1+2+180*4,60,-stt2,-stt2 ASR 8} ;ground

			squigd{buffa1+8*4,180,-stt2,0}	;billboard

		##[$80BC] done>1
		champ.w=myselchamp.w
		menu.w=1
		Gosub HandleOptions
	Return
;--------------------------------

	.SetUpBill

		base.l=billptr+$8000
		billptr-(?billdatf-?billdat) ASR 5

		For x=0 To 63:For y=0 To 63:map(x,y)=2047:Next:Next
		For cnt.w= 4+4 To 4+32-4 Step 8
			map(cnt,1)=billptr+$8000
			map(cnt,2)=billptr+$8001
		Next

		map(4	 +4,2+17+1)=billptr+$800b
		map(4+32-4,2+17+1)=billptr+$800b
		map(4	 +4,2+17+2)=billptr+$800b
		map(4+32-4,2+17+2)=billptr+$800b


		For x=4 To 4+32
			For y=2 To 2+17
				happy=0
				If y=2		Then map(x,y)= billptr+$8003:happy=1
				If y=2+17 Then map(x,y)= billptr+$8006:happy=2
				If x=4
					Select happy
						Case 0:map(x,y)= billptr+$8008
						Case 1:map(x,y)= billptr+$8002
						Case 2:map(x,y)= billptr+$8005
					End Select:happy=3
				EndIf
				If x=4+32
					Select happy
						Case 0:map(x,y)= billptr+$8009
						Case 1:map(x,y)= billptr+$8004
						Case 2:map(x,y)= billptr+$8007
					End Select:happy=3
				EndIf

				If happy=0 Then map(x,y)=base:base+roll
			Next
		Next
		origptr.w=billptr
		billptr+(?billdatf-?billdat) ASR 5

	Return

;-----------------


	.RedCrap

		If redlev=0
			If signside.w
				While ((stt ASR 3+40)>(tobd ASR 9)) AND (tobd<16384)
					##[$C482] &map(0,0)+tobd,#wvram+billptr*32+tobd,256
					tobd+512
				Wend
			Else
				While ((stt ASR 3-28)<((16384-tobd) ASR 9)) AND (tobd<16384)
					tobd+512
					##[$C482] &map(0,0)+16384-tobd,#wvram+billptr*32+16384-tobd,256
				Wend
			EndIf
		EndIf



		If redlev=-64 Then redlev=-11
		Select redlev
			Case -11:
				GetReg a0,&map(0,0):MOVE.l #$55555555,d1
				MOVE.l d1,d2:MOVE.l d2,d3:MOVE.l d3,d4:MOVEQ #16,d5
				MOVE.l #1023,d0;#(64*128)/8-1
				mycls5:MOVEM.l d1-d4,(a0):ADD d5,a0:DBRA d0,mycls5

			Case -10
				win\x=0
				mysrc.rect\map=?seldat,16,44,0 ,88*(nxchamp&3),32,88
				sblat{&mysrc,&win}
			Case -9
				win\x=32
				mysrc.rect\map=?seldat,16,44,32,88*(nxchamp&3),32,88
				sblat{&mysrc,&win}
			Case -8
				win\x=64
				mysrc.rect\map=?seldat,16,44,64,88*(nxchamp&3),32,88
				sblat{&mysrc,&win}

			Case -7
				win\x=96
				mysrc.rect\map=?seldat,16,44,96,88*(nxchamp&3),32,88
				sblat{&mysrc,&win}
			Case -6:
;					If nxchamp<4
;						segaprintprint{?champdat,12,0,0}
;					Else
;						If nxchamp<8
;							segaprintprint{?turbodat,12,0,0}
;						Else
;							segaprintprint{?matchdat,10,0,0}
;						EndIf
;					EndIf
					redlev=0
					tobd=0

		End Select
		If redlev<0 Then redlev+1

	Return

;-----------------------------------



Statement NewDraw{item.w,col.w}
	Shared champtyp.w,laptyp.w

	y.w=item*20+24

	If item&1=1
		col=col+8
		Select item
			Case 1:base.l=?matdat+champtyp.w ASL 2
			Case 3:base.l=?lapdat+laptyp.w ASL 2
			Case 5:base.l=?passdat
		End Select
		y-2
	Else
		base.l=?txtdat+item ASL 1
	EndIf


	addstring{item,Peek.l(base),Peek.l(base+4)-Peek.l(base)-1,col}
	positionstring{item,20,	y ASR 3}


	Goto moredone





	matdat:Dc.l r01,r02,r03,r04
		r01:Dc.b "CHAMPIONSHIP"
		r02:Dc.b "TURBO[LEAGUE"
		r03:Dc.b "[MATCH[RACE["
		r04:Event

	txtdat:Dc.l r11,r12,r13,r14,r15
		r11:Dc.b"MODE"
		r12:Dc.b"LAPS"
		r13:Dc.b"PASSWORD"
		r14:Dc.b"EXIT"
		r15:Event

	lapdat:Dc.l r21,r22,r23,r24
		r21:Dc.b"4["
		r22:Dc.b"8["
		r23:Dc.b"12"
		r24:Event

	 passdat:Dc.l r31,r32
		r31:Dc.b "________"
		r32:Event



	moredone
End Statement


Macro yta
	((i*20+44) ASR 3)
End Macro

	.doone

		If newp(i)\sel
;			Select newp(i)\sel
;				Case -3:dofence{2,!yca,36,i+8,2,10}
;				Case -2:dofence{2,!yca,36,i+8,10,26}
;				Case -1:dofence{2,!yca,36,i+8,26,34}
;			End Select

			addstring{i*3,&newp(i)\nam1,5,i+8}
			positionstring{i*3,20,!yta}

			positionstring{i*3+1,-5,!yta}
			positionstring{i*3+2,45,!yta}
;			addmini{i*3+1,5,!yca,newp(i)\car,i}
;			addmini{i*3+2,28.75,!yca+0.5,6,6}


		Else
;			dofence{2,!yca,36,15,-4,-11}
;			addstring{i*3,?press,10,13}
;			positionstring{i*3,20,!yca+1}
			addstring{ i*3,?press,10,#deselcol}
			positionstring{i*3,20,!yta}
		EndIf

	Return


Macro shownum
	If menu>0
		docount{&map(8,3),`1,origptr+$800a,billptr+$8000}
	EndIf
End Macro

	.HandleOptions


		roll.w=0:Gosub SetUpBill

		!shownum{0}

		!MyVWait
		##[$C482] &map(0,0),#wvram+$1000			,2048

;		numchars=(?fontf-?font)/32
;		fontptr.w=billptr+1
;		SegaTransfer ?font,#vram+fontptr*32,8192;(?fontf-?font) ASR 1

		temp.l=$55555555
		base.l=#vram+fontptr*32-32
		For roll.w=0 To 7:##[$C489] &temp,base,2:base+4:Next


		nxlink.w=0

		item=0
		If menu=0
			For cnt.w=0 To 6
				col=#deselcol
				If item=cnt Then col=#selcol
				NewDraw{cnt,col}
			Next
		Else

			For i=0 To 5
				Gosub doone
				newp(i)\sel=0
				cnt=i*10
				charb(cnt	)\id=i*3+1
				charb(cnt+1)\id=i*3+1
				charb(cnt+8)\id=i*3+2
				charb(cnt+9)\id=i*3+2
			Next
			addstring{-5,?reg0,11,#deselcol}
			positionstring{-5,20,3}

		EndIf



		done=Off:mycount.w=0
		##[$80BB]


			movechars{}

			!shownum{mycount ASR 6}

			!MyVWait

			displaychars{$fc00}
			##[$C482] &map(0,0),#wvram+$1000			,2048


			mycount=mycount+1
			If mycount>=(10 ASL 6) Then mycount=0


			temp.l=##[$C484](trx{0})
			delx=(temp&4=4)-(temp&8=8)
			dely=(temp&1=1)-(temp&2=2)
			fire=(temp&$10)<>0
			If menu=0 Then Gosub procopt
			If menu=1
				Gosub procreg
				For i=0 To #uscar
					If newp(i)\ed>-1 Then colourstring{i*3,i+8,newp(i)\ed,!yta}
				Next
			EndIf

		##[$80BC] done
		!MyVWait
		nxlink.w=0
		displaychars{$fc00}


		GetReg a0,&map(0,0):MOVE.l #$55555555,d1
		MOVE.l d1,d2:MOVE.l d2,d3:MOVE.l d3,d4:MOVEQ #16,d5
		MOVE.l #1023,d0;#(64*128)/8-1
		mycls1:MOVEM.l d1-d4,(a0):ADD d5,a0:DBRA d0,mycls1

		!MyVWait
		##[$C482] &map(0,0),#wvram+billptr*32	,8192;2048
		roll.w=1:Gosub SetUpBill

		!MyVWait
		##[$C482] &map(0,0),#wvram+$1000			,2048
		nxchamp-1
	Return


	procopt

			If moved=0

				If dely<>0
					nu=##[$C384](item+dely+dely,0,8)
					NewDraw{item,#deselcol}
					item=nu
					NewDraw{item,#selcol}
					moved=50
				EndIf

				If fire<>0
					Select item
						Case 0:champtyp.w=##[$C384](champtyp+fire,0,3)
						Case 2:laptyp.w=##[$C384](laptyp.w-fire,0,3)
						Case 4:;password
						Case 6:done.w=On
					End Select
					If item<6 Then NewDraw{item+1,#deselcol}
					moved=50
				EndIf
			Else
				If delx=0 AND dely=0 AND fire=0 Then moved=0
			EndIf



	Return

	procreg
		For i=0 To numseg.w
			temp.l= ##[$C484](trx{i})&255
			If newp(i)\moved<0
				If temp<>0 Then newp(i)\moved=newp(i)\del:newp(i)\del=#delay2
			Else
				newp(i)\moved-1
				If temp=0 Then newp(i)\moved=-1:newp(i)\del=#delay1
				temp=0
			EndIf

			If temp&128
				newp(i)\moved=30
				If i=0 Then mycount=(mycount+64)&$FFc0;done.w=On
;					If newp(0)\sel Then newmenu=#champsel:newsel=0:temp=0
;				EndIf
			EndIf


			delx=(temp&4=4)-(temp&8=8)
			dely=(temp&1=1)-(temp&2=2)

			If (delx<>0) OR (dely<>0)
				If i=0 Then mycount=0
			EndIf

			Select newp(i)\sel
				Case	0:If temp&$ff Then newp(i)\sel=-2:newp(i)\ed=-32:Gosub doone:delx=0
;				Case -1
;					dely-(temp&16=16)
;					If dely<>0 Then newp(i)\col=JWrap(newp(i)\col+dely,0,8):Gosub DoPal
;				Case -3
;					dely-(temp&16=16)
;					If dely<>0 Then newp(i)\car=JWrap(newp(i)\car+dely,0,6):Gosub doone
				Case -2:
					If newp(i)\ed>-1
						If temp&16=16
							newp(i)\ed-32:Gosub doone
						Else
							base.l=##[$C384](newp(i)\ed+delx,0,6)
							newp(i)\ed=base
							base.l+&newp(i)\nam1

							If dely<>0 OR delx<>0 Then Poke.b base,##[$C384](Peek.b(base)-dely,64,102):Gosub doone
						EndIf
						delx=0
					Else
						If temp&16
							newp(i)\ed+32
							If newp(i)\nam2&1
								newp(i)\nam1=newp(i)\humnam1
								newp(i)\nam2=newp(i)\humnam2
							EndIf
							Gosub doone

						EndIf
					EndIf

				Default
			End Select


;			If delx<>0 Then newp(i)\sel=JWrap(newp(i)\sel+delx,-3,0):Gosub doone

		Next

;		If mycount>638 Then done=On
		If mycount>238 Then done=On


	Return



CEND






;------------------------------------------





CNIF #frontend



	Statement Draw{item.w}
	Shared menu.w,itemsel.w,maxit()
	Shared disptyp.w
		If (item<0) OR (item>=maxit(menu)) Then Goto donedraw

		y=item*3+7:x=20
		y=30-(maxit(menu)-item)*3

		Select menu
			Case #pause	 :base.l=?pausedat
			Case #main		:base.l=?maindat
			Case #finish	:base.l=?finishdat
			Case #change	:base.l=?changedat
			Case #scoreb	:base.l=?scoredat
			Case #rego		:base.l=?scoredat
			Case #option	:base.l=?optiondat
;			Case #champsel:base.l=?champseldat
			Case #leaderb :base.l=?leaderdat
		End Select
		base=base+item ASL 2

		If menu=#option
			If item=3
				base=?displaydat+disptyp ASL 2
			EndIf
		EndIf

;		If menu=#champsel
;			x=2+(item&1)*19
;			y=1+((item&2)*15)ASR 1
;			x+9:y+12
;		EndIf


		l.w=Peek.l(base+4)-Peek.l(base)-1

;		addstring{Peek.l(base),l,x,y,col,-1}
		If item=itemsel
			addstring{item,Peek.l(base),l,#selcol}
		Else
			addstring{item,Peek.l(base),l,#deselcol}
		EndIf
		positionstring{item,x,y}




		Goto donedraw


		Event
	.pausedat:Dc.l m00,m01,m02,m03
		m00:Dc.b "CONTINUE"
		m01:Dc.b "QUIT RACE"
		m02:Dc.b "CHANGE SETTINGS"
		m03:Event


	finishdat:Dc.l m20,m21,m22,m23,m24
		m20:Dc.b "RACE AGAIN"
		m21:Dc.b "NEXT RACE"
		m22:Dc.b "MAIN MENU"
		m23:Dc.b "SETTINGS"
		m24:Event

	changedat:Dc.l m30,m31,m32,m33,m34,m35,m36,m37,m38
		m30:Dc.b "CLASSIC"
		m31:Dc.b "GRUNTY"
		m32:Dc.b "ZIPPY"
		m33:Dc.b "NIPPY"
		m34:Dc.b "SLIPPERY"
		m35:Dc.b "PATHETIC"
		m36:Dc.b "SNEEZY"
		m37:Dc.b "BASHFUL"
		m38:Event


	scoredat:Dc.l m40,m41
		m40:Dc.b "QUIT"
		m41:Event


	maindat:Dc.l m50,m51,m52,m53
		m50:Dc.b "MATCH RACE"
		m51:Dc.b "CHAMPIONSHIP"
		m52:Dc.b "OPTIONS"
		m53:Event

	optiondat:Dc.l m60,m61,m62,m63,m64,m65
		m60:Dc.b "LAPS"
		m61:Dc.b "DIFFICULTY"
		m62:Dc.b "PASSWORD"
		m63:Dc.b "DISPLAY"
		m64:Dc.b "EXIT"
		m65:Event


	displaydat:Dc.l m70,m71,m72,m73
		m70:Dc.b "DISPLAY: TEAM["	;hard space
		m71:Dc.b "DISPLAY: VERT["
		m72:Dc.b "DISPLAY: HORIZ"
		m73:Event

	leaderdat:Dc.l m80,m81,m82
		m80:Dc.b "NEXT RACE"
		m81:Dc.b "EXIT RACE";MAIN MENU"
		m82:Event


		donedraw
	End Statement


CNIF 1=0
		If menu=#pause
			Select item
				!ft{0,"CONTINUE"}
				!ft{1,"QUIT RACE"}
				!ft{2,"CHANGE SETTINGS"}
			End Select
		EndIf

		If menu=#change
			Select item
				!ft{0,"COMPGRIP"}
				!ft{1,"COMPTOP"}
				!ft{2,"COMPACC"}
				!ft{3,"HUMGRIP"}
				!ft{4,"HUMTOP"}
				!ft{5,"HUMACC"}
				!ft{6,"STEERING"}
				!ft{7,"DONE"}
			End Select
		EndIf



CEND




CEND


CNIF #frontend AND (#c=#s)


Event
	sup0		 :Dc.b "SUPER SKIDMARKS"
	rac0		 :Dc.b "RACE RESULTS"
	reg0		 :Dc.b "REGISTRATION"
	press		:Dc.b "PRESS START"
	lptxt		:Dc.b "LAPS"
	ptstxt	 :Dc.b "PTS"
	racingtxt:Dc.b "NEXT RACE"





	rallyr	 :Dc.b "RALLY"
	beachr	 :Dc.b "BEACH"
	snowr		:Dc.b "SNOW"
	ranchr	 :Dc.b "RANCH"
	racedat	:Dc.b "RACE"
	scordat	:Dc.b "SCORES"

	tub			:Dc.b "TURBO"
	nrm			:Dc.b "NORML"




	champdat:Dc.b "CHAMPIONSHIP"
	turbodat:Dc.b "TURBO LEAGUE"
	randodat:Dc.b "RANDOM PLAY"
	matchdat:Dc.b "MATCH RACE"

		m10:Dc.b "RALLY"
		m11:Dc.b "BEACH"
		m12:Dc.b "SNOW"
		m13:Dc.b "RANCH"
		m14:Event



	Event
	racename :Dc.l rallyr,beachr,snowr,ranchr
	Event


trknamdat
Dc.b "DEATH VALLEY "
Dc.b "OLD JOES FARM"
Dc.b "THE HOMESTEAD"
Dc.b "MOONSHINE RUN"
Dc.b "DEVILS CANYON"
Dc.b "COWBOY COUNTY"
Dc.b "GREASE TOWN	"
Dc.b "INDY 5			 "
Dc.b "BOVINE CITY	"
Dc.b "GRANDPAS LAWN"
Dc.b "MISERY COUNTY"
Dc.b "SNOWYS TRAIL "
Dc.b "GASVILLE		 "
Dc.b "BUTCHERS RUN "
Dc.b "ROADKILL WAY "
Dc.b "BIKINI MILE	"
Dc.b "TEASER BAY	 "
Dc.b "TRASHCAN LAND"
Dc.b "ANGEL ISLAND "
Dc.b "FROZEN FARM	"
Dc.b "CREAM COUNTY "
Dc.b "BADMANS GULLY"
Dc.b "PETROL CITY	"
Dc.b "TYRE MOUNTAIN"









Macro showit
	##[$C482] &map(0,0),#wvram+scrbmem.w,2048;4096
End Macro

Macro yca
	i*5+1
End Macro

Macro ycb
	i*3+1
End Macro


	.SetFirst
		menu.w=#rego
		For cnt.w=0 To 5
			newp(cnt)\sel=Off
			newp(cnt)\ed=-32
			newp(cnt)\col=newp(cnt)\humcol
			NewName{&newp(cnt)\nam1,1}
		Next
	Return




	.SetUpFront
		!MyVWait
		##[$C48A] Off
		!MyVWait
		!MyVWait
		!MyVWait
		inrace.w=Off

		!MyVWait


		fontptr.w=$3000
		numchars=(?fontf-?font)/32
		##[$C489] ?font,#vram+$3000,(?fontf-?font) ASR 1
		##[$C489] ?fence,#vram+$3000+numchars*32,(?miniatf-?fence) ASR 1
		minioff.w=(?miniat-?fence) ASR 5+ 384+numchars
;		SegaTransfer ?miniat,

		selptr.w=minioff+(?miniatf-?miniat) ASR 5
		##[$C489] ?seldat,#vram+selptr*32,(?seldatf-?seldat) ASR 1

		##[$C489] ?checkers,#vram+$ff80,32


		For x=0 To 63:For y=0 To 33; AHHAHAH3
;			If (x&2+y&2)&2 Then map(x,y)=$e7fc:Else map(x,y)=$e7fd
			If (x+y)&1 Then map(x,y)=$e7fd:Else map(x,y)=$e7fc
		Next:Next
		##[$C482] &map(0,0),#wvram+8192,2048;4096

;		!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
;		!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical
;		!pokemem{#wvram+$10020000,-(vp(2)\sx AND 7)+(64-21)*8} ;horizontal
;		!pokemem{#wsram+$00020000, (vp(2)\sy AND 7)}					 ;vertical
		!pokemem{#wvram+$3c000003,0}					 ;sprite base?
		!pokemem{#wvram+$3c020003,0}
		!pokemem{#wvram+$3c040003,0}
		!pokemem{#wvram+$3c060003,0}


		!pokemem{#wvram+$20000000,0}					 ;horizontal
		!pokemem{#wsram+$00000000,4}					 ;vertical
		!pokemem{#wvram+$20020000,0}					 ;horizontal
		!pokemem{#wsram+$00020000,0};-32*8}			 ;vertical

		!setreg{2,0}		 ;map location=0*8192
		!setreg{4,1}		 ;map location=1*8192
		!setreg{5,$7e}	 ;sprites location=$fc00
		!setreg{11,0}		;scroll=entire screen + no external interupts (8)
;		!setreg{12,$89}	;32 cell mode shadows no interlace
		!setreg{12,$81}	;32 cell mode shadows no interlace
		!setreg{13,$8}	 ;hs=$1000
		!setreg{16,1+48} ;64x128 sized map
		!setreg{3,$38}	 ;windowpos= $e000
		!setreg{17,$0};$8a}
		!setreg{18,$0};$ff}
		!setreg{7,0}



		Gosub redr
		!showit
		!MyVWait
		Gosub DoPal
		##[$C48A] On
;		!setreg{0,$14}	;split vertical
;		!setreg{10,119}


	Return




	.DoFront

		bigdone.w=Off
		##[$80BB]


			movechars{}


			!MyVWait

			!pokemem{#wsram+$00000000,scry}			 ;vertical
			scry=scry+scryd



			!pokemem{#wvram+$20020000,myx&15-48}					 ;horizontal
			!pokemem{#wsram+$00020000,myy&15}			 ;vertical
			displaychars{$fc00}

			!showit:fps.w+1
			If scry>244 Then scry=244:scryd=0
			If scry<4 Then scry=4:scryd=0


			myy=##[$851A](myy+jcos{myfirstang} ASL 1 )
			myx=##[$851A](myx-1)

			myfirstang=##[$C384](myfirstang+(myangvel ASR 5),0,1)
			myangvel=(myangvel+##[$8481](myangvel,myfirstang) ASR 4)*0.98



			newmenu.w=menu.w

			Select menu
				Case #rego:Gosub processlogin
				Default: Gosub processmenu
			End Select



			If menu=#rego
				For i=0 To #uscar
					If newp(i)\ed>-1 Then colourstring{i*3,i+8,newp(i)\ed,!yca+1}
				Next
			EndIf



			If menu<>newmenu.w
				If menu=#rego
					For cnt.w=0 To 5
						newp(cnt)\humcol=newp(cnt)\col
						If newp(cnt)\sel
							If newp(cnt)\nam2&1=0
								newp(cnt)\humnam1=newp(cnt)\nam1
								newp(cnt)\humnam2=newp(cnt)\nam2
							EndIf
						EndIf
					Next
				EndIf

;				If menu=#champsel Then cnt.w=0:Gosub DoPal
				menu.w=newmenu.w:itemsel.w=newsel.w
;				If menu=#champsel
;					cnt.w=-42:Gosub DoPal
;					racenum.w=0
;				EndIf

				If menu=#rego
					For cnt.w=0 To 5
						newp(cnt)\sel=Off
						newp(cnt)\ed=-32
						newp(cnt)\col=newp(cnt)\humcol
						NewName{&newp(cnt)\nam1,1}
					Next
				EndIf
				Gosub redr

			EndIf

		##[$80BC] bigdone
	Return


	processlogin

		done.w=Off
		For i=0 To numseg.w
			temp.l= ##[$C484](trx{i})&255
			If newp(i)\moved<0
				If temp<>0 Then newp(i)\moved=newp(i)\del:newp(i)\del=#delay2
			Else
				newp(i)\moved-1
				If temp=0 Then newp(i)\moved=-1:newp(i)\del=#delay1
				temp=0
			EndIf

			If temp&128
				newp(i)\moved=30
				If i=0 Then done.w=On
;					If newp(0)\sel Then newmenu=#champsel:newsel=0:temp=0
;				EndIf
			EndIf


			delx=(temp&4=4)-(temp&8=8)
			dely=(temp&1=1)-(temp&2=2)

			Select newp(i)\sel
				Case	0:If temp&$ff Then newp(i)\sel=-3:newp(i)\ed=-32:Gosub doone:delx=0
				Case -1
					dely-(temp&16=16)
					If dely<>0 Then newp(i)\col=##[$C384](newp(i)\col+dely,0,8):Gosub DoPal
				Case -3
					dely-(temp&16=16)
					If dely<>0 Then newp(i)\car=##[$C384](newp(i)\car+dely,0,6):Gosub doone
				Case -2:
					If newp(i)\ed>-1
						If temp&16=16
							newp(i)\ed-32:Gosub doone
						Else
							base.l=##[$C384](newp(i)\ed+delx,0,6)
							newp(i)\ed=base
							base.l+&newp(i)\nam1

							If dely<>0 OR delx<>0 Then Poke.b base,##[$C384](Peek.b(base)-dely,64,102):Gosub doone
						EndIf
						delx=0
					Else
						If temp&16
							newp(i)\ed+32
							If newp(i)\nam2&1
								newp(i)\nam1=newp(i)\humnam1
								newp(i)\nam2=newp(i)\humnam2
							EndIf
							Gosub doone

						EndIf
					EndIf

				Default
			End Select

			If delx<>0 Then newp(i)\sel=##[$C384](newp(i)\sel+delx,-3,0):Gosub doone

		Next


		If done.w=On Then Gosub NextRace

	Return

	processmenu

			temp.l=##[$C484](trx{0}) ;OR SegaJoy(1)
			If hilite.w
				If (temp&$f0)=0
					hilite=Off:Gosub hitbutton:Return
				Else
					Return
				EndIf
			EndIf

;			If menu=#champsel
;				delta=itemsel
;				If (temp&4) OR (temp&8) Then delta=delta&2+1-delta&1
;				If (temp&2) OR (temp&1) Then delta=(delta+2)&3
;				delta-itemsel
;			Else
				delta=0:delx=0
				If temp&2 Then delta+1
				If temp&1 Then delta-1
				If menu=#option
					If itemsel<(maxit(#option)-1)
						delx=(temp&4=4)-(temp&8=8)-(temp&$70<>0):temp=0
					EndIf
				EndIf
;			EndIf

			If moved<0
				nu.w=##[$C384](itemsel+delta,0,maxit(menu))
				If nu<>itemsel
					##[$80C9] itemsel.w,nu.w
					moved=del
					del=#delay2
					Draw{nu}
					Draw{itemsel}
				Else
					If temp&$f0
						hilite.w=On
						colourstring{itemsel,#hicol,-1,-1}
;						Repeat
;							temp.l=SegaJoy(trx{0})
;						Until temp&$f0=0
;						Gosub hitbutton
					EndIf

				EndIf
				If delx<>0
					If itemsel=3 Then disptyp=##[$C384](disptyp+delx,0,3)
					Draw{itemsel}
					moved=del
					del=#delay2
				EndIf
			Else
				moved-1
				If (delta=0) AND (delx=0) Then moved=-1:del=#delay1

			EndIf


	Return




CNIF 1=0
		If menu=#rego
			For i.w=0 To 5
				If newp(i)\sel
					base.l=&newp(i)\nam1
					addstring{base,5,20,!yca+1,i+8,newp(i)\ed}
					addmini{5,!yca,newp(i)\car,i}
					addmini{29,!yca+0.25,6,6}
				Else
					addstring{?press,10,20,!yca+1,13,-1}
				EndIf
			Next
		EndIf
CEND

CNIF 1=0
	.doone

		If newp(i)\sel
			Select newp(i)\sel
				Case -3:dofence{2,!yca,36,i+8,2,10}
				Case -2:dofence{2,!yca,36,i+8,10,26}
				Case -1:dofence{2,!yca,36,i+8,26,34}
			End Select

			addstring{i*3,&newp(i)\nam1,5,i+8}
			positionstring{i*3,20,!yca+1}
			addmini{i*3+1,5,!yca,newp(i)\car,i}
			addmini{i*3+2,28.75,!yca+0.5,6,6}


		Else
			dofence{2,!yca,36,15,-4,-11}
			addstring{i*3,?press,10,13}
			positionstring{i*3,20,!yca+1}
		EndIf

	Return
CEND



	.redr
;		If scrbmem.w=0
;			scrbmem.w=3840:scryd= 4
;		Else
;			scrbmem.w=0	 :scryd=-4
;		EndIf

		Gosub home
		For x=0 To 63:For y=0 To 31:map(x,y)=257:Next:Next


		For cnt.w=0 To maxit(menu)-1
			Draw{cnt}
		Next

		Select menu
			Case #raceit

				addstring{0,?racingtxt,8,5+8}
				positionstring{0,20,10}


				base.l=racenum.w+1
				temp.l=##[$C381](base/10):base-(temp*10)
				temp=(temp+48)ASL 8+(base ##[$80B9] 10 + 48)
				addstring{1,&temp+2,1,5+8}
				positionstring{1,20,18}

				For cnt.w=0 To nxlink-1
					charb(cnt)\cx=charb(cnt)\fx
					charb(cnt)\cy=charb(cnt)\fy
					chara(cnt)\x=charb(cnt)\fx
					chara(cnt)\y=charb(cnt)\fy
				Next
				!MyVWait
				displaychars{$fc00}
				!showit

			Case #rego
				For i=0 To 5
					Gosub doone
					cnt=i*10
					charb(cnt	)\id=i*3+1
					charb(cnt+1)\id=i*3+1
					charb(cnt+8)\id=i*3+2
					charb(cnt+9)\id=i*3+2
				Next
			Case #scoreb
				roll.w=10
				For i=0 To 5
					*p=Pl(newp(i)\pl)

					dofence{2,!yca,36,i+8,4,11}
					addstring{roll.w,&newp(i)\nam1,5,i+8}
					positionstring{roll,22,!yca+1}

					addmini{roll+1,7,!yca,newp(i)\car,i}


					cnt.w=*p\pos+49;=1..
					addstring{roll+2,&cnt+1,0,5+8}
					positionstring{roll+2,4,!yca+1}

;					addstring{roll+3,?ptstxt,2,5}
;					positionstring{roll+3,34,!yca}


					base.l=*p\newscore
					If base>9
						temp.l=##[$C381](base/10):base-(temp*10)
						temp=(temp+48)ASL 8+(base ##[$80B9] 10 + 48)
						addstring{roll+6,&temp +2,1,5+8}
					Else
						temp.l=base+48
						addstring{roll+6,&temp +3,0,5+8}
					EndIf
					positionstring{roll+6,34,!yca+2}


					roll+20
				Next
				For i=0 To 5
					roll=i*20+10
					addstring{roll+3,?ptstxt,2,5}
					positionstring{roll+3,34,!yca}
				Next

;			Case #champsel
;;				base.l=?selmap
;				For i.w=0 To 3
;					roll.w=2+(i&1)*19
;					pitch.w=1+((i&2)*15)ASR 1
;
;
;
;					For dy=0 To 11
;						For dx=0 To 16
;							map(roll+dx,pitch+dy)=Peek.w(base)+selptr+$8000:base+2
;						Next
;					Next
;				Next
			Default
				roll=26
				For item.w=0 To maxit(menu)-1
					y=30-(maxit(menu)-item)*3
					dofence{20-roll ASR 1,y,roll,0,2,roll-2}
				Next
		End Select
		If menu=#leaderb
			roll=10
			For i=0 To 5
				addstring{roll.w,&newp(i)\nam1,5,i+8}
				positionstring{roll,22,!ycb+1}


				*p=Pl(newp(i)\pl)
				base.l=*p\score+*p\newscore:temp=0
				If base>9
					temp.l=##[$C381](base/10):base-(temp*10)
					temp=(temp+48)ASL 8 +base+48
					addstring{roll+6,&temp +2,1,5+8}
				Else
					temp.l=temp+base+48
					addstring{roll+6,&temp +3,0,5+8}
				EndIf


				positionstring{roll+6,34,!ycb+1}


				roll+20
			Next
		EndIf
	Return


abcde:Dc.b "ABCDGHIJ"	;even...


	.hitbutton


		Select menu
			Case #main
				If itemsel<2 Then newmenu=#rego:newsel=0:champtyp.w=itemsel
				If itemsel=2 Then newmenu=#option:newsel=maxit(#option)-1

			Case #option
				If itemsel=maxit(#option)-1 Then newmenu=#main:newsel=2

;			Case #champsel
;				champ.w=itemsel&3 ;AHA!
;
;				mytrk.w=(itemsel&3)*2
;
;				lapdir.w=-1:If itemsel<4 Then lapdir=1
;
;				champ.w=-1
;				Gosub NextRace

			Case #finish
				Select itemsel
					Case 0:Gosub NextRace
					Case 1
						racenum=racenum+1
						If (mytrk.w&1)=0
							mytrk.w+1
						Else
							mytrk.w+7
						EndIf
						Gosub NextRace
					Case 2 :newsel=0			:newmenu=#main
					Case 3 :newsel=skill.w:newmenu=#change
				End Select
			Case #leaderb
				Select itemsel
					Case 0:racenum+1:Gosub NextRace
					Case 1:bigdone.w=On:;newsel=0:newmenu=#main
				End Select
			Case #change
				skill.w=itemsel
				newsel=3
				newmenu=#leaderb;finish

			Case #scoreb
				newmenu=#leaderb:newsel=0

		End Select

	Return

CEND











	.DoAttract
		CNIF #race
			##[$C48A] Off

			mytrk.w=(##[$8481](rsd,23.435)+1)*12:rsd+435.76
			For cnt.w=0 To #uscar
				newp(cnt)\sel=0
				newp(cnt)\car=0;(Random1(325.654,rsd)+1)*2
			Next
			screenmode.w=(screenmode+1)&3:rsd-435.765
			screenmode=0
			laps.w=1:lapdir.w=1
			racenum.w=-1
			Gosub SetFirst

			Gosub GetNewTrack
			Gosub SetUpWorld
			Gosub SkidMain

			laps.w=4:inrace.w=Off
		CEND

	Return




.NextRace


;		!setreg{0,$04}
		If racenum>0
			For pl=0 To #uscar
				Pl(pl)\score+Pl(pl)\newscore
			Next
		EndIf

		!MyVWait
		##[$C48A] Off
		If champ<4
			mytrk.w=champ*2+racenum&1 + (racenum&6)*8/2
			super.w=Off
		Else
			If champ<8
				mytrk.w=(champ-4)*2+racenum&1 + (racenum&6)*8/2
				super.w=On
			Else
				mytrk.w=(champ-8)*2 + (##[$8481](rsd,68.83)+1)*3
				rsd-7.2894
				super.w=Off
			EndIf
		EndIf




		Gosub GetNewTrack

		Gosub SetUpWorld
;		Safe{}

		Gosub SkidMain
		Gosub BookKeep

		menu=#scoreb:itemsel.w=0
;		menu=#finish:itemsel=0

		newmenu=menu:newsel=itemsel
		Gosub SetUpFront



Return

.assignplayers
	reduce.w=0
	For pl.w=0 To #uscar
		*p=Pl(pl):Gosub SetStartCar
		If newp(pl)\sel Then reduce+1
	Next

	If racenum<=0

		For pl=0 To #uscar
			*p=Pl(pl)
			*p\score=0
			*p\newscore=0
			newp(pl)\pl=-1
			*p\newp=-1
		Next

		Select reduce
			Case 0:	;screenmode=0 ;???
			Case 1:	screenmode=0
			Case 2:	screenmode=disptyp
			Case 5:	screenmode=3
			Case 6:	screenmode=3
			Default: If disptyp=0 Then screenmode=0:Else screenmode=3
		End Select


		cnt.w=0	;gethumans/comp
		pitch.w=reduce;#uscar
		For pl=0 To #uscar
			If newp(pl)\sel
				Pl(cnt)\newp=pl
				Pl(cnt)\control=trx{pl}
				newp(pl)\pl=cnt :cnt+1
			Else
				Pl(pitch)\newp=pl
				Pl(pitch)\control=#contcomp
				newp(pl)\pl=pitch:pitch+1
			EndIf
		Next

		If screenmode=1	;HAHAHAHHA
			##[$80C9] Pl(1)\newp,Pl(2)\newp
			##[$80C9] Pl(1)\control,Pl(2)\control
			newp(Pl(1)\newp)\pl=1
			newp(Pl(2)\newp)\pl=2
		EndIf

		For pl=0 To #uscar
			If newp(pl)\sel=0
				##[$80BB]
					pitch.w=(##[$8481](rsd,435.661)+1)*4:rsd-5.8275
					For roll=0 To #uscar
						If pitch.w=newp(roll)\col Then pitch.w=-1
					Next
				##[$80BC] pitch.w>-1
				newp(pl)\col=pitch.w
				newp(pl)\car=(##[$8481](rsd,435.661)+1)*2:rsd-7.1245
			EndIf
		Next
	EndIf
Return






.
.
.
;	light,big gamma, overscore,little l,post


.SetUpWorld

	CNIF #race

		CNIF #c=#s
			##[$C491] 46


			Poke.l $ff0020,0
			For roll.w=0 To 127 Step 2
				Poke.w &chara(0)+roll,0
			Next
			!MyVWait

			For cnt.w=0 To 128
				Poke.w buffa1+cnt+cnt,0
				Poke.w buffa2+cnt+cnt,0
				Poke.w buffb1+cnt+cnt,0
				Poke.w buffb2+cnt+cnt,0
			Next
			##[$C482] &chara(0),#wvram+$fc00,64
;			SegaDMA &chara(0) ,#wcram,64


			##[$C48A] Off
		CEND


		cmpacc=-1
		cmpacc7=-0.7
		inrace.w=On


		CNIF #maketri
			myang=64

			qs=0.2:qc=0.2
			delta.l=0

			deadx=2
			deady=0

			Gosub InitTris
		CEND

		CNIF #c=#a
			For dtp=2 To pts3 Step 0.1
				FindLo dtp,skbm
				Point bez\i ASL #sc,bez\j ASL #sc,1
				Point bez\k ASL #sc,bez\l ASL #sc,1
			Next
		CEND


		CNIF #c=#s AND #race
			;
			For cnt.w=0 To 31
				##[$C489] ?blank,#vram+cnt*64*2,64				;2048 bytes
			Next

			For cnt.w=0 To 7
				If *ath.theader\blocks[cnt]<>0
					If Peek.l(*ath\blocks[cnt]+tkbin)<>$43724d21 Then Safe{}
					##[$C387] *ath\blocks[cnt]+tkbin,blockmap.l
					##[$C489] blockmap,#vram+$1000+cnt*8192,4096;Peek.l(*ath\blocks[cnt]+tkbin+6)/2
				Else
					If cnt<3 Then Safe{}
				EndIf
			Next

			##[$C387]	*ath\blockmap+tkbin,blockmap.l
			skidm.l=blockmap+64
			If super
				##[$C48F] skidm
				For cnt=0 To #uscar
					spr(cnt)\spdata=spr(cnt)\spdata OR $800
					spr(cnt+#uscar+1)\spdata=spr(cnt+#uscar+1)\spdata OR $800
				Next
				lapdir.w=-1
			Else
				For cnt=0 To #uscar
					spr(cnt	)\spdata=spr(cnt)\spdata AND $f7ff
					spr(cnt+#uscar+1)\spdata=spr(cnt+#uscar+1)\spdata AND $f7ff
				Next
				lapdir.w=1
			EndIf



			!setreg{2,0}		 ;map location=0*8192
			!setreg{4,0}		 ;map location=0*8192
			!setreg{5,$7e}	 ;sprites location=$fc00
			!setreg{11,0}		;scroll=entire screen + no external interupts (8)
			!setreg{12,$89}	;32 cell mode shadows no interlace
			!setreg{13,$4}	 ;hs=$1000;$fc00
			!setreg{16,1}		;64x32 sized map
			!setreg{3,$38}	 ;windowpos= $e000
			!setreg{17,$0};$8a}
			!setreg{18,$0};$ff}
		CEND




		lapdir2=lapdir ASL 1:lapdir4=lapdir ASL 2

		For dum.w=0 To #spoon:spoon(dum)=-1000:Next

		Gosub assignplayers

		Gosub PlaceNorm ;AHAHAHAHHAHAH



		##[$80CA] *p
		For ipl.w=0 To #maxcar
			*p=Pl(ipl)
			\carnum=newp(\newp)\car
		Next


		CNIF #c=#s
			If champ>-1
;				UpDateNuPlayer{Peek.l(Peek.l($ff0004)+8)+24*champ.w}
				If champtyp
					UpDateNuPlayer{Peek.l(Peek.l($ff0004)+8)}
				Else
					UpDateNuPlayer{Peek.l(Peek.l($ff0004)+12)}
				EndIf
			Else
				UpDateNuPlayer{Peek.l(Peek.l($ff0004)+4)+8*skill.w}
			EndIf
		CELSE
			UpDateNuPlayer{?cardiff+8*2}
		CEND





;		 If retch Then Safe{}
		Gosub NewScrMode

			!MyVWait
			!MyVWait
			!MyVWait




		MOVE #$8700,$c00004
;			If retch Then Safe{}

		Gosub DoSignStart




		##[$80CA] *p
		reduce.w=-1
		For pl=0 To #uscar
			*p=Pl(pl)
			*p\pos=pl	;huh?!
			tdist(pl)\car=pl
			*p\newscore=pl

			If \control=#contcomp
				*p\k=QHite(*p\i,*p\j,skbm)	 :\drop=On
			Else
				*p\k=QHite(*p\i,*p\j,skbm)+16:reduce+1
			EndIf
			##[$C48D] &newp(*p\newp)\nam1,?tagbin,*p\q,super
			*p\oldpos=-2:*p\disc=32000
			*p\pos=*p\oldpos




			If pl<1;5 ;0..4
				*p\tune=41-newp(*p\newp)\car*5+pl
				*p\shv =Peek.w(Peek.l(Peek.l($ff0004)+4)+*p\carnum ASL 2)
				*p\peak=Peek.w(Peek.l(Peek.l($ff0004)+4)+*p\carnum ASL 2+2)
				CNIF #snd
					##[$C490] *p\tune,-1
				CEND
			EndIf
		Next





		For pl=0 To #uscar
	;		If pl>iscar
	;			tdist(Pl(pl)\pos)\h=-10000
	;		Else
	;			Pl(pl)\oldpos=Pl(pl)\pos
	;			tdist(Pl(pl)\pos)\h=Pl(pl)\newscore
	;		EndIf

				Pl(pl)\oldpos=Pl(pl)\pos ;<shrugs>
				tdist(Pl(pl)\pos)\h=-10000
		Next
		##[$851E] tdist,iscar,*p0




		##[$C489] ?strip,#vram+$fe80,128 ;dinky sprites
		Gosub DoPal


		CNIF #c=#s

			!MyVWait
			##[$C48A] On

		CEND

		done.w=Off
	CEND

Return


;testtrack
;IncBin "rat:track.1"



.PlaceCar	;i,j,fr,mycar.w
	CNIF #c=#a
		Circle ii ASL #sc,jj ASL #sc,3,mycar.w+2
	CEND
;	CNIF #c=#s
;		spr(mycar.w+8)\hp=JLimit(116+IOP(*p\myview\sx)-scrx,$40,$1e9)
;		spr(mycar.w+8)\vp=134+IOP(*p\myview\sy)-scry
;
;		spr(mycar)\vp=spr(mycar+8)\vp+*p\shady
;		spr(mycar)\hp=spr(mycar+8)\hp
;
;
;	CEND

Return



Statement SetupMiddle{x.w,l1.l,l2.l,eo.l}

	MOVE.l d1,a0:MOVE.l d2,a1
	EXT.l d0:MOVE.l d0,d5
	MOVE.l #$00800701,d4:ADD.l #$a7f40080,d5
	MOVE.l #$00200001,d6:MOVEQ #3,d7

	nxset
	MOVE.l d4,(a0)+:MOVE.l d5,(a0)+:ADD.l d3,d5:ADD.l #$780000,d4
	MOVE.l d4,(a1)+:MOVE.l d5,(a1)+:SUB.l d3,d5:SUB.l #$780000,d4
	ADD.l d6,d4

	DBRA d7,nxset
	AsmExit
End Statement


Macro stopz80:MOVE.b#1,z80:wz`@:BTST.b#0,z80:BNE wz`@:End Macro
Macro startz80:MOVE #0,z80:End Macro


.NewScrMode
CNIF #c=#s

	!stopz80
	!setreg{0,$04} ;disable vert int

	!MyVWait
	!MyVWait
	!MyVWait
	!MyVWait
	!MyVWait
	##[$C48A] On


	For cnt.w=0 To 31
		##[$C482] ?blank,#wvram+cnt*64*2,64				;2048 bytes
	Next




	Select screenmode
		Case 0:scrw=320 :scrh=240	:blkh.w=31
		Case 1:scrw=160 :scrh=240	:blkh.w=31
		Case 2:scrw=320 :scrh=120	:blkh.w=16
		Case 3:scrw=160 :scrh=120	:blkh.w=16
	End Select

	vp(0)\wid=scrw,128		,128
	vp(2)\wid= -24,128+160,128
	vp(1)\wid= -24,128		,128+120
	vp(3)\wid= -24,128+160,128+120


	Select screenmode
		Case 0	;noint..
			SetupMiddle{312,buffa1,buffb1,$00000000}
			SetupMiddle{312,buffa2,buffb2,$00000000}
			Poke.w $ff0014,-1;$9303
		Case 1
			SetupMiddle{152,buffa1,buffb1,$00000000}
			SetupMiddle{152,buffa2,buffb2,$00000000}
			Poke.w $ff0014,-1;$9340
		Case 2
			SetupMiddle{312,buffa1,buffb1,$20000000}
			SetupMiddle{312,buffa2,buffb2,$20000000}
			Poke.w $ff0014,0;$9303
		Case 3
			SetupMiddle{152,buffa1,buffb1,$20000000}
			SetupMiddle{152,buffa2,buffb2,$20000000}
			Poke.w $ff0014,0;,$9340
	End Select


	If screenmode>1
		vp(1)\wid=scrw
	Else
		If screenmode=1 Then vp(2)\wid=scrw
	EndIf


	If screenmode=3 Then vp(2)\wid=scrw:vp(3)\wid=scrw



	scrwh=scrw ASR 1:scrhh=scrh ASR 1
	scr.scr\scrw=scrw,scrwh,scrh,scrhh

	warpmode.w=(screenmode=0)
	##[$C48A] Off

	!MyVWait


;	If screenmode>0
		!setreg{10,119}
		!setreg{0,$14}	;split vertical

;	Else
;		!setreg{0,$04}
;
;	EndIf


	!startz80
CEND

Return


	CNIF #c=#s

		#row=192
		Statement animate{map.l,info.l,user.l}

			MOVEM.l a4-a5,-(a7)
			MOVE.l d0,a0:MOVE.l d1,a1:MOVE.l d1,a2:MOVE.l d2,a3
		getfat:
			MOVE (a2)+,d0:BMI dunlist:MOVE (a2)+,d1:MOVEM 0(a1,d1),d4-d7
			MOVE d6,d3:MULU d7,d3:SUBQ#1,d6:SUBQ#1,d7
		wrapuser:
			MOVE (a3),d1:BPL titus:mpos:ADD d5,d1:BMI mpos
			titus:SUB d5,d1:BPL titus:ADD d5,d1:MOVE d1,(a3)+
			MULU d1,d3:ADD d3,d4:LEA 0(a0,d0.w),a4
		nxx:
			MOVE d7,d0:MOVE.l a4,a5:ADDQ#2,a4	;:MOVE d4,(a4)
		nxy:
			MOVE d4,(a5):ADD #row,a5:ADDQ#1,d4:DBRA d0,nxy:DBRA d6,nxx
			BRA getfat
		dunlist:
			MOVEM.l (a7)+,a4-a5
			AsmExit
		End Statement

	CEND



Macro doflag
		flanim.q=##[$C384](flanim+.4,0,8)
		##[$C482] ?flags+flanim*8*32,#wvram+flags.l,8*16
End Macro



.
.SkidMain
CNIF #race



	startrace.w=-1
	starthoppy.w=128*3+30	;three beeps
	hoppy.w=500						;credits
	If reduce.w=-1 Then hoppy=starthoppy ;demo race..


	*newleader.car=*p1:lead.w=0
	*oldleader.car=*p0

	fps.w=0:endrace.w=30000-50:nureduce.w=#uscar ;HAHAH
	fadeincol.w=-40
	CNIF #c=#s
		!MyVWait
		Gosub DoSegaGfx1
		!MyVWait
		Gosub DoSegaGfx2
	CEND

;	If screenmode>1 Then Poke.w $ff0014,0 ; enable hint


	##[$80BB]


		CNIF #c=#s
			Gosub DoSegaGfx1
		CEND


		fps.w+1
		If fps>endrace Then done=On



;		If hoppy=500 Then Gosub Credits

		If (hoppy>-50) AND (hoppy<499)
			hoppy-1
			If (hoppy AND 127)=18
				dum.w=hoppy ASR 7
;				Select dum
;					Case 0:top$=" GO "
;					Case 1:top$="lmno"
;					Case 2:top$="hijk"
;					Case 3:top$="defg"
;				End Select

;				QPrint top$,Addr BitMap (4),Addr BitMap(2)
;				Use BitMap #signbmap
;				Scroll 32,0,32,16,0,0,4
;				If dum=3 Then Poke.w (Addr Sound(4) +4) , sndper ASL 1
				If dum=0
;					Poke.w (Addr Sound(4) +4) , sndper
					*ap.car=*p0
					For opl.w=0 To #uscar
;						If *ap\predef>-1 Then *ap\idle=On:*ap\disc=30:*ap\warp=0
						*ap\idle=On:*ap\disc=1:*ap\warp=0
						*ap+SizeOf.car
					Next
				EndIf
;				If snd Then Sound 4,6,30,30
			EndIf

			If (hoppy AND 127)=0
				dum.w=(hoppy ASR 7)
				If dum<>0
;					If snd Then Volume 6,8,8
					hoppy=((hoppy) AND $380)-128 +30
				Else
;					If squeal Then LoopSound 5,8,0	;screech!
				EndIf
			EndIf
			If hoppy=-48
;				If snd
;					If squeal
;						LoopSound 0,7,0,0,0 ;funkee!
;					Else
;						LoopSound 0,15,0,0,0,0 ;funkee!
;					EndIf
;				EndIf
			EndIf
		EndIf


		CNIF #c=#s
			If fadeincol.w<0


				!showred
				!MyQWait
				!showwht

				##[$C482] &chara(0) ,#wcram,64

			Else

				!showred
				!MyQWait


		;		MyVWait{}
		;		MyVWait{}
		;		MyVWait{}
		;		!showblk
			EndIf

			Gosub DoSegaGfx2




			If fadeincol<0
				fadeincol+1

				If fadeincol>-30

					base.l=&chara(0):temp.l=&charb(0)
					For roll=0 To 63
						Poke.w base,mycloset{Peek.w(base),Peek.w(temp.l)}
						base+2:temp+2
					Next
				EndIf
			Else
				fadeincol+1
				If fadeincol=100
;					If screenmode>1 Then Poke.w $ff0014,0 ; enable hint
				EndIf

			EndIf




		CEND





		CNIF #c=#s
			If *p0\control=#contcomp
				If ##[$C484](trx{0})&32<>0
					screenmode=(screenmode+1)&3
					Gosub NewScrMode

					##[$80BB]:##[$80BC] ##[$C484](trx{0})&32=0
					!MyVWait
				EndIf
				If ##[$C484](trx{0})&128>0 Then done=On
			EndIf

		CEND


;			temp=SegaJoy(port)
;			Poke.l x,(temp&4=4)-(temp&8=8)
;			Poke.l y,(temp&16=16);JLimit((temp&1=1)-(temp&2=2)+(temp&16=16),-1,1)
;			Poke.l butt,0

;		GetJoy{&sjoxa.l,&sjoya.l,&sbutt.l,0}
;		GetJoy{&sjoxb.l,&sjoyb.l,&sbutt.l,1}


		myfrcnt.w=(myfrcnt.w+1)&3



		CNIF #collisions
			myfredcar.w=myfredcar+1
			If myfredcar>#uscar Then myfredcar=0
			*p=Pl(myfredcar):Gosub HandleHeader
			pla=myfredcar:*ap=*p
			Gosub Crash
		CEND

		For ipl.w=0 To 3
			*p=Pl(ipl):mynxcnt.w=(myfrcnt+ipl)&3


			If (mynxcnt&2)=0
				If *p\control<#contcomp
					If fadeincol=0
;						temp=SegaJoy(*p\control)
						temp=##[$C484](*p\control)

						If ipl=0 ;AHA
							If temp&32<>0
								screenmode=(screenmode+1)&3
								Gosub NewScrMode

							EndIf
							If temp&128>0
								done=On

;								Repeat:Until SegaJoy(trx{0})&128=0 ;hmmmmmm
							EndIf
						EndIf


						If super
							jox=(temp&8=8)-(temp&4=4)
						Else
							jox=(temp&4=4)-(temp&8=8)
						EndIf

						joy=(temp&16=16)-(temp&64=64)
					Else
						jox=0:joy=0
					EndIf
				EndIf

;				If *p\control<#contcomp
;					temp=SegaJoy(*p\control)
;					jox=(temp&4=4)-(temp&8=8)
;					joy=(temp&16=16)
;				EndIf


;				If *p\control<#contcomp
;					temp=SegaJoy(*p\control)
;					temp=SegaJoy(*p\control)
;					jox=(temp&4=4)-(temp&8=8)
;					joy=(temp&16=16)
;				EndIf


				Gosub SpinIt
			EndIf

			If mynxcnt=0

				;get joy from above
				If (\drop=Off) AND (joy<>0)
					\drop=On:reduce-1:
					If reduce.w<0 Then hoppy=starthoppy
				EndIf
				Gosub MoveIndiv
			EndIf
		Next


		CNIF #uscar>3
			Select myfrcnt
				Case 0:*p=*p4:Gosub MoveIndiv
				Case 1:*p=*p4:Gosub SpinIt:*p=*p5:Gosub SpinIt
				Case 2:*p=*p5:Gosub MoveIndiv
				Case 3:*p=*p4:Gosub SpinIt:*p=*p5:Gosub SpinIt

			End Select
		CEND


		CNIF #c=#a
			If Joyb(0)<>0 Then done=On
		CEND


		Gosub CheckWallLatent

		CNIF #c=#s
			If super
				MoveAll -*p0,#uscar
			Else
				MoveAll *p0,#uscar
			EndIf
		CELSE

			MoveAll *p0,shcar,#uscar
		CEND

;		myshadcar=JWrap(myshadcar+1,0,#uscar+1):*p=&Pl(myshadcar):Gosub DrawShadow
;		*p+(SizeOf.car*2):Gosub DrawShadow
;		*p+(SizeOf.car*2):Gosub DrawShadow



		##[$851E] tdist,#uscar,*p0




;		animate {skidm,myinfo.l,&fram(0)}
;		For cnt.w=myfrcnt To 63 Step 4
;			fram(cnt)+1
;		Next
;		EndIf





;		For mycar=0 To #uscar
;			*p=Pl(mycar)
;			Gosub PlaceCar
;		Next
;		*p=Pl(1):mycar=1
;		Gosub PlaceCar



		CNIF #c=#a
			If Joyb(0)<>0 Then done=On:bigdone=On
		CEND

	##[$80BC] done

	For fadeincol=0 To 22

		Gosub DoSegaGfx1
		!MyVWait
		Gosub DoSegaGfx2

		##[$C482] &chara(0) ,#wcram,64

		base.l=&chara(0)
		For roll=0 To 63
			Poke.w base,myfurther{Peek.w(base)}
			base+2
		Next

	Next

	CNIF #c=#s
		!setreg{0,$04} ;disable vert int
	CEND

	For pl=0 To #uscar
		*p=Pl(pl)
		##[$C491] *p\tune
	Next

CEND

	retch.w=On
Return

.BookKeep
	For pl=0 To #uscar
		*p=Pl(pl)
		Select *p\pos
			Case 0:*p\newscore=9
			Case 1:*p\newscore=6
			Case 2:*p\newscore=3
			Case 3:*p\newscore=1
			Default:*p\newscore=0
		End Select
	Next
Return




;				tempx=IOP(*p\myview\sx)
;				tempy=IOP(*p\myview\sy)
;				spr(cnt)\sx=tempx-12
;				spr(cnt)\sy=tempy+6
;				spr(cnt)\dpth=*p\dpth
;
;				*v.view=hisview(cnt)
;
;				*v\mx=((tempx-*v\px)ASR 1 +*v\mx)ASR 2:*v\px+*v\mx
;				*v\my=((tempy-*v\py)ASR 1 +*v\my)ASR 2:*v\py+*v\my
;
;				vp(cnt)\sx=JLimit(tempx+JInt(tempx-*v\px)-scrwh,0,767.5-scrw)
;				vp(cnt)\sy=JLimit(tempy+JInt(tempy-*v\py)-scrhh,0,383.5-scrh)


;	a0=car,a1=spr,a2=view,a3=vp

Statement chunkycar{*car.car,*sp.segasp,*v.view,*u.vp,*scr.scr}
	MOVEM.l a4-a5,-(a7)
	MOVE.l d0,a0:MOVE.l d1,a1:MOVE.l d2,a2:MOVE.l d3,a3:MOVE.l d4,a4

	MOVEQ #uscar,d7
	onemorecar
		LEA SizeOf.segasp*uscar+SizeOf.segasp(a1),a5
		MOVEM.l SizeOf.car\myview+SizeOf.view\sx(a0),d0-d1

		ASR.l #1,d0:ASR.l #1,d1:MOVE.l d0,d2:MOVE.l d1,d3
		ASR.l #1,d2:ASR.l #1,d3:ADD.l d2,d0:ADD.l d3,d1

		MOVE.l d0,d2:MOVE.l d1,d3:SWAP d2:SWAP d3
		SUB #$c,d2:;ADD #6,d3
		SUB #2,d3
		MOVE d2,SizeOf.segasp\sx(a1):MOVE d3,SizeOf.segasp\sy(a1)
		MOVE d2,SizeOf.segasp\sx(a5):MOVE d3,d4:ADD #8,d4
		ADD SizeOf.car\shady(a0),d4

		MOVE d4,SizeOf.segasp\sy(a5)

		MOVE SizeOf.car\dpth(a0),SizeOf.segasp\dpth(a1)


		MOVEM.l SizeOf.view\px(a2),d4/d5
		MOVE.l d0,d2:MOVE.l d1,d3:SUB.l d4,d2:SUB.l d5,d3
		ASR.l #1,d2:ASR.l #1,d3
		ADD.l SizeOf.view\mx(a2),d2:ADD.l SizeOf.view\my(a2),d3
		ASR.l #2,d2:ASR.l #2,d3
		MOVEM.l d2/d3,SizeOf.view\mx(a2)
		ADD.l d2,d4:ADD.l d3,d5
		MOVEM.l d4/d5,SizeOf.view\px(a2)

		SUB.l d0,d4:SUB.l d1,d5:CLR.w d4:CLR.w d5
		SUB.l d4,d0:SUB.l d5,d1
		SUB.l SizeOf.scr\scrwh(a4),d0
		SUB.l SizeOf.scr\scrhh(a4),d1
		MOVE.l #$3000000,d2:SUB.l SizeOf.scr\scrw(a4),d2
		MOVE.l #$1800000,d3:SUB.l SizeOf.scr\scrh(a4),d3

		TST.l d0:BGE godoy1:MOVEQ #0,d0:godoy1
		CMP.l d2,d0:BLE godoy2:MOVE.l d2,d0:godoy2
		TST.l d1:BGE godox1:MOVEQ #0,d1:godox1
		CMP.l d3,d1:BLE godox2:MOVE.l d3,d1:godox2


;					spr(cnt+#uscar+1.w)\sx=spr(cnt)\sx
;					spr(cnt+#uscar+1)\sy=spr(cnt)\sy+*op\shady


		SWAP d0:SWAP d1
		MOVEM.w d0-d1,SizeOf.vp\sx(a3)




		LEA SizeOf.car(a0),a0
		LEA SizeOf.segasp(a1),a1
		LEA SizeOf.view(a2),a2
		LEA SizeOf.vp(a3),a3


		DBRA d7,onemorecar
		MOVEM.l (a7)+,a4/a5
	AsmExit
End Statement






CNIF (#c=#s) AND #race
	.DoSegaGfx1

		If warpmode.w

				mindist.w=*newleader\pos;9
				*dp.car=*newleader
				For cnt.w=0 To #uscar
					*op.car=Pl(cnt)
					If *op\control<#contcomp
						If *op\pos<mindist Then mindist=*op\pos:*dp.car=*op
					EndIf

					spr(cnt)\sx=##[$C487](*op\myview\sx)-12
					spr(cnt)\sy=##[$C487](*op\myview\sy)-2;+6
					spr(cnt)\dpth=*op\dpth
					spr(cnt+#uscar+1)\sx=spr(cnt)\sx
					spr(cnt+#uscar+1)\sy=spr(cnt)\sy+*op\shady+8


				Next
				If *dp.car<>*newleader
					*oldleader=*newleader
					*newleader=*dp:lead.w=16
				EndIf

				lead-1:If lead<0 Then lead=0
				olead=16-lead
				*v.view=hisview(0)

				*v\sx=##[$C487]( (*newleader\myview\sx*olead+*oldleader\myview\sx*lead) ASR 4)
				*v\sy=##[$C487]( (*newleader\myview\sy*olead+*oldleader\myview\sy*lead) ASR 4)

;				*v\sx=spr(cnt)\sx	 ;IOP(MapX(Pl(cnt)\i,Pl(cnt)\j))
;				*v\sy=spr(cnt)\sy+19;IOP(MapY(Pl(cnt)\i,Pl(cnt)\j,skbm))
				*v\mx=((*v\sx-*v\px)ASR 1 +*v\mx)ASR 2:*v\px+*v\mx
				*v\my=((*v\sy-*v\py)ASR 1 +*v\my)ASR 2:*v\py+*v\my
				vp(0)\sx=##[$C386](*v\sx+##[$C381](*v\sx-*v\px)-scrwh,0,767.5-scrw)
				vp(0)\sy=##[$C386](*v\sy+##[$C381](*v\sy-*v\py)-scrhh,0,383.5-scrh)

;				If startrace>0 Then
				spoon(spptr.w)=tdist(*newleader\pos)\h:spptr=(spptr+1)&#spoon

		Else


			chunkycar{*p0,&spr(0),&hisview(0),&vp(0),&scr.scr}
;			For cnt.w=0 To #uscar
;				chunkycar{&Pl(cnt),&spr(cnt),&hisview(cnt),&vp(cnt),&scr.scr}
;				*p=Pl(cnt )
;
;				tempx=IOP(*p\myview\sx)
;				tempy=IOP(*p\myview\sy)
;				spr(cnt)\sx=tempx-12
;				spr(cnt)\sy=tempy+6
;				spr(cnt)\dpth=*p\dpth
;
;				*v.view=hisview(cnt)
;
;				*v\mx=((tempx-*v\px)ASR 1 +*v\mx)ASR 2:*v\px+*v\mx
;				*v\my=((tempy-*v\py)ASR 1 +*v\my)ASR 2:*v\py+*v\my
;
;				vp(cnt)\sx=JLimit(tempx+JInt(tempx-*v\px)-scrwh,0,767.5-scrw)
;				vp(cnt)\sy=JLimit(tempy+JInt(tempy-*v\py)-scrhh,0,383.5-scrh)
;			Next

		EndIf





		setupvps{*nv0,&vp(0)}

		For *p=*p0 To *maxp Step SizeOf.car
			If (*p\coll>0) AND (*p\idle<0)
				roll.w=*p\coll+1
				If roll>60 Then *p\coll=-1:Else *p\coll=roll
			EndIf
		Next


		motl.l=mptl.l
		mptl.l=skidm+##[$C381](vp(0)\sx LSR 3)ASL1+##[$C381](vp(0)\sy LSR 3)*192;96*2

		If (screenmode&1)=1 ;split horizontal..
			motr.l=mptr.l
			mptr.l=skidm+##[$C381](vp(2)\sx LSR 3)ASL1+##[$C381](vp(2)\sy LSR 3)*192;96*2
		EndIf

		If screenmode=2
			motla.l=mptla.l
			mptla.l=skidm+##[$C381](vp(1)\sx LSR 3)ASL1+##[$C381](vp(1)\sy LSR 3)*96*2
		EndIf
		If screenmode=3
			motla.l=mptla.l
			motra.l=mptra.l
			mptla.l=skidm+##[$C381](vp(1)\sx LSR 3)ASL1+##[$C381](vp(1)\sy LSR 3)*96*2
			mptra.l=skidm+##[$C381](vp(3)\sx LSR 3)ASL1+##[$C381](vp(3)\sy LSR 3)*96*2
		EndIf




		doSortSprites{&cptr(0)}
		##[$80C9] buffa1,buffa2
		##[$80C9] buffb1,buffb2
		If (screenmode&1)=0
			dodoSegaSprites{&cptr(0),*nv0,buffa1+32}
		Else
			doSegaSprites{&cptr(0),*nv0,buffa1+32,super}
		EndIf




#skipval=220;15

;		If (myfrcnt&1)=0


		 replup
			 TST $ff0000:BLT dunrep
			 MOVE $c00008,d0

			 CMP.w #skipval*256,d0
			 BCC dunrep

;			While (Peek.w($c00008)LSR 8)&255<#skipval
;				Poke.w $c00004,$8702+ddcar.w
				ddcar.w=ddcar+1

				If (ddcar>#uscar) OR (ddcar<0) Then ddcar=0
				*p=Pl(ddcar)
				If *p\upd&2 Then ##[$C48B] 0,*p\fr,*p\q,*p\bnk ,*p\carnum
				If *p\upd&1 Then Gosub DrawShadow
				*p\upd=0

				BRA replup
			dunrep



		MOVE #$8700,$c00004

	Return



	.DoSegaGfx2


		If (screenmode&1)=0

			!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
			!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical
			If motl<>mptl Then ##[$C485] mptl,0,41,blkh

			If screenmode=2
				If motla<>mptla Then ##[$C485] mptla,16*64*2					,41,blkh
			EndIf

		Else

			!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
			!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical
			!pokemem{#wvram+$10020000,-(vp(2)\sx AND 7)+(64-21)*8} ;horizontal
			!pokemem{#wsram+$00020000, (vp(2)\sy AND 7)}					 ;vertical
			If motl<>mptl Then ##[$C485] mptl,0				,20,blkh
			If motr<>mptr Then ##[$C485] mptr,(64-22)*2,20,blkh

			If screenmode=3
				If motla<>mptla Then ##[$C485] mptla,16*64*2					,20,blkh
				If motra<>mptra Then ##[$C485] mptra,16*64*2+(64-22)*2,20,blkh
			EndIf
		EndIf


		##[$C482] buffa1,#wvram+$fc00,320


		If myfrcnt&1=0
;			SegaCar 0,Pl(0)\fr,$f300,0	 ,Pl(0)\carnum
		CNIF #uscar<4
			##[$C482]	 *p0\q ,#wvram+$ec40,768;288
		CELSE
			##[$C482]	 *p0\q ,#wvram+$ec40,1008
		CEND
;			SegaCar 0,Pl(2)\fr,$f540,1	 ,Pl(2)\carnum
;			SegaDMA	 Pl(2)\q ,$f540,288

		Else
;			SegaCar 0,Pl(1)\fr,$f780,0	 ,Pl(1)\carnum
			CNIF #uscar<4
				##[$C482]	 *p1\q ,#wvram+$f420,768;288
			CELSE
				##[$C482]	 *p1\q ,#wvram+$f420,1008
			CEND
;			SegaCar 0,Pl(3)\fr,$f9c0,1	 ,Pl(3)\carnum
;			SegaDMA	 Pl(3)\q ,$f9c0,288

		EndIf



		!doflag



		!showblk


		If screenmode=2
			Poke.w $ff0020, (vp(1)\sy &7)+8;-15*8
			Poke.w $ff0022, (vp(1)\sy &7)+8;-15*8
			Poke.w $ff0024,-(vp(1)\sx &7)
			Poke.w $ff0026,-(vp(1)\sx &7);+(64-21)*8
			Poke.l $ff0028,3	;sprite link
		EndIf
		If screenmode=3
			Poke.w $ff0020, (vp(1)\sy &7)+8;-15*8
			Poke.w $ff0022, (vp(3)\sy &7)+8;-15*8
			Poke.w $ff0024,-(vp(1)\sx &7)
			Poke.w $ff0026,-(vp(3)\sx &7)+(64-21)*8
			Poke.l $ff0028,3	;sprite link
		EndIf


		Poke.l $ff0010,buffb1

	Return
CEND




CNIF #collisions AND #race


Macro bitme					;!hitme{*ap,*sha,cra,*rp<>*ap}
	If `4
;		If (*rp\towed<>`1) AND (`1\towed<>*rp)
			If ##[$8524](`1\i,`1\j,`1\k,*rp\i,*rp\j,*rp\k)
				`3=Off
				If (`1\coll<0)
					If FastCollide(`1,*rp,`2)
						verydum.w=-1
;						chan(*rp\channel)\reqsam=2
;						chan(`1\channel)\reqsam=2
					EndIf
				EndIf
			EndIf
;		EndIf
	EndIf
End Macro


	.Crash
;		If myfrcnt.w>1 Then Return
;		!showred
		crash.w=0

;		pla.w=ipl:*ap.car=*cp0
;		pla=myfrcnt:*ap.car=Pl(pla)
		*rp.car=*p0:cra.w=On

		If *ap\coll<0
;			*sha=Bank(*ap\bnk)+*ap\head*SizeOf.ShadPt
;			*sha.ShadPt=?shadowdat+*ap\head*SizeOf.ShadPt
;				Peek.l($ff000c)+\carnum ASL 12
			*sha.ShadPt=Peek.l($ff000c)+\carnum ASL 12+*ap\head*SizeOf.ShadPt
			For *rp=*p0 To Pl(#uscar) Step SizeOf.car
				If *rp\coll<0
					!bitme{*ap,*sha,cra,*rp<>*ap}
				EndIf

			Next

		EndIf
;		!fixit{cra,*ap}

	Return
CEND


;			If myfrcnt=0
;				*ap.car=Pl(0):*rp.car=Pl(1)
;				Gosub DoMyColl
;			EndIf
;			If myfrcnt=1
;				*ap.car=Pl(1):*rp.car=Pl(0)
;				Gosub DoMyColl
;			EndIf
;
;.DoMyColl
;	*sha.ShadPt=?shadowdat+*ap\head*SizeOf.ShadPt
;	If MyRectsHit(*ap\i,*ap\j,*ap\k,*rp\i,*rp\j,*rp\k)
;		mydumvar.w=FastCollide(*ap,*rp,*sha)
;	EndIf
;Return
;CEND


.DoMainS
;Safe{}





.
.DoMainJ

CNIF #c=#j

	##[$80BB]

		!waitdsp:!waitgpu:!waitblit	;wait till previous frame rendered!

		##[$80C9] *bmr1.jbmap,*bmr2.jbmap
		MOVE framecnt,d7:'wdb:CMP framecnt,d7:BEQ 'wdb

		*bmr=*bmr1

		BlCls{*bmr,0,0};$1010101,$10101010}

		CNIF #bars
			Poke.w $f0002a,0
		CEND

		!waitgpu
		!waitblit
		!waitdsp

;		Poke.l *bmr\idata+320+8,$ffffffff

		Gosub PlaceCarold

		stt=jint{(mytau-2)*2}
		For gt=stt To stt+8 ;Step 2
			t=gt

			If t<2 Then t+pts
;			If t>pts2 Then t-pts
			##[$80C9] mapa.l,mapb.l
			map.l=mapa
			Gosub RotObj

			!waitdsp
			!waitgpu
			!waitblit
			BlCopyMem{tritemp.l,map.l,trisize.l }

			Gosub Draw
		Next

		!waitgpu
		!waitblit

		CNIF #bars
			Poke.l $f0002a,$ffff
			Poke.w $f0002a,mysilly.w:mysilly+1
		CEND

		GetJoy{&jox.l,&joy.l,&butt.l}

	##[$80BC] 1=0
CEND
Return

.
CNIF #c=#a
	.DoMainA


		##[$80BB]
			VWait
		##[$80BC] Joyb(0)<>0


	Return
CEND



Macro calc
	`1=base(t)+(`2+ ((`3)*((`3)+1)) ASR 1)*SizeOf.vec
End Macro

Macro mpc
	`1=map+(`2+ ((`3)*((`3)+1)) ASR 1)*SizeOf.xy
End Macro



.trijunk

NEWTYPE .vec
	x.q:y:z
End NEWTYPE

NEWTYPE.xy
	y.w:x.w
End NEWTYPE

NEWTYPE .tri
	a.w:b.w:c.w
End NEWTYPE


DEFTYPE.vec *dest,*dest2,*dest3,*dest4

.InitTris

CNIF #c=#j
		mapa.l=GetMem32{65536}
		mapb.l=GetMem32{65536}

		colbase.l=GetMem32{32768}
		map.l=mapa

	Dim vec.vec(10000):vecs.l=-1
	Dim tri.tri(10000)
	Dim base.l(100)


		sx1=-10:sy1=-30:sz1=30
		sx2=-10:sy2=30 :sz2=30
		sx3=20:sy3=0	 :sz3=30
		Gosub Generate
		For t=0 To tri.l
			base(t)=GetMem32{SizeOf.vec*9*10/2}
			a=tri(t)\a
			b=tri(t)\b
			c=tri(t)\c
			sx1=vec(a)\x; ASL 6
			sy1=vec(a)\y; ASL 6
			sz1=vec(a)\z; ASL 6
			sx2=vec(b)\x; ASL 6
			sy2=vec(b)\y; ASL 6
			sz2=vec(b)\z; ASL 6
			sx3=vec(c)\x; ASL 6
			sy3=vec(c)\y; ASL 6
			sz3=vec(c)\z; ASL 6
			Gosub Make
		Next

		For h.w=0 To 18*18
			col.q=(##[$8481](h,0)+1)*127+1:temp.l=col&255
			temp=temp ASL 8 + temp
			Poke.l colbase+h ASL 2,temp ASL 16+temp
		Next
	CEND

Return




.Make
CNIF #c=#j
	!calc{*dst.vec,0,0}:xx=sx1:yy=sy1:zz=sz1:Gosub Split
	!calc{*dst.vec,0,8}:xx=sx2:yy=sy2:zz=sz2:Gosub Split
	!calc{*dst.vec,8,8}:xx=sx3:yy=sy3:zz=sz3:Gosub Split

	scal=8:hscal=scal ASR 1
	For cnt.w=0 To 2

		For y=hscal To 7 Step scal
			For x=hscal To y Step scal

				!calc{*dest2,x-hscal,y-hscal}
				!calc{*dest3,x-hscal,y+hscal}
				!calc{*dest4,x+hscal,y+hscal}

				x2=*dest2\x:y2=*dest2\y:z2=*dest2\z
				x3=*dest3\x:y3=*dest3\y:z3=*dest3\z
				x4=*dest4\x:y4=*dest4\y:z4=*dest4\z

				!calc{*dest,x,y}
				!calc{*dest2,x-hscal,y}
				!calc{*dest3,x,y+hscal}

				xx=(x2+x4) ASR 1
				yy=(y2+y4) ASR 1
				zz=(z2+z4) ASR 1
				*dst.vec=*dest:Gosub Split

				xx=(x2+x3) ASR 1
				yy=(y2+y3) ASR 1
				zz=(z2+z3) ASR 1
				*dst.vec=*dest2:Gosub Split

				xx=(x3+x4) ASR 1
				yy=(y3+y4) ASR 1
				zz=(z3+z4) ASR 1
				*dst.vec=*dest3:Gosub Split

			Next
		Next
		scal ASR 1:hscal ASR 1
	Next
CEND

CNIF 1=0
	For y=0 To 8
		For x=0 To y
			!calc{*dst,x,y}
			xx=*dst\x ASR 6
			yy=*dst\y ASR 6
			zz=*dst\z ASR 6
			dist=(10 ASL 2)/jsqr{xx*xx+yy*yy+zz*zz}
;			*dst\x=Sin(ang1)*10;xx*dist
;			*dst\y=Cos(ang1)*10;yy*dist
;			*dst\z=0;zz*dist



			ad.l=?sincos+((x ASL 4) ASL 2)
			qs=Peek.w(ad	)ASR 15
			qc=Peek.w(ad+2)ASR 15

			ad.l=?sincos+(((8-y) ASL 4) ASL 2)
			ps=Peek.w(ad	)ASR 15
			pc=Peek.w(ad+2)ASR 15

			*dst\x=qs*30*pc
			*dst\y=qc*30*pc
			*dst\z=-ps*30
		Next
	Next
CEND
Return


.Split
CNIF #c=#j
	*dst\x=xx
	*dst\y=yy
	*dst\z=zz
CEND

Return




NEWTYPE .vert
	t.q:plus.w
	dx.q:dy.q
End NEWTYPE

CNIF #c=#a
		#sc=2
CEND




.InitLatMem

	Dim latchl(31),latchr(31)
	latls.w=-1:latrs.w=-1
	Dim vert.vert(240)
	vecs.l=-1:tri.l=-1
Return

CNIF #maketri
	Function.w FindNext{mmin,mmax,plus.w}

	Shared vert(),verts
		mptr=-1
		For cnt.w=0 To verts
			If vert(cnt)\plus=plus
				If mmin<vert(cnt)\t
					If vert(cnt)\t<mmax
						mmax=vert(cnt)\t
						mptr=cnt
					EndIf
				EndIf
			EndIf
		Next

		Function Return mptr
	End Function

	Function.w FindNextLat{mmin,mmax,plus.w}
	Shared latchl(),latchr(),latls.w,latrs.w
		mptr=-1
		If plus
			For cnt.w=0 To latls
				If mmin<latchl(cnt)
					If latchl(cnt)<mmax
						mmax=latchl(cnt)
						mptr=cnt
					EndIf
				EndIf
			Next
		Else
			For cnt.w=0 To latrs
				If mmin<latchr(cnt)
					If latchr(cnt)<mmax
						mmax=latchr(cnt)
						mptr=cnt
					EndIf
				EndIf
			Next
		EndIf
		Function Return mptr
	End Function



.Generate

	mystp=1 ASR 5
	For mycnt.w=0 To 7
		plusa.w=(mycnt&1=1)
		plusb.w=(mycnt&2=2)
		If mycnt>3
			tau1=31
			tau2=19
		Else
			tau1=12
			tau2=3
		EndIf

		For k=1 To 5

			FindLo tau1
			If plusa
				x1=bez\i:y1=bez\j
			Else
				x1=bez\k:y1=bez\l
			EndIf
			FindDif tau1+mystp
			If plusa
				dx1=bez\i ASL 5:dy1=bez\j ASL 5
			Else
				dx1=bez\k ASL 5:dy1=bez\l ASL 5
			EndIf

			FindLo tau2
			If plusb
				x2=bez\i:y2=bez\j
			Else
				x2=bez\k:y2=bez\l
			EndIf
			FindDif tau2+mystp
			If plusb
				dx2=bez\i ASL 5:dy2=bez\j ASL 5
			Else
				dx2=bez\k ASL 5:dy2=bez\l ASL 5
			EndIf


			mag1=jsqr{dx1*dx1+dy1*dy1}
			mag2=jsqr{dx2*dx2+dy2*dy2}
			dista=((x1-x2)*dy2-(y1-y2)*dx2)/mag2
			distb=((x2-x1)*dy1-(y2-y1)*dx1)/mag1
			tau1=##[$C384](tau1+dista/mag1,2,pts3)
			tau2=##[$C384](tau2-distb/mag2,2,pts3)
		Next
		If plusa
			latls+1:latchl(latls)=tau1
		Else
			latrs+1:latchr(latrs)=tau1
		EndIf
		If plusb
			latls+1:latchl(latls)=tau2
		Else
			latrs+1:latchr(latrs)=tau2
		EndIf

		FindLo tau1
		If plusa
			Circle bez\i ASL #sc,bez\j ASL #sc,4,3
		Else
			Circle bez\k ASL #sc,bez\l ASL #sc,4,3
		EndIf
		FindLo tau2
		If plusb
			Circle bez\i ASL #sc,bez\j ASL #sc,4,4
		Else
			Circle bez\k ASL #sc,bez\l ASL #sc,4,4
		EndIf

	Next

	basel=latchl(FindNextLat{2,pts4,On})
	baser=latchr(FindNextLat{2,pts4,Off})

	For hiscnt.w=0 To 6

		verts=-1
		plus.w=On
		tau1=basel;
		tau2=latchl(FindNextLat{tau1 ,pts4,plus})	:	basel=tau2
		Gosub FryIt

		plus.w=Off
		tau1=baser;latchr(FindNextLat{baser,pts4,plus})
		tau2=latchr(FindNextLat{tau1 ,pts4,plus})	:	baser=tau2
		Gosub FryIt


		Gosub MakeGoodTri
	Next

Return
CEND



.MakeGoodTri
CNIF #c=#a
	curl=FindNext{1,pts4,On}
	curr=FindNext{1,pts4,Off}
		mminl=vert(curl)\t
		mminr=vert(curr)\t

	FindLo mminl
	x1=bez\i:y1=bez\j
	FindLo mminr
	x2=bez\k:y2=bez\l

	done.w=Off
	##[$80BB]
		Line x1 ASL #sc, y1 ASL #sc, x2 ASL #sc, y2 ASL #sc,5

		mminl=vert(curl)\t
		mminr=vert(curr)\t
		nxl=FindNext{mminl,pts4,On}
		nxr=FindNext{mminr,pts4,Off}

		If (nxl>-1) OR (nxr>-1)

			x3=-200:y3=-200
			x4=-200:y4=-200
			If nxl>-1
				FindLo vert(nxl)\t
				x3=bez\i:y3=bez\j
			EndIf
			If nxr>-1
				FindLo vert(nxr)\t
				x4=bez\k:y4=bez\l
			EndIf


			dx=(x4-x1) ASR 3
			dy=(y4-y1) ASR 3
			distl=dx*dx+dy*dy
			dx=(x3-x2) ASR 3
			dy=(y3-y2) ASR 3
			distr=dx*dx+dy*dy

			If distl>distr
				Line x1 ASL #sc, y1 ASL #sc, x3 ASL #sc, y3 ASL #sc,6
				x1=x3:y1=y3:curl=nxl
			Else
				Line x4 ASL #sc, y4 ASL #sc, x2 ASL #sc, y2 ASL #sc,7
				x2=x4:y2=y4:curr=nxr
			EndIf

		Else
			done.w=On
		EndIf
	##[$80BC] done

CEND

Return


.FryIt
CNIF #c=#a
;	FindLo tau2
;	x1=bez\k ASL #sc:y1=bez\l ASL #sc
;	Line x1,y1,x1+10,y1+10,5

;	verts=0
	verts+1
	vert(verts)\t=tau1
	vert(verts)\plus=plus
	verts+1
	vert(verts)\t=tau2
	vert(verts)\plus=plus



	For pass.w=0 To 1
		dtp=tau1
		dista=0

		While dtp<tau2

			dtp+0.05
			FindLo dtp
				If plus
					newi=bez\i:newj=bez\j
				Else
					newi=bez\k:newj=bez\l
				EndIf
			FindDif dtp+0.02

			If plus
				dx=bez\i*(50*0.05)
				dy=bez\j*(50*0.05)
			Else
				dx=bez\k*(50*0.05)
				dy=bez\l*(50*0.05)
			EndIf

			dista=dista+jsqr{dx*dx+dy*dy}
			If pass=1
				If dista>myidt
CNIF #c=#a
					Point newi ASL #sc,newj ASL #sc,1
CEND
					dista-myidt
					verts+1:vert(verts)\t=dtp
					vert(verts)\plus=plus
				EndIf
			EndIf

		Wend

		If pass=0
			myidt=(dista+0.01)/(##[$C381](dista/7)+1)
		EndIf

	Next
CEND


Return







.PlaceCarold

CNIF #c=#j
;	If butt&1 Then rotang+1
;	If butt&2 Then rotang-1



	mytau=mytau+joy*0.1

	FindLo mytau
	quikx=(bez\i+bez\k) ASR 1
	quiky=(bez\j+bez\l) ASR 1
	FindDif mytau+1



	fredang=Angle((bez\i+bez\k) ASL 4,(bez\j+bez\l) ASL 4) ASR 16
	qs=-jsin{fredang} ASR 2
	qc=-jcos{fredang} ASR 2
;	rotang*0.98
;	fredang=fredang+rotang



;	ad.l=?sincos+((fredang&1023) ASL 2)
;	f=jfrac{fredang}:of=1-f
;	qs=Peek.w(ad	)*of+Peek.w(ad+4)*f
;	qc=Peek.w(ad+2)*of+Peek.w(ad+6)*f
CEND

Return



.RotObj


CNIF 1=0
	myscal=2;1.3
	qqs=jext{qs}*2*myscal
	qqc=jext{qc}*2*myscal
	*dest=base(0)
	*mp.xy=map

	For y=0 To 16
		For x=0 To y
;			!calc{*dest,x,y}
;			!mpc{*mp.xy,x,y}

			*mp\x=(*dest\x*qqc-*dest\y*qqs +160)ASL 4

			hgh=*dest\x*qqs+*dest\y*qqc +100
			If hgh<0 Then hgh=0
			*mp\y=(hgh&$ffff) ASL 2
			*dest+SizeOf.vec
			*mp+SizeOf.xy
		Next
	Next
CEND



CNIF #c=#j

	!waitdsp

;	BlCopyMem{map.l,tritemp.l,trisize.l }
	mytemp.l=$f1cf80

	Poke.l mytemp	,tritemp.l	;dest
	Poke.l mytemp+4,base(t)		;src

	Poke.l mytemp+	8,jfr{qs ASR 1,qc ASR 1}
;	quikx.q=(5-jfrac{deadx}) ASL 6
;	quiky.q=(5-jfrac{deady}) ASL 6

	Poke.q mytemp+ $c,quikx
	Poke.q mytemp+$10,quiky

	!rundsp{0}

;	!waitdsp

;	BlCopyMem{tritemp.l,map.l,trisize.l }
	Return
CEND



Return



.Draw
CNIF #c=#j

	BlPoly{*bmr,map,colbase}
CEND

CNIF #c=#a
	For y=0 To 15
		!mpc{*mp.xy,0,y}
		*mpn.xy=*mp+SizeOf.xy*(y+1)
		*dt2.xy=*mpn+SizeOf.xy


;		fred(0)=*mp\x:fred(1)=*mp\y
;		fred(2)=*mpn\x:fred(3)=*mpn\y
;		fred(4)=*dt2\x:fred(5)=*dt2\y
;		Polyf 3,&fred(0),*mp\c2


		For x=0 To y-1
			*mp+SizeOf.xy

;			fred(2)=*mp\x:fred(3)=*mp\y
;			Polyf 3,&fred(0),*mp\c1
			*mpn=*dt2:*dt2+SizeOf.xy

;			fred(0)=*mp\x:fred(1)=*mp\y
;			fred(2)=*mpn\x:fred(3)=*mpn\y
;			fred(4)=*dt2\x:fred(5)=*dt2\y
;			Polyf 3,&fred(0),*mp\c2

;			BlLin{*bmr,*mpn\x ASR 4,*mpn\y ASR 2,*mp\x ASR 4,*mp\y ASR 2,x+1}

		Next
	Next

CEND
Return


;			BlLin{*bmr,*dt4\x ASR 4,*dt4\y ASR 2,*dt2\x ASR 4,*dt2\y ASR 2,*mp\c}
;			BlLin{*bmr,*dt2\x ASR 4,*dt2\y ASR 2,*dt3\x ASR 4,*dt3\y ASR 2,*mp\c}

























.
.
.
.
.
.
.


##[$80CA] *p
.SpinIt

;	If jox=2 Then chan(\channel)\reqsam=3:jox=0
	If \inair
		\rot=##[$C386](\rot,-1,1)
	Else
		If \idle<0
			If \control=#contcomp
				\rot=(\rot+*p\jox*\steering) ASR 1
			Else
				\rot=(\rot+	 jox*\steering) ASR 1
			EndIf
		EndIf
	EndIf

	oldk=\k
	If \drop

		\headk-\gravity:newk=\k+\headk+\headk
		tx=\i+\headi+\headi:tz=\j+\headj+\headj
		soonk=QHite(tx,tz,skbm)
		If newk >soonk
;			Stop
			\inair=On:\traction=1
			CNIF #c=#s
			 Select (Peek.w($c00004) AND 7)	;quick random..
				 Case 0:\pitch=##[$C386](\pitch+\mpitch,0,4)
				 Case 1:\roll =##[$C386](\roll +\mroll ,0,4)
				 Default
				End Select
			CEND
		Else

			\headk=(soonk-oldk)ASR 1:\inair=Off

			pitch.w=##[$C386]((QHite(tx,tz+0.2,skbm)-soonk)+2.5,0,4)
			\mpitch=##[$C382](pitch-\pitch):\pitch+\mpitch

			roll.w=##[$C386]((QHite(tx-0.2,tz,skbm)-soonk)+2.5,0,4)
			\mroll=##[$C382](roll-\roll):\roll+\mroll

		EndIf
	EndIf

	\dir=##[$851A](\dir+\rot)
	\qc=qcos(\head):\qs=qsin(\head)
	roll.w=\roll*160+\pitch ASL 5+\head ASR 1

	If roll<>\fr
		\fr=roll:\upd=3
	Else
		\upd=1
	EndIf
Return



Macro FindScr
	*s\v`1x=(*sha\rx`1																					 )
	*s\v`1y=(*sha\ry`1-##[$C487](QHite(\i+*sha\ri`1,\j+*sha\rj`1,skbm)-oldk))
;	*s\v`1y=IOP(MapY(\i+*sha\ri`1,\j+*sha\rj`1,skbm))

End Macro


##[$80CA] *p
.DrawShadow

	CNIF #c=#s

		oldk=\k

		*s.quad=&quadverts(0);\q
;		*sha.ShadPt=peek.l($ff000c)+?shadowdat+SizeOf.ShadPt*FixAng(\head+0.5)
		*sha.ShadPt=Peek.l($ff000c)+\carnum ASL 12 +SizeOf.ShadPt*##[$851A](\head+0.5)
		!FindScr{0}:!FindScr{1}:!FindScr{2}:!FindScr{3}
;		temp=0

		temp=##[$C483] (&quadverts(0),*p\q+384)
		*p\shady=temp

;		If QAbs(*p\headk)>3
;			*p\segasp\rshady=-1
;		Else
;			*p\segasp\rshady=0
;		EndIf

	CEND


Return


Statement bounce{result.w,*e.quadratic,*par.parse}
	Shared sqlu.l

;result obtained from TestNew..
;fi,fj are the params to be changed...
;di,dj,i,j are just for fun..

	here.w=Off ; in case we crash more than once?

	result+16
	##[$80BB]
		If ( (result & 1)=1)
			If *e\lstraight
				here+FixHitLine(*e,*par)
			Else
				here+FixHitQuad(*e,*par,sqlu)
			EndIf
		EndIf	 ;noimpact
		result ASR 1
		*e+#hquad
		*par\norm+32
	##[$80BC] (result=1) ; OR (here=On)
	*par\norm AND 63
	*par\boom=(here<0)
End Statement	;end of bounce



Statement Damage{result.w,*e.quadratic,*par.parse}
	##[$80BB]
		If ( (result & 1)=1)
			If *e\lstraight
				deli=*par\fi-*e\lc
				delj=*par\fj-*e\lf
				fac=*e\lb*deli+*e\le*delj
				*par\i=*e\lc+*e\lb*fac
				*par\j=*e\lf+*e\le*fac	;				here+bouncenew{*e,*par}
			Else
				deli=*par\fi-*e\lc
				delj=*par\fj-*e\lf
				fac=*e\lb*deli+*e\le*delj
				*par\i=*e\lc+fac*(*e\lb+*e\ma*fac)
				*par\j=*e\lf+fac*(*e\le+*e\md*fac) ;				here+bouncepod{*e,*par,sqlu}
			EndIf
		EndIf	 ;noimpact
		result ASR 1
		*e+#hquad
	##[$80BC] (result=0)
End Statement	;end of Damage


#mung=On
#clip=On

##[$80CA] *p
.MoveIndiv
CNIF #race

;	If \towed<>0 Then Return

	If \control=#contcomp Then comp=On:Else:comp=Off	;computer override!

	If \idle<0 ;be strict!


		\movi=0:\movj=0

	CNIF #mung
		*par\fi=\i:*par\fj=\j
		*par\i =\i:*par\j =\j
		dt=\curdt
		*e=edge(dt):result.w=CheckCollQuad(*e,*par):*g.xtra=grot(dt+1)
		If result.w>0
			If (result&5)>0
				If (*g\cai-*par\fi)**g\swivj > (*g\caj-*par\fj)**g\swivi
					result&14
				Else
					result&11
				EndIf
			EndIf
			If (result&10)>0
				If (*g\cai-*par\fi)**g\swivj > (*g\caj-*par\fj)**g\swivi
					result&13
				Else
					result&7
				EndIf
			EndIf

			If result>0
				Damage{result,*e,*par}
				\i=*par\i:\j=*par\j:\headi=0:\headj=0
			EndIf

		EndIf
		;mung walls (fin)
	CEND


		If \inair
			\nrev=0
		Else

			If comp

				\jox=0
				ni=*p\i+*p\headi ASL 2
				nj=*p\j+*p\headj ASL 2

				mess.w=firstmass(##[$C384](*p\curdt,2,pts3))
				*first.guide=mass(mess)
				safe=On
;				MOVE #$8708,$c00004
				DEFTYPE.guide *guide
				cur.w=\curdt
				cur=##[$C384](mess+##[$8529](massbase.l,&mass(mess),massbig.l,ni,nj,cur,pts1),0,nxmass.w)
CNIF 1=0
				While safe
					mess=##[$C384](mess+1,0,nxmass.w)
					*guide.guide=mass(mess)
					dif=(*guide\dtp-\curdt)
					If dif<0 Then dif+pts1
					If (dif>-2 AND dif<8)
						difi=*guide\mi-ni
						difj=*guide\mj-nj
						If (*guide\di*difj-*guide\dj*difi)<0
							cur.w=mess:maxout=dist:safe=Off
						EndIf
					EndIf
				Wend
CEND
;				MOVE #$8700,$c00004

				desti=0
				*guide	 =mass(			cur						)
				*lg.guide=mass(##[$C384](cur-1,0,nxmass))

				If lapdir=1
					difi=*guide\li-ni:normi=*guide\li-*lg\li
					difj=*guide\lj-nj:normj=*guide\lj-*lg\lj
					If difi*normj<difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\ri:destj=*rg\rj:joy=cmpacc7
					EndIf

					difi=*guide\ri-ni:normi=*guide\ri-*lg\ri
					difj=*guide\rj-nj:normj=*guide\rj-*lg\rj
					If difi*normj>difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\li:destj=*rg\lj:joy=cmpacc7
					EndIf
				Else
					##[$80C9] *lg,*guide

					difi=*guide\li-ni:normi=*guide\li-*lg\li
					difj=*guide\lj-nj:normj=*guide\lj-*lg\lj
					If difi*normj>difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\ri:destj=*rg\rj:joy=cmpacc7
					EndIf

					difi=*guide\ri-ni:normi=*guide\ri-*lg\ri
					difj=*guide\rj-nj:normj=*guide\rj-*lg\rj
					If difi*normj<difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\li:destj=*rg\lj:joy=cmpacc7
					EndIf

				EndIf


				If desti=0
					*rg.guide=mass(##[$C384](cur+lapdir4,0,nxmass))
					desti=*rg\mi:destj=*rg\mj:joy=cmpacc
				EndIf

;				MOVE #$8707,$c00004

				difi=desti-\i
				difj=destj-\j
				\jox=##[$C382](difi*\qs-difj*\qc)
			EndIf

			\vel=\headi*\qc+\headj*\qs

									;	*****	 HILL	 ******
			tx=\i-\qc:tz=\j-\qs
			If \vel<0
				joy+(\headk ASR 1)	;hmmmm
			Else
				joy-(\headk ASR 1)	;hmmmm
			EndIf
;			joy+(!qhite{tx,tz}-\k) ASR 3

			##[$8528] *p,joy
;			\nrev=(\rev+joy*\accel)*(\engfric)
;
;			\movi+(\qc*\nrev)-\headi
;			\movj+(\qs*\nrev)-\headj
;			\nrev=(\nrev-\rev) ASR 2
;
;			\traction=JAbs(\qc*\movj-\qs*\movi)
;
;			\movi*\retard
;			\movj*\retard

		EndIf

		ddi1=\headi ASL 2+(\movi ASL 2+ \movi) ASL 1
		ddj1=\headj ASL 2+(\movj ASL 2+ \movj) ASL 1
		proi=\i+ddi1
		proj=\j+ddj1

		*g=grot(\curdt)
		ni=proi-*g\midi:nj=proj-*g\midj
		If *g\dirj*ni < *g\diri*nj	;n.b. qwrap (2,pts3)
			\curdt-1
			If (\curdt<		2) Then \curdt+pts1:lapinc.w=-lapdir:Gosub DrawLaps
;			If leadtime(\curdt)<tim Then leadtime(\curdt)=tim

		Else
			*g=grot(\curdt+1):ni=proi-*g\midi:nj=proj-*g\midj
			If *g\dirj*ni > *g\diri*nj
				\curdt+1
				If (\curdt>pts2) Then \curdt-pts1:lapinc=lapdir:Gosub DrawLaps
;				If leadtime(\curdt)<tim Then leadtime(\curdt)=tim
			EndIf
		EndIf



	CNIF #clip
		test\boom=Off
		ddi1=-ddi1
		ddj1=-ddj1
		test\i =*p\i:test\j =*p\j
		test\fi=proi:test\fj=proj
		test\di=ddi1:test\dj=ddj1

		\side=0:\top=0
		If (##[$C385](ddi1) < 0.02) AND (##[$C385](ddj1) < 0.02) ;goslo
			\headi=0:\headj=0:\movi=0:\movj=0
			ddi1=0:ddj1=0
		Else
			ro=ddi1 ASL 6:ger=ddj1 ASL 6
			qfac.q=RDistance(ro,ger) ASL 7
			test\diri=ddi1*qfac
			test\dirj=ddj1*qfac

			dt=\curdt:							;*g=grot(dt)
			*e=edge(dt)
			result.w=CheckCollQuad(*e,*par)
			If result<>0
				*par\boom=Off
				bounce{result,*e,*par}
				If test\boom
					##[$8527] *p,*par,&qcos(0),&qsin(0),ddi1,ddj1
CNIF 1=0
					\swai=test\fi
					\swaj=test\fj

					\headi=-ddi1 ASR 2:\movi=0
					\headj=-ddj1 ASR 2:\movj=0


					\swiv=##[$851A]((\dir-*par\norm)*2)

					\difi=qcos(*par\norm)
					\difj=qsin(*par\norm)	;Hooway!

;					If *p=*p0
;						Use BitMap 0
;						Line MapX(\swai,\swaj),MapY(\swai,\swaj),MapX(\swai+\difi,\swaj+\difj),MapY(\swai+\difi,\swaj+\difj),14
;					EndIf

					If ddi1<0 Then \side=1 Else \side=2
					If ddj1<0 Then \top=3 Else \top=4
CEND
				EndIf
			EndIf
		EndIf
	CEND

	Else
		##[$80CA] *p
		If \idle=1

			\traction=0

			dtp=##[$C384](signmovst+*p\pos*signmov,3,pts4) ;quick you fool!
;			dtp=JWrap(signmovst+*p\carnum*signmov,3,pts4) ;quick you fool!
			FindLo dtp,skbm
			If signside.w
				difi=bez\i-\i:difj=bez\j-\j
			Else
				difi=bez\k-\i:difj=bez\l-\j
			EndIf

			\headi=difi ASR 4
			\headj=difj ASR 4
			\movi=0:\movj=0
			FindLo dtp-0.05,skbm:FindDif dtp+0.1,skbm
			If signside.w
				ddist=##[$851A](Angle(bez\i ASL 3,-bez\j ASL 3) ASR 10	 -\dir)
			Else
				ddist=##[$851A](Angle(bez\k ASL 3,-bez\l ASL 3) ASR 10+32-\dir)
			EndIf

			\rot=(ddist-32) ASR 4

		EndIf

	EndIf



	If (\idle=-1) ;AND (\towed=0) ;strict!!!!!!!
		If lapdir=1
			myleng.w=*p\lap ASL 7 +*p\curdt
		Else
			myleng.w=*p\lap ASL 7 -*p\curdt
		EndIf
		tdist(*p\pos)\h=myleng

		If warpmode
			If (*p\control<(#contcomp))	;local player
				If (*p<>*newleader)

					If (spoon((spptr+1)&#spoon) >myleng) ;losing by 1 second
						If ((tdist(*newleader\pos)\h-1)>myleng) ;but not much
	;						If (*p\warp=0) Then *p\warp=1
	;						if snd
	;							chan(\channel)\reqsam=7:joy=-8
	;						EndIf

							*dp=*newleader

							*p\newwarps+1
							*p\qc=*dp\qc:*p\qs=*dp\qs
							*p\i=*dp\i+*p\qc*1.2
							*p\j=*dp\j+*p\qs*1.2
							*p\k=QHite(*p\i,*p\j,skbm)
							*p\headi=*dp\headi:*p\headj=*dp\headj:*p\headk=*dp\headk

							*p\rev=*dp\rev:*p\vel=*dp\vel
							*p\dir=*dp\dir:*p\rot=*dp\rot
							*p\curdt=*dp\curdt
							If *p\lap<>*dp\lap Then lapinc=*dp\lap-*p\lap:Gosub DrawLaps
							*p\coll=1
							*p\warp=0:*p\lasttime-#spoon
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf







	EndIf


	\vel=\headi*\qc+\headj*\qs

CEND
Return


.DrawLaps
	*p\lap+lapinc



	If (laps.w<*p\lap)
		\coll=1:\tottime=fps
		\idle=1:\rot=0
		tdist(\pos)\h=32000

;		If *p\control<#contcomp
			nureduce.w-1
			If nureduce.w<0 Then endrace.w=fps+200
;		EndIf


	EndIf

	If lapinc=1
;		If laps=*p\lap Then chan(*p\channel)\reqsam=4

		If startrace<0 Then startrace=fps
		quik.w=fps-*p\lasttime

		If quik>0
;			PrintCarCar quik,?tagbin,*p\q
			If quik<*p\bestlap Then *p\bestlap=quik

			If (*p\control<#contcomp)
;				dum.w=quik*0.002:thing.l=			 dum	ASL 8:quik-dum*500
;				dum.w=quik*0.02 :thing.l=(thing+dum) ASL 8:quik-dum*50
;				thing=(thing+10) ASL 8+Int(quik*0.2)
;				PutSpriteNums thing,*p\spr1,*p\spr2
				*p\disc=15:*p\oldpos=-1
;				PrintCarCar 0,?tagbin,*p\q
				##[$C48C] quik,?tagbin,*p\q,super
			EndIf
		Else

		EndIf
		*p\lasttime=fps

	Else
		*p\lasttime=10000
	EndIf



Return

CheckWallLatent
CNIF #race
	##[$80CA] *p
	For *p=Pl(0) To Pl(#uscar) Step SizeOf.car	; if in a collision, \movi=0=\movj

		*p\rev+*p\nrev

		a.q=##[$C385](*p\headi)
		b.q=##[$C385](*p\headj)
		If a>b Then dtp=a+a+a+b Else dtp=a+b+b+b
		dtp=##[$C386](dtp ASL *p\shv,0,*p\peak)

		##[$C497] *p\tune,dtp ;JAbs(*p\rev)	ASL 8;4


		Select \side
			Case 0:impact.w=Off
			Case 1:impact.w=(\i+\headi) >= \swai
			Case 2:impact.w=(\i+\headi) <= \swai
		End Select
		If NOT impact
			Select \top
				Case 3:impact.w=(\j+\headj) >= \swaj
				Case 4:impact.w=(\j+\headj) <= \swaj
			End Select
		EndIf
		If impact

			\i=\swai:\j=\swaj
			fac=(\headi*\difj-\headj*\difi);ASL 1 ; do the wild vel
			fac=fac+ fac ASR 1
			\headi-(fac*\difj)
			\headj+(fac*\difi)

			If (##[$C385](\headi)>0.03) OR (##[$C385](\headj)>0.03)	;so bounce ain't excessive..
				blah=RDistance(\headi ASL 7,\headj ASL 7) ASL 4	;was 3
				If blah<1
					\headi*blah:\headj*blah

				EndIf
;				\headi+0.5
;;		 Safe{}
			Else
				\headi= \difj ASR 5
				\headj=-\difi ASR 5
			EndIf

			blah=qsin(\swiv)	;do the wild spin after bounce..
			\dir=##[$851A](\dir-blah)
			\rot-blah ;ASL 1

			\side=0:\top=0:\swai=-1	;reset so ain't happen 'gin
			\swiv=0 ;:\rev ASR penalty
		EndIf

	Next
CEND

Return






.
.
.
.
.




CNIF #c=#j
	;********************** JAGOS SUBS ******************************

.jagos ;(thanx mark!)
	;
	;OK, well need some zero page locations...
	;
	#allocat=$200
	#stopat=$204
	#vbint=$208
	#gpint=$20c
	#obint=$210
	#tiint=$214
	#dsint=$218
	#_INT1=$21c

	#superstacksize=256
	#userstacksize=256


	copymem		 ;a0=src, a1=srcf, a2=dest
	;
	CMP.l a1,a0:BCC 'done:MOVE.l (a0)+,(a2)+:BRA copymem
	'done:RTS

	initjagos
	;
	CLR.l $ff0:CLR.l $ff8:
	MOVE.l #$200000,allocat:MOVE.l (a7),a0
	MOVE.l allocat,a7:SUB.l #superstacksize,allocat
	MOVE #$0,sr
	MOVE.l allocat,a7:SUB.l #userstacksize,allocat:MOVE.l a0,-(a7)
	;
	MOVE #$1f00,_INT1:LEA inthandler(pc),a0:MOVE.l a0,$100
	;
	MOVEQ #8,d0:BSR alloc:CLR.l (a0):MOVE.l #4,4(a0):MOVE.l a0,stopat
	MOVE.l a0,d0:SWAP d0:MOVE.l d0,$f00020:RTS


	alloc ;d0=size, return a0=mem
	MOVE.l 4,a6:MOVEQ #0,d1:JSR -204(a6):MOVE.l d0,a0:RTS

	vbinton:OR #1,_INT1:MOVE _INT1,$f000e0:RTS
	vbintoff:ANDI #$fffe,_INT1:MOVE _INT1,$f000e0:RTS

	inthandler
	;
	MOVEM.l d0-d7/a0-a6,-(a7)
	;
	MOVE $f000e0,d2:ANDI #$1f,d2:MOVE d2,d0
	LSL #8,d0:OR d2,d0:MOVE d0,$f000e0
	;
	LSR #1,d2:BCC 'novbint:MOVE.l vbint,a0:JSR (a0):'novbint
	LSR #1,d2:BCC 'nogpint:MOVE.l gpint,a0:JSR (a0):'nogpint
	LSR #1,d2:BCC 'noobint:MOVE.l obint,a0:JSR (a0):'noobint
	LSR #1,d2:BCC 'notiint:MOVE.l tiint,a0:JSR (a0):'notiint
	LSR #1,d2:BCC 'nodsint:MOVE.l dsint,a0:JSR (a0):'nodsint
	;
	MOVE d0,$f000e2
	;
	MOVEM.l (a7)+,d0-d7/a0-a6:RTE


	initvbint	;d0=scanline, a0=address of code
	MOVE d0,$f0004e:MOVE.l a0,vbint

	If a=a
		MOVE.l a5,global
		MOVE.l a3,local
	EndIf
	RTS



	vbdb	;vertical blank double buffer...
		MOVEM.l d0/d2,-(a7)
		MOVE.l global,a5
		MOVE.l local,a4

		ADDQ #1,framecnt

		RefrBmap{*bmr2.jbmap}
		HeadBmap{*bmr2}

	;	HeadBmap{Peek.l($204)-32}

		MOVEM.l (a7)+,d0/d2
	RTS



global :Dc.l 0
local	:Dc.l 0
CEND



CNIF 1=0

.printd2
;
;RTS
;
;print d2 at d0,d1
;
MOVEM.l d2-d4/a2,-(a7)
;
MOVE.l bmap1,a0							;where it goes
MULU #320,d1:ADD.l d1,a0:LSL #2,d0:AND #$fff0,d0:ADD d0,a0
MOVE.l d2,d0
;
MOVEQ #7,d4
'loop
ROL.l #4,d0:MOVE d0,d2:AND #15,d2
LEA digs(pc),a1:LSL #4,d2:ADD d2,a1						 ;start of digit
MOVEQ #7,d3:MOVE.l a0,a2
'loop2
MOVE.l (a1),(a2):MOVE.l 4(a1),4(a2)
MOVE.l 8(a1),16(a2):MOVE.l 12(a1),20(a2)
;
LEA 576(a1),a1:LEA 1280(a2),a2
DBF d3,'loop2
LEA 32(a0),a0:DBF d4,'loop
;
MOVEM.l (a7)+,d2-d4/a2:RTS

Event
CEND



	Event

CNIF #c=#j
	gpu_1
	IncBin "gpu"
	gpu_1f

	dsp_1
	IncBin "dsp"
	dsp_1f
CEND


	sincos:		IncBin "sincos.bin"
;	shadowdat: IncBin "shadow.dat"
	sqludat:	 IncBin "sql.inc"

CNIF #c<>#s
	mytrack:	 IncBin "maps:f5.nmp"
CEND


CNIF #c=#s

	CNIF #race
		flags:IncBin "flags.bin"

	CEND


	blank:Dcb.w 64,$80
	carpalette: IncBin "car.palette"
	segpalette: IncBin "sega.palette"

strip:
	Dcb.l 32,$89aba981
	Dcb.l 32,$1cdefedc





	CNIF #frontend OR #title
		font:
			Dc.l 0,0,0,0,0,0,0,0
			Dc.l 0,0,0,0,0,0,0,0
			IncBin "font.bin"
		fontf:

		fence:
			IncBin "rails.bin"
		fencef

		miniat:IncBin "cars.bin"
					 IncBin "rainbow.bin"
		miniatf

		seldat:IncBin"select.bin"
		seldatf
;		selmap:IncBin"select.map"



		fsize:IncBin "size.bin"

		checkers:IncBin "checkers.bin"


	CEND



CEND










.InitOs
	CNIF #c=#j
;		BSR initjagos
		MOVE.l #$00a600a6,$f00038:MOVE #$656,$f0003c
		;MOVE #ypos,$f00046:MOVE #ypos+hite+hite,$f00048
		MOVE #$2e,$f00046
		;MOVE #$2e+240+240,$f00048
		MOVE #$2e+199+199,$f00048

		bld.l=$f02200
		!waitgpu
		!waitdsp

		Poke.l $f1a100,(Peek.l($f1a100)&$f) OR (1 ASL 14)
		BlCopyMem{?gpu_1,$f03000,?gpu_1f-?gpu_1}
		BlCopyMem{?dsp_1,$f1b000,?dsp_1f-?dsp_1}

	CEND
	CNIF #c=#s


;		!setreg{2,0}		 ;map location=0*8192
;		!setreg{4,0}		 ;map location=0*8192
;		!setreg{5,$78}	 ;sprites location=$f000
;		!setreg{11,0}		;scroll=entire screen + no external interupts (8)
;		!setreg{12,$81}	;32 cell mode no shadows no interlace
;
;		!setreg{13,$3f}	;hs=$fc00
;		!setreg{16,1+48} ;64x64 sized map
;		!setreg{3,$38}	 ;windowpos= $e000
;		!setreg{17,$0};$8a}
;		!setreg{18,$0};$ff}
;		!setreg{7,0}

		!setreg{0,4}
		!setreg{1,$74}
		!setreg{6,0}
		!setreg{7,0}
		!setreg{8,0}
		!setreg{9,0}
		!setreg{10,0}
		!setreg{14,0}
		!setreg{15,2}


	CEND

Return




;	nmp.l						;8k+ contours NOT CRUNCHED
;	blockmap.l			 ;8k crunched
;	blocks.l[8]			;40k+ crunched

.InitVars

	;warpmode.w=On

	mytrk.w=2
	skill.w=3
CNIF #frontend
	menu.w=#main
CEND

	myfontdat.l=?font
	screenmode=0
	mytau=6

	scry=4
	laps.w=4
	CNIF #c=#s
		segjoy.w=##[$C48E]
		If segjoy<0
			numseg.w=1-segjoy
		Else
			numseg=segjoy-1
		EndIf
		If numseg>0
			cnt.w=##[$C484](0)
			cnt.w=##[$C484](1)
		EndIf
	CEND

Return



;NEWTYPE .segasp					 ;sort points here
;	dpth.w:car.w						;car=0 for car or numsprites for bridge
;	binfo.l[0]							;ptr to bridge info in rom
;	shady.w:rshady						;
;	sx.q:sy.q:spdata.w			;bridge
;End NEWTYPE







Macro ssp SizeOf.segasp\`1(a1):End Macro

Statement findsprites{myinfo.l,splist.l,cptr.l,mydata.l}
	;
	MOVEM.l a4-a6,-(a7)
	MOVE.l d0,a0:MOVE.l d1,a1:MOVE.l d2,a4:MOVE.l d3,a5
donother
	MOVE (a0)+,d2:BMI dun:MOVE (a0)+,d3		 ;d2-d3=n block
nxpart:
	MOVE (a0)+,!ssp{sx}:MOVE (a0)+,!ssp{sy}:MOVE d3,!ssp{spdata}
	MOVE #3000,!ssp{dpth}
	;
	MOVE (a0),d4:AND#$f00,d4:OR#5,d4:MOVE d4,!ssp{l}:ADD 2(a0),d3
	;
	MOVE.b(a0),d4:ADDQ#4,a0:MOVE d4,d5:AND #12,d4 ;d4=w d5=h+1
	LEA 0(a5,d4),a6:MOVE.l a6,!ssp{wptr}
	AND#3,d5:ADDQ#1,d5:MOVE d5,d4
	MOVE d4,!ssp{h0}:ADD d5,d4
	MOVE d4,!ssp{h1}:ADD d5,d4
	MOVE d4,!ssp{h2}:ADD d5,d4
	MOVE d4,!ssp{h3}
	;
	MOVE.l a1,(a4)+:ADD #SizeOf.segasp,a1:SUBQ#1,d2:BNE nxpart:BRA donother
	;
dun:
	MOVE.l #0,(a4):MOVEM.l (a7)+,a4-a6:AsmExit
	;
End Statement

Statement findsprites2{myinfo.l,splist.l,cptr.l,mydata.l}
	;
	MOVEM.l a4-a6,-(a7)
	MOVE.l d0,a0:MOVE.l d1,a1:MOVE.l d2,a4:MOVE.l d3,a5
donother2:
	MOVE (a0)+,d2:BMI dun2:MOVE (a0)+,d3:BCHG#11,d3		 ;d2-d3=n block
nxpart2:
	;
	MOVE #768,d4:SUB (a0)+,d4:MOVE d4,!ssp{sx}
	MOVE (a0)+,!ssp{sy}:MOVE d3,!ssp{spdata}:MOVE #3000,!ssp{dpth}
	;
	MOVE (a0),d4:AND#$f00,d4:OR#5,d4:MOVE d4,!ssp{l}:ADD 2(a0),d3
	;
	AND#$c00,d4:ADD#$400,d4:LSR#7,d4:SUB d4,!ssp{sx}
	;
	MOVE.b(a0),d4:ADDQ#4,a0:MOVE d4,d5:AND #12,d4 ;d4=w d5=h+1
	LEA 0(a5,d4),a6:MOVE.l a6,!ssp{wptr}
	AND#3,d5:ADDQ#1,d5:MOVE d5,d4
	MOVE d4,!ssp{h0}:ADD d5,d4
	MOVE d4,!ssp{h1}:ADD d5,d4
	MOVE d4,!ssp{h2}:ADD d5,d4
	MOVE d4,!ssp{h3}
	;
	MOVE.l a1,(a4)+:ADD #SizeOf.segasp,a1:SUBQ#1,d2:BNE nxpart2:BRA donother2
	;
dun2:
	MOVE.l #0,(a4):MOVEM.l (a7)+,a4-a6:AsmExit
	;
End Statement





.GetNewTrack
	CNIF #c=#s
		*ath.theader=tkptr + SizeOf.theader*mytrk.w
		maptr.l=*ath\nmp+tkbin
		myinfo.l=*ath\info+tkbin

		For cnt.w=0 To #uscar
			cptr(cnt)=&spr(cnt)
			cptr(#uscar+1+cnt)=&spr(#uscar+1+cnt)
		Next
		cnt.w=#uscar+#uscar+1+1

		flags.l=Peek.w(myinfo) ASL 5
		If super
			findsprites2{myinfo+2,&spr(cnt),&cptr(cnt),?mytable}
		Else
			findsprites{myinfo+2,&spr(cnt),&cptr(cnt),?mytable}
		EndIf

	CELSE

		maptr.l=?mytrack
	CEND

	condt.l=maptr+64*64*2 + 2
	pts.w=Peek.w(maptr+64*64*2):pts1.w=pts+1:pts2.w=pts+2:pts3=pts+3:pts4=pts+4

	SetMaptr maptr.l+2,skbm
	SetConDt condt.l,skbm
	SetIO &bez.ij,skbm
	Gosub PreProcess

Return




.DoPal
	CNIF #c=#j
			palbase.l=$f00400
			For tr.w=0 To 255
				mycol=tr ASL 1

				blah.q=(##[$8481](15*tr+2.3,tr)+1)*127:mr=blah
				blah.q=(##[$8481](tr,tr*7+3242)+1)*127:mg=blah
				blah.q=(##[$8481](tr*31+32.6,tr*9+324)+1)*127:mb=blah

				temp.l=(jint{mr ASR 3} ASL 5 + jint{mb ASR 3}) ASL 6+ jint{mg ASR 2}
		;		temp.l=$ffff;3333
				Poke.w palbase+mycol,temp
			Next
	CEND

	CNIF #c=#s
		If inrace
			base.l=&charb(0)+32;#wcram+32
;			MyCopy{ blockmap	 ,#wcram+96,16	}
;			MyCopy{ blockmap+32,#wcram	 ,16 }
			MyCopy{ blockmap	 ,&charb(0)+96,16	}
			MyCopy{ blockmap+32,&charb(0)	 ,16 }

			MyCopy{ ?carpalette,base,8																	 }
			MyCopy{ ?carpalette,base+32,8																}

			MyCopy{ ?carpalette+16+newp(Pl(0)\newp)\col ASL 3,base+16,4 }
			MyCopy{ ?carpalette+16+newp(Pl(2)\newp)\col ASL 3,base+24,4 }

			MyCopy{ ?carpalette+16+newp(Pl(1)\newp)\col ASL 3,base+48,4 }
			MyCopy{ ?carpalette+16+newp(Pl(3)\newp)\col ASL 3,base+56,4 }

		Else
			base.l=#wcram
			##[$C482] ?segpalette,base+96,16
			##[$C482] ?carpalette,base+64,8 ;cheap...
			##[$C482] ?carpalette+4,base+80,4
			##[$C482] ?carpalette+8,base+88,4


			##[$C482] ?carpalette,base,8
			##[$C482] ?carpalette,base+32	,8

			##[$C482] ?carpalette+16+newp(0)\col ASL 3,base+16,4
			##[$C482] ?carpalette+16+newp(1)\col ASL 3,base+24,4

			##[$C482] ?carpalette+16+newp(2)\col ASL 3,base+48,4
			##[$C482] ?carpalette+16+newp(3)\col ASL 3,base+56,4


		EndIf



	CEND
Return


##[$80CA] *p
.HandleHeader
		If \idle=1
			\disc-1
			If \disc=0
				quik=\bestlap
				If quik>0 Then ##[$C48C] quik,?tagbin,\q,super:\disc=32000:\oldpos=-1
			EndIf
		EndIf

		If \idle=-1 ;racing
			\disc-1
			If \disc=0
				If *p\oldpos=-2
;					tt$="			 "
;					PutSpriteMess tt$,*p\spr1,*p\spr2
					##[$C48C] 0,?tagbin,*p\q,super
					*p\oldpos=9
				EndIf
				If *p\oldpos=-1
					*p\oldpos=9

					##[$C48C] -1-*p\pos,?tagbin,*p\q,super
					*p\disc=3

				Else
;					PutSpriteNums 0,*p\spr1,*p\spr2
					##[$C48C] 0,?tagbin,*p\q,super
				EndIf
			EndIf
		EndIf


;		If (*p\oldpos>-1)
;			If (*p\pos<> *p\oldpos) OR (*p\disc<-1000)
;				*p\oldpos=*p\pos
;				*p\disc=2
;;				PutSpriteNums *p\pos+1,*p\spr1,*p\spr2
;				PrintCarCar -1-*p\pos,?tagbin,*p\q
;			EndIf
;		EndIf

Return






##[$80CA] *p
.SetStartCar
	\idle=0:\drop=Off:\inair=On
	\coll=-1:\warp=0:\lap=0:\jox=0
	\pitch=2:\roll=2:\mpitch=0:\mroll=0:\rot=0:\movi=0:\movj=0
	\headi=0:\headj=0:\headk=0:\rev=0:\nrev=0:\vel=0:\traction=0

	\swaheadi=0:\swaheadj=0:\swamovi=0:\swamovj=0
	\side=0:\top=0:\swai=0:\swaj=0:\difi=1:\difj=0:\swiv=0
	\bestlap=32000:\lasttime=10000:\tottime=-1
	\upd=3
Return


.PlaceNorm
CNIF #race
	dtp.q=pts3+0.5:If lapdir=-1 Then dtp=2.5
	signmovst=dtp

	FindLo dtp,skbm:dti =(bez\i+bez\k)ASR 1:dtj =(bez\j+bez\l)ASR 1:dtp-(0.1*lapdir)
	FindLo dtp,skbm:dpri=(bez\i+bez\k)ASR 1:dprj=(bez\j+bez\l)ASR 1

	dj=(dtj-dprj) :di=(dti-dpri):width=1.2
	qnorm.q=0.1/jsqr{di*di+dj*dj}

	signmov=2.5:If trailer Then signmov=4.5

	di*10*qnorm*1.25:dj*10*qnorm*1.25
	tdir=##[$851A](Angle(dj ASL 6,di ASL 6) ASR 10+32)




	mycnt.w=0
	For *p=Pl(0) To Pl(#maxcar) Step SizeOf.car
		*p\i=dti+dj*width*((mycnt&1)-0.5)*2 - 2*di*width*mycnt;dback
		*p\j=dtj-di*width*((mycnt&1)-0.5)*2 - 2*dj*width*mycnt;dback
 ;	 *p\k=QHite(*p\i,*p\j,skbm)+10

		*p\dir=tdir:*p\qc=qcos(tdir):*p\qs=qsin(tdir)
		*p\curdt=dtp
		mycnt+1
	Next

CEND
Return


Statement CopGrot{src.w,dest.w}
Shared grot(),edge()
	*gs.xtra		 =grot(src):*gd.xtra		 =grot(dest)
	*es.quadratic=edge(src):*ed.quadratic=edge(dest)

	For i=0 To SizeOf.quadratic:Poke.b *ed+i,Peek.b (*es+i):Next
	For i=0 To SizeOf.xtra		 :Poke.b *gd+i,Peek.b (*gs+i):Next

End Statement



PreProcess
CNIF #race

	oldi=100:oldj=100
	For dt=0 To pts3

		*g=grot(dt):*e=edge(dt)

		FindLo dt+0	,skbm:A1=bez\i:A2=bez\j:bA1=bez\k:bA2=bez\l
		FindLo dt+0.5,skbm:B1=bez\i:B2=bez\j:bB1=bez\k:bB2=bez\l
		FindLo dt+1	,skbm:C1=bez\i:C2=bez\j:bC1=bez\k:bC2=bez\l


		*g\swivi=A1-bA1:*g\swivj=A2-bA2

;		*g\desti=(A1+	 C1+bA1+		bC1)ASR 2
;		*g\destj=(A2+	 C2+bA2+		bC2)ASR 2
;		*g\desti=(A1+B1+C1+bA1+bB1+bC1)/6
;		*g\destj=(A2+B2+C2+bA2+bB2+bC2)/6
;		*g\desti=(B1+bB1)ASR 1
;		*g\destj=(B2+bB2)ASR 1
		*g\desti=(B1+bB1) ASR 1 +(C1-B1+bC1-bB1)+(A1-B1+bA1-bB1)
		*g\destj=(B2+bB2) ASR 1 +(C2-B2+bC2-bB2)+(A2-B2+bA2-bB2)

		cai=A1:caj=A2
		cbi=C1:cbj=C2	;keep em in - why not?
		*g\midi=B1	:*g\midj=B2
		*g\cai=A1	 :*g\caj=A2
		*g\dai=A1-C1:*g\daj=A2-C2

		ni	=A1-C1:nj	=A2-C2:pdist=jsqr{ni	*ni	+nj	*nj	}:ni	/pdist:nj	/pdist
		difi=A1-B1:difj=A2-B2:pdist=jsqr{difi*difi+difj*difj}:difi/pdist:difj/pdist
		fac=(ni*difj-nj*difi)
		If ##[$C385](fac)<0.13
			*e\lstraight=On
		Else
			*e\lstraight=Off
			*e\lodd1=(fac<0)
			*e\lodd3=(fac>0)
		EndIf


		plussage.w=0:Gosub DoQuadratic

		*e+#hquad
		A1=bA1:A2=bA2:B1=bB1:B2=bB2:C1=bC1:C2=bC2

		*g\cbi=A1	 :*g\cbj=A2
		*g\dbi=A1-C1:*g\dbj=A2-C2

		dai =A1-cai:daj =A2-caj
		dbi =C1-cbi:dbj =C2-cbj		;ya never know.. might come in handy!
		*g\diri=B1-*g\midi:*g\dirj=B2-*g\midj

		mu=(cbj*dai-caj*dai+cai*daj-cbi*daj)/(dbi*daj-dbj*dai)

		ni	=A1-C1:nj	=A2-C2:pdist=jsqr{ni	*ni	+nj	*nj	}:ni	/pdist:nj	/pdist
		difi=A1-B1:difj=A2-B2:pdist=jsqr{difi*difi+difj*difj}:difi/pdist:difj/pdist
		fac=ni*difj-nj*difi
		If ##[$C385](fac)<0.13
			*e\lstraight=On
		Else
			*e\lstraight=Off
			*e\lodd1=(fac>0)
			*e\lodd3=(fac>0)
		EndIf
		plussage.w=32:Gosub DoQuadratic
	Next



	CopGrot{pts1,0}
	For src=1 To 7:CopGrot{src,src+pts1}:Next

	nxmass.w=0:stp=0.25:dtp=2:FindLo dtp,skbm:Gosub getnew:oi=ni:oj=nj

	While dtp<(pts+3)
		dist=0:stpmax=80:stpmin=0
		While (dist<3.8) OR (dist>4.2)
			ndt=dtp+stp:FindLo ndt,skbm:Gosub getnew
			dist=(oi-ni)*(oi-ni)+(oj-nj)*(oj-nj)
			If dist<4
				stpmin=stp
				If stpmax=80 Then stp+0.1: Else stp=(stpmax+stpmin) ASR 1
			Else
				stpmax=stp
				If stpmin=0 Then stp=##[$C386](stp-0.1,0,80):Else stp=(stpmax+stpmin) ASR 1
			EndIf
		Wend
		dtp=ndt:oi=ni:oj=nj

		difi=bez\k-bez\i:difj=bez\l-bez\j:proj.q=1/jsqr{difi*difi+difj*difj}:difi*proj:difj*proj

		li=bez\i+difi:lj=bez\j+difj
		ri=bez\k-difi:rj=bez\l-difj
		mass(nxmass)\mi=ni,nj
		mass(nxmass)\di=difi,difj
		mass(nxmass)\li=li,lj
		mass(nxmass)\ri=ri,rj
		mass(nxmass)\dtp=ndt:nxmass+1
;		Circle MapX(ni,nj),MapY(ni,nj),3,14
;		Line MapX(ni+difi,nj+difj),MapY(ni+difi,nj+difj),MapX(ni,nj),MapY(ni,nj),14
;		Circle MapX(li,lj),MapY(li,lj),3,14
;		Circle MapX(ri,rj),MapY(ri,rj),3,14

	Wend


	mess.w=0
	For dtp=2 To pts2

		mess=##[$C384](mess-20,0,nxmass)
		dif=mass(mess)\dtp-dtp
		If dif>5 Then dif-pts1
		While dif<0
			mess=##[$C384](mess+1,0,nxmass)
			dif=mass(mess)\dtp-dtp
			If dif>5 Then dif-pts1
		Wend
		firstmass(dtp)=##[$C384](mess-1,0,nxmass)

	Next
	If maxmess<nxmass Then maxmess=nxmass

	massbase.l=&mass(0)
	massbig.l=&mass(nxmass)


CEND
Return

CNIF #race

.getnew
	ni=(bez\i+bez\k) ASR 1
	nj=(bez\j+bez\l) ASR 1
Return


DoQuadratic
	If *e\lstraight	;one straight.. comin right up!
		difi=(C1-A1)	:difj=(C2-A2)
		pdist=jsqr{difi*difi+difj*difj}
		difi/pdist:difj/pdist:*e\lb=difi:*e\le=difj

		*e\lc=(A1+C1)ASR 1:*e\lf=(A2+C2)ASR 1
		b1=(A1-*e\lc)*difi+(A2-*e\lf)*difj
		b2=(C1-*e\lc)*difi+(C2-*e\lf)*difj
;		If b2<b1 Then Exchange b1,b2
		mid=(b1+b2) ASR 1:dif=##[$C385](b1-b2)*0.52
		b1=mid-dif:b2=mid+dif
		*e\lb1=b1:*e\lb2=b2

		*e\langst=##[$851A](Angle(difj ASL 6,difi ASL 6) ASR 10+32)
		*e\langadd=0
;		Circle MapX(*e\lc,*e\lf),MapY(*e\lc,*e\lf),5,8


	Else
		pc=A1:B1-pc:B1*2:C1-pc:pa=(C1-B1)*2:pb=C1-pa
		pf=A2:B2-pf:B2*2:C2-pf:pd=(C2-B2)*2:pe=C2-pd

		t=-0.5*(pa*pb+pd*pe)/(pa*pa+pd*pd)

		ob=2*t*pa+pb:oc=t*t*pa+t*pb+pc
		oe=2*t*pd+pe:of=t*t*pd+t*pe+pf
		pdist=jsqr{ob*ob+oe*oe}
		ob/pdist:oe/pdist
		od=-ob	:oa=oe	; to be modified along this line..

		t+1
		tc=t*t*pa+t*pb+pc-oc
		tf=t*t*pd+t*pe+pf-of

		dt1=tc*ob+tf*oe	 ;now, dot2*dot2=dot1...
		dt2=tc*oa+tf*od
		fac=(dt1*dt1/dt2)
		ma=oa/fac:md=od/fac
		oa*fac:od*fac

		*e\la=oa:*e\ld=od
		*e\ma=ma:*e\md=md
		*e\lb=ob:*e\le=oe
		*e\lc=oc:*e\lf=of

		t=0:tc=t*t*pa+t*pb+pc-oc
				tf=t*t*pd+t*pe+pf-of
				b1=tc*ob+tf*oe
		t=1:tc=t*t*pa+t*pb+pc-oc
				tf=t*t*pd+t*pe+pf-of
				b2=tc*ob+tf*oe
		dif=##[$C385](b1-b2)*0.52:mid=(b1+b2) ASR 1
		b1=mid-dif:b2=mid+dif
		*e\lb1=b1:*e\lb2=b2

		t=b1
		difi=2*t*ma+ob		 ;strictly optional..
		difj=2*t*md+oe		 ;differientiate it
		fang=(Angle(difj ASL 6,difi ASL 6) ASR 10+32)

		t=b2
		difi=2*t*ma+ob		 ;strictly optional..
		difj=2*t*md+oe		 ;differientiate it
		stang =(Angle(difj ASL 6,difi ASL 6) ASR 10+32)

		dang.q=(stang-fang)
		If dang<-32 Then dang+64
		If dang>32 Then dang-64	;take the smaller..

		dang/(b2-b1)

		*e\langst=fang-(b1*dang)
		*e\langadd=dang ASR 4


	EndIf
Return



.DoSignStart
	dtp=pts3+0.5:If lapdir=-1 Then dtp=2.5
	FindLo dtp,skbm
;	difi =(MapX(bez\i,bez\j)-signx) ASR 4:difj =(MapY(bez\i,bez\j,skbm)-signy) ASR 4
;	desti=(MapX(bez\k,bez\l)-signx) ASR 4:destj=(MapY(bez\k,bez\l,skbm)-signy) ASR 4
;	signside.w=(difi*difi+difj*difj) < (desti*desti+destj*destj)

	signside=(lapdir>0)

	FindDif 2.6,skbm
	If signside
		difi=1.4/jsqr{bez\i*bez\i+bez\j*bez\j}
	Else
		difi=1.4/jsqr{bez\k*bez\k+bez\l*bez\l}
	EndIf
	signmov=-difi*0.1*lapdir
;	signmov=0.5
	signmovst.q=pts3+0.5:If lapdir=-1 Then signmovst=2.5
Return


CEND



##[$80D3]
	champs
	mini:Dc.w	-8, 15, 20,-13,-10,-24
	pors:Dc.w	 7, -5,	4,	3,-18, -9
	midg:Dc.w -20, 18, -7, -4, 10, 13
	beet:Dc.w	 2,-14,-21,	1, -6,-17
	truk:Dc.w	 8, 23, 24, 22,-11,-12
	musc:Dc.w -16,-22, 19,	5,	9, 11
	ccow:Dc.w	12, -3, -1, -2,	6,-23
	f1f1:Dc.w	16, 21, 17, 14,-15,-19

champcars
	Dc.w	0,1,7,2,4,3,6,5

;	Dc.w -10,-13, 20, 16, 22, -8
;	Dc.w	 4,	7,-18,	3, -5, -9
;	Dc.w	-4, -7, 10, 13, 18,-20
;	Dc.w	 2, -6,-14,	1,-11,-17
;	Dc.w -12, 23, 15,	8,-21, 24
;	Dc.w	-3,	5,	9, 11,-16,-22
;	Dc.w	-2,	6, 12,-23, 19, -1
;	Dc.w	14, 17,-15, 21,-19,-24


tagbin:IncBin "tags.bin"



CNIF #title
	cmdat		:IncBin "cm.bin"
;	titleadat:IncBin "titlea.bin"
;	titlebdat:IncBin "titleb.bin"
;	squigdat :IncBin "squig.bin"
	clouddat :IncBin "background.bin"
	billdat	:IncBin "billboard.bin"
	billdatf
CEND



.LostCode

CNIF 1=0
		If (((Peek.w($c00008)LSR 8)&255)>160); OR (Peek.w($ff0000)=-1)
			!MyVWait
			##[$C482] &myvram1(0),$fc00,320

			If (screenmode&1)=0
;				SegaMap mptl,0,41,blkh
				!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
				!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical

;				If screenmode=2
;					SegaMap mptla,16*64*2					,41,blkh
;				EndIf

			Else
;				SegaMap mptl,0				,21,blkh
;				SegaMap mptr,(64-22)*2,21,blkh
				!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
				!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical
				!pokemem{#wvram+$10020000,-(vp(2)\sx AND 7)+(64-21)*8} ;horizontal
				!pokemem{#wsram+$00020000, (vp(2)\sy AND 7)}					 ;vertical

;				If screenmode=3
;					SegaMap mptla,16*64*2					,21,blkh
;					SegaMap mptra,16*64*2+(64-22)*2,21,blkh
;				EndIf
			EndIf


;			Repeat
;				cnt.w=(Peek.w($c00008)LSR 8)&255
;			Until cnt>125


		EndIf
CEND

CNIF 1=0
		MOVE #$8709,$c00004
		##[$80BB]

			cnt.w=(Peek.w($c00008)LSR 8)&255
		##[$80BC] cnt>174
		MOVE #$8703,$c00004
;		wwb:CMP.w #$7700,$c00008:BCS wwb
CEND




	CNIF 1=0


		jj=0
		If butt&1 Then jj+1
		If butt&2 Then jj-1
		myangvel=(myangvel+jj) *0.98
		myang=myang+myangvel ASR 4
		If myang<0 Then myang+1024
		If myang>=1024 Then myang-1024


		ad.l=?sincos+((myang&1023) ASL 2)
		f=jfrac{myang}:of=1-f



		qs=Peek.w(ad	)*of+Peek.w(ad+4)*f
		qc=Peek.w(ad+2)*of+Peek.w(ad+6)*f

		qqs=jext{qs}
		qqc=jext{qc}


		xvel=(xvel+jox) *0.95
		yvel=(yvel+joy) *0.95

		xdif=xvel*qqc + yvel*qqs
		ydif=xvel*-qqs + yvel*qqc
		deadx=jlimit{deadx+xdif ASR 3 ,1,63-#sqs}
		deady=jlimit{deady+ydif ASR 3 ,1,63-#sqs}

		delta.l=jint{deadx} +jint{deady}ASL 6
	CEND

	CNIF #c=#j
		LEA vbdb(pc),a0:MOVEQ #1,d0:BSR initvbint:BSR vbinton
	CEND






	CNIF 1=0
		Use On

		SUB Init
		peat
		VWait:DisplayBitMap 0,db:db=1-db:Use lmaxlen db:BlockScroll
		BitMapOutput db
		 sx3=MouseX:sy3=MouseY
		Gosub Make
		Gosub Rot
		Gosub Draw

	 ##[$80BC] Joyb(0)<>0
	End
	CEND


	CNIF 1=0
;		If (jcos{0}<0.9) OR (jcos{0}>1.1)
			For i.w=0 To 320
				hgh=i/320
				BlLin{*bmr,i,128,i,jcos{hgh}*64+128,$ffffffff}
			Next
;		EndIf
	CEND







Return



CNIF 1=0
			base.l=Peek.l(?racename+champ ASL 2)
			If champ=2
				roll.w=3 ;snow..
			Else
				roll.w=4
			EndIf


			segaprint{base,roll,6,7,8};
			segaprint{?racedat,3,10+roll+roll,7,8};

			cnt.w=racenum+49
			segaprint{&cnt+1,0,15,10,8};



			##[$C482] &map(0,0),#wvram,4096;2048


			##[$C482] ?carpalette,#wcram+ 64,8
			##[$C482] ?carpalette,#wcram+ 96,8

			fadeincol.w=0
			count=0:nxlink.w=0:fps.w=0
			For pl=0 To 5
				titcol=pl
				For cnt.w=0 To 2
					charb(nxlink	)\id=cnt+pl ASL 4
					charb(nxlink+1)\id=cnt+pl ASL 4:nxlink+2
				Next
				Gosub makeoldcar

				;assume nxlink+6.. yeah, i know	hard space(?)
			Next



			titcol=0:fadeincol=0:done.w=2
			##[$80BB]
				If fadeincol<10000 Then fadeincol.w+1
				!MyVWait
				displaychars{$f000}

;					If titcol>15
;						titcol-12
;
;						If titcol=4 Then SegaDMA ?carpalette+16+newp(titcol)\col ASL 3,#wcram+ 80,4
;						If titcol=5 Then SegaDMA ?carpalette+16+newp(titcol)\col ASL 3,#wcram+ 88,4
;						titcol-3
;					EndIf
;
				item=0
				For pl=0 To 5
					If fadeincol<30
						myx=newp(pl)\ed-10
					Else
						myx=newp(pl)\ed
					EndIf


					newp(pl)\ed=myx
					myx=##[$C386](##[$C381](myx),128-48-96,128+320+8)
					If myx<128-48-8
						chara(item	 )\y=0
						chara(item+ 1)\y=0
						chara(item+ 2)\y=0
						chara(item+ 3)\y=0
						chara(item+ 4)\y=0
						chara(item+ 5)\y=0
						chara(item+ 6)\y=0
					EndIf

					If myx=128-48-96
						If titcol=pl Then titcol+16

						chara(item+ 7)\y=0
						chara(item+ 8)\y=0
						chara(item+ 9)\y=0
						chara(item+10)\y=0
						chara(item+11)\y=0:item+12
					Else
						delx=(myx-288) ASR 7



;							chara(item+8 )\y=128+80
;							chara(item+9 )\y=128+80
;							chara(item+10)\y=128+80
;							chara(item+11)\y=128+80

						mbx=myx+24
						chara(item+ 6)\x=mbx+charb(item+ 6)\dx
						chara(item+ 7)\x=mbx+charb(item+ 7)\dx
						chara(item+ 8)\x=mbx+charb(item+ 8)\dx
						chara(item+ 9)\x=mbx+charb(item+ 9)\dx
						chara(item+10)\x=mbx+charb(item+10)\dx
						chara(item+11)\x=mbx+charb(item+11)\dx


						mbx=myx+32
						chara(item	)\x=myx:myx-delx
						chara(item+1)\x=mbx:mbx-delx
						chara(item+2)\x=myx:myx-delx
						chara(item+3)\x=mbx:mbx-delx
						chara(item+4)\x=myx
						chara(item+5)\x=mbx

						item+12
					EndIf
				Next

				If done=2
					If (##[$C484](trx{0})&$f0)=0 Then done=1
				Else
					If (##[$C484](trx{0})&$f0) Then done=0
				EndIf

			##[$80BC] done=0


;		CELSE
;			menu.w=#raceit:Gosub redr
;		CEND

CEND


;			Wend
CNIF 1=0
				If (Peek.w($c00008)LSR 8)&255<#skipval
					##[$C48B] 0,*p2\fr,*p2\q,1	 ,*p2\carnum
					*p=*p2:Gosub DrawShadow
					CNIF #uscar>3
						If (Peek.w($c00008)LSR 8)&255<#skipval
							##[$C48B] 0,*p4\fr,*p4\q,2	 ,*p4\carnum
							*p=*p4:Gosub DrawShadow
						EndIf
					CEND
				EndIf
			EndIf

		Else
			##[$C48B] 0,*p1\fr,*p1\q,0	 ,*p1\carnum
			##[$C48B] 0,*p3\fr,*p3\q,1	 ,*p3\carnum
			CNIF #uscar>4
				##[$C48B] 0,*p5\fr,*p5\q,3	 ,*p5\carnum
			CEND

		EndIf
CEND

CNIF 1=0

Statement shit{src.l,dest.l,x.w,adder.w}
	MOVE.l d0,a0:MOVE.l d1,a1:MOVE d2,d0:ADD d0,d0:MOVE d0,d1:MOVE d3,d4
	LEA 0(a1,d1),a2:MOVEQ#29,d7
	nxb:MOVE#$180,(a2):ADD#128,a2:DBRA d7,nxb:ADDQ#2,d1
nxtxx:
	CMP #80,d1:BPL dundun:TST d0:BMI dundun
	LEA 0(a0,d0),a2:LEA 0(a1,d1),a3:MOVEQ#29,d7
	more:MOVE (a2),d3:ADD d4,d3:MOVE d3,(a3):ADD #80,a2:ADD#128,a3
	DBRA d7,more:SUBQ#2,d0:ADDQ#2,d1:BRA nxtxx
dundun:
	AsmExit
End Statement



		*p=&map(0,0)

		*batman.batman=?titleadat
		*robin.batman=?titlebdat

		base.l=&*batman\mmap
		For j=0 To 29
			For i=0 To 39
				If (i>10) AND (i<20)
				Else
					Poke.w *p,Peek.w(base)+$8300:*p+2
				EndIf
				base+2
			Next
		Next

		*p=&map(0,30)


		For roll.w=0 To 39 ;Step 1 ASR 4

			shit{&*batman\mmap,&map(0,0),roll,$8b00}
			shit{&*robin\mmap,&map(0,32),roll,$a980}
;			For y=0 To 29
;				map(roll,y)=$180
;			Next
;			base.l=*p +roll*2
;			For x=roll+1 To JLimit(roll+roll,0,39)
;				temp.l=base
;				For y=0 To 29
;					map(x,y)=Peek.w(temp)+$800:temp+80
;				Next
;				base-2
;			Next

			!MyVWait
			##[$C482] &map(0,0),#wvram,4096;2048

		Next
CEND


CNIF 1=0
	.makeoldcar
		newp(pl)\ed=128+320-6+pl*80;200
		newp(pl)\moved=128+8+pl*46

		If titcol&1
			blah.q=107 ASR 2
		Else
			blah.q= 85 ASR 2
		EndIf

		pitch.w=titcol+2

		For cnt=0 To 2
			addmini{cnt+pl ASL 4,-10,blah-cnt ASR 3,newp(titcol)\car,pitch}
		Next



;		addstring{pl ASL 4 +4,&newp(pl)\nam1,5,7};pitch}
;		positionstring{pl ASL 4+4,-20,blah-2};14 ASR 3}
;		For cnt=1 To 6
;			chara(nxlink-cnt)\x=charb(nxlink-cnt)\fx
;			chara(nxlink-cnt)\y=charb(nxlink-cnt)\fy
;		Next

	Return


CEND

CNIF 1=0

	Statement squigb{src.l,ycnt.w}
		MOVE.l d0,a0

		MOVEQ#0,d0:MOVE.l #cp,a1:MOVE.l#vd,a2

	nxlin5
		wl3:MOVE.w $c00008,d2:LSR#8,d2:CMP d2,d0:BPL wl3

	 MOVE.w (a0)+,d7

	;		MOVE.l #wvram+$38000003,(a1):MOVE #0,(a2)
	;		MOVE.l #wvram+$38020003,(a1):MOVE #0,(a2)
			MOVE.l #wsram+$00000000,(a1):MOVE d7,(a2)
	;		MOVE.l #wsram+$00020000,(a1):MOVE d7,(a2)


		ADDQ#1,d0:CMP d1,d0:BNE nxlin5:AsmExit




	End Statement

CEND



##[$80D3]

CNIF #c<>#s
	Event
	cardiff
	Dc.b	98,26,24,	 98,24,24,	44,0		;classic
	Dc.b	92,40,30,	 108,33,25 ,60	,0 ;grunty		2
	Dc.b	102,61,47,	115,59,45,64,0	 ;zippy
	Dc.b	100,80,60,	110,50,60,72,0	 ;nippy
	Dc.b	25,127,101, 29,45,122,68,0	;slippery
	Dc.b	117,23,17,	104,17,10 ,30	,0 ;pathetic	2
	Event
CEND




;Blue Top
;Green sweat shirt
;302-6308
