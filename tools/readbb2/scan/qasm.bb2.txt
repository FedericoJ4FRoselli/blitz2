; ascii translation of /Users/simon/Google Drive/amiga/w/disks/crap/examples_old/quikasm/qasm.bb2,/Users/simon/Google Drive/amiga/w/lha/bbold/disks/crap/examples_old/quikasm/qasm.bb2
#unbug=0
;
##[$80C3]:##[$80CC]:##[$80CB]
;
;This example is a bit heavier...A no pass assembler!
;
;This is included as a Blitz ][ demo in order to show
;you some of the juicier tricks which can be pulled off in
;Blitz ][
;
;How does it work?
;
;Firstly, object code is placed IMMEDIATELY into memory.
;we put it into chip mem to so that when lines are deleted
;or inserted, we can use the blitter to shift it all around.
;
;Also, labels are created immediately they are entered into
;the editor. When lines are deleted or inserted, labels are
;recalculated.
;
;Now, when things are entered into the editor, a big list
;of RCODE (run code) is maintained.
;This rcode is designed to fill in all unknown label refs
;etc. straight into the object code - this more or less
;reduces assembly time to the execution of a compiled
;program!
;
;To keep things simple, source files may not be INCLUDED,
;and macros are NOT supported (haven't worked out how to do
;them yet!)
;
;The only psuedo-ops currently available are:
;
; EQU
; DC
; DS
; INCBIN	(!)
;
;I'd really like to expand on this idea to produce a
;commercially viable product...Let me know if you think
;it'd be worth it.
;								 Mark

DEFTYPE.l

DEFTYPE.q x,y,x2,y2,cy,wtp,wbp

;we'll have an xtra 256 bytes of code to check for overflow
;ditto with rcode, but make it 512
;
codexs=256
rcodexs=512
;
maxlines=0				;max prog lines+1
maxlabs=0				 ;max labels
maxequs=0				 ;max equates
;
maxcode=0				 ;max object code
maxrcode=0				;max run code
;
mousew=16				 ;width of mouseables column (none right now!)
ltab=20					 ;label tab setting
otab=30					 ;operand tab
;
maxctemp=256			;max temp code space
maxrtemp=512			;max temp rcode space
;
#maxpcref=4			 ;maximum pcrefs in rcode
#maxlaref=6			 ;maximum label refs in rcode
;
maxtoks=130			 ;tokens
maxtdat=1020			;max token data
windhp=DispHeight ;allow for ntsc!
;
maxwins=windhp LSR 5		;max windows
windw=80-mousew				 ;width of edit window in chars
windwp=windw LSL 3			;above in pixels

NEWTYPE.aline
pc.l				;program counter
ln.l				;length of code in bytes
;
lab.w			 ;label offset
tok.b			 ;token
sz.b				;size def (.w)=0, .b=1, .w=2, .l=3, .s=4
ops$				;operand
rcode.l		 ;pointer to rcode
rcodel.w		;length of rcode
;
npc.w			 ;number of pcref entries
pcref.w[#maxpcref]	;offset of pc refs in rcode
laref.w[#maxlaref]	;label offsets in operands!
;
End NEWTYPE

NEWTYPE.label
flags.w		 ;0=available, ;b0=inited, b1=mousable
name$			 ;text
lval.l			;label value
init.w			;init count
acc.w			 ;access count
End NEWTYPE

NEWTYPE.ecode ;special rcode buffers for equs.
;
rcode.b[64]	 ;64 bytes should be OK per equ!
;
End NEWTYPE

Gosub edon:Gosub opts

MaxLen fpa$=160:MaxLen ffi$=64
MaxLen bpa$=160:MaxLen bfi$=64

.arrays
;
Dim ##[$80B3] lines.aline(maxlines+1)
Dim labs.label(maxlabs)
Dim cl.w(maxwins)					 ;current line
Dim cc(maxwins)						 ;current line current item
Dim wt.q(maxwins)					 ;locate of window top line
Dim vl.w(maxwins)					 ;lines visible in window
Dim tok$(maxtoks),tokp.w(maxtoks)			;tokens
Dim tokd.w(maxtdat)
Dim fld$(3)								 ;3 fields!
Dim sz$(4)
Dim no.w(1),nc.w(1),mo.w(1),re.w(1),ex.w(1)
Dim tr(1),r(1),rl(1)				;temp r code buffers
;
Dim npc.w(1),pcr.w(#maxpcref,1)
Dim lar.w(#maxlaref)
Dim ##[$80B3] equs.ecode(maxequs)				 ;pointer to rcode for equates

DEFTYPE.label *lab
labat=labs(0)+32768				 ;address of middle of labels

Statement putcurr{c}
Shared lines()
Poke.l lines(0)-40,c
End Statement

Function getcurr{}
Shared lines()
Function Return Peek.l(lines(0)-40)
End Function

Statement setbps{n}
Poke.w ##[$80B8] lmaxlen(0)+4,n
End Statement

Function yesno{t$}
;
localstat 1,80,32,480,64,$1002,"DECISION TIME!",1,2,1
WLocate 8,16
Print Centre$(t$,57)
##[$80BB]
	##[$80BB]
		ev=WaitEvent
	##[$80BC] EventWindow=1
	If ev=64
		If GadgetHit=1 Then k=-1:Goto endfunc
		If GadgetHit=2 Then k=0:Goto endfunc
	EndIf
	If ev=$400
		i$=Inkey$
		If i$=Chr$(13) Then k=-1:Goto endfunc
		If i$=Chr$(27) Then k=0:Goto endfunc
	EndIf
##[$80C7]
;
endfunc
Free localstat 1:Use localstat 0:BitMapOutput 0
Function Return k
;
End Function

Statement pw{k}
Print Mki$(k)
End Statement

Statement pl{k}
Print Mkl$(k)
End Statement

Function rw{}
Function Return Cvi(Inkey$(2))
End Function

Function rl{}
Function Return Cvl(Inkey$(4))
End Function

Statement ps{s$}
NPrint s$:If Eof(0)&1 Then Print Chr$(0)
End Statement

Function$ rs{}
s$=Edit$(256)
If Eof(0)&1 Then i$=Inkey$
Function Return s$
End Function

Gosub init:Gosub windon:Gosub new:Gosub refall

.main
;
##[$80CA] lines()
;
If upmo Then upmo=0:Gosub updatemouse
;
Gosub edsrcline ;alter src line
;
If alt Then Gosub linechange
;
Select ev
Case $400 ;keystroke!
	.keys
	Select Asc(i$)	;
	Case 13
		;return
		;
		pc=\pc+\ln
		If globalloc(lines())
			;
			If blkt
				If cl<blkt
					blkt+1:blkb+1
				Else
					If cl<blkb Then blkb+1
				EndIf
			EndIf
			;
			MaxLen \ops=0:Gosub zeroline:\pc=pc,0
			Scroll 0,wtp+8,windwp,(cy+wt(cw))LSL 3-wtp,0,wtp
			Boxf 0,(cy+wt(cw))LSL 3,windwp-1,(cy+wt(cw))LSL 3+7,0
			;
			cl+1:hl+1:y=cy:l=cl:Gosub showcwline
			;
			l=cl:nu=1:Gosub insfix:Gosub qrefall:cx=0
			;
		Else
			Gosub eder5
		EndIf
	Case 28
		;curs up
		;
		If cl>1
			If bq AND 3 ;shifted?
				y=Int(vl(cw)*.75)
				If cl-y<1 Then y=cl-1
				cl-y:For k=1 To y:j=PrevItem(lines()):Next
				Gosub refresh
			Else
				Scroll 0,wtp,windwp,vl(cw)LSL 3-8,0,wtp+8
				cl-1:k=PrevItem(lines())
				;
				Boxf 0,wtp,windwp-1,wtp+7,0
				;
				If cl-cy>=0
					PushItem lines():y=cy:l=cl
					While y
						y-1:l-1:k=PrevItem(lines())
					Wend
					Gosub showcwline
					PopItem lines()
				EndIf
				;
			EndIf
		Else
			Gosub eder1
		EndIf
	Case 29
		;curs down
		;
		If cl<hl
			If bq AND 3 ;shifted?
				y=Int(vl(cw)*.75)
				If cl+y>hl Then y=hl-cl
				cl+y:For k=1 To y:j=globfree(lines()):Next
				Gosub refresh
			Else
				Scroll 0,wtp+8,windwp,vl(cw)LSL 3-8,0,wtp
				cl+1:k=globfree(lines())
				;
				Gosub showbottom
				;
			EndIf
		Else
			Gosub eder2
		EndIf
CNIF #unbug=1
	Case 129	;F1 ?
		Gosub viewcode
	Case 130	;F2
		Gosub viewasm
	Case 131	;F3
		Gosub viewlabs
	Case 132	;F4
		Gosub viewrcode
	Case 133	;F5
		Gosub viewsrc
CEND
	End Select
Case 8
	If MButtons=1 Then Gosub mouseclick ;was &1
Case $100
	.menus
	Select MenuHit
	Case 0	;project
		Select ItemHit
		Case 0	;new
			If yesno{"THIS WILL ERASE EVERYTHING! ARE YOU SURE?"}
				Gosub new:Gosub refall
			EndIf
		Case 1	;load
			f$=FileRequest$("NAME OF FILE TO LOAD...",fpa$,ffi$)
			Gosub wac
			If f$
				If WriteMem(0,f$)
					FileInput 0:dcp=0			 ;get from file!
					If Inkey$(4)="qAsM" ;check ID!
						;
						lhl=rw{}:lhil=rw{}:leqs=rw{}:ldup=rw{}:lunk=rw{}
						lc=rl{}:lcl=rl{}
						lr=rl{}:lrl=rl{}
						;
						l$="" ;errors!
						If lhl>maxlines
							l$+", LINES ("+Str$(lhl)+")"
						EndIf
						If lhil>maxlabs
							l$+", LABELS ("+Str$(lhil+1)+")"
						EndIf
						If leqs>maxequs
							l$+", EQUATES ("+Str$(leqs)+")"
						EndIf
						If lcl>maxcode
							l$+", OBJECT CODE ("+Str$(lcl)+")"
						EndIf
						If lrl>maxrcode
							l$+", RCODE ("+Str$(lrl)+")"
						EndIf
						;
						If l$
							er$="NOT ENOUGH FREE "+Mid$(l$,3)
							Gosub err:Goto loaddone
						EndIf
						;
						Gosub new						 ;new the file!
						locfree lines()	 ;top of sorc...
						globfree lines():freelast lines()
						;
						;read lines
						;
						For k=1 To lhl:globalloc lines()
						MaxLen \ops=0
						##[$BE14] 0,lines(),SizeOf.aline
						Poke.l lines()+SizeOf.aline\ops,0
						\ops=rs{}
						;
						\pc-lc+code ;fix pc of line
						If \tok=4 ;equate stuff????
							If \rcode
								AddLast equs():\rcode=equs()
								##[$BE14] 0,\rcode,\rcodel
							EndIf
						Else
							If \rcode Then \rcode-lr+rcode
						EndIf
						Next
						;
						;read labels
						;
						For k=0 To lhil
						MaxLen labs(k)\name=0
						##[$BE14] 0,labs(k),SizeOf.label
						labs(k)\lval-lc+code
						Poke.l labs(k)+SizeOf.label\name,0
						labs(k)\name=rs{}
						Next
						;
						;read code!
						;
						##[$BE14] 0,code,lcl:codef=code+lcl
						;
						;read rcode!
						;
						##[$BE14] 0,rcode,lrl:rcodef=rcode+lrl
						;
						;fix rcode...
						;
						locfree lines()
						For k=1 To lhl:globfree lines()
						If \tok<>4 AND \rcode
							j=\rcode
							For l=0 To \npc-1
							Poke.l j+\pcref[l],Peek.l(j+\pcref[l])-lc+code
							Next
						EndIf
						Next
						;
						hl=lhl:hil=lhil:eqs=leqs:dup=ldup:unk=lunk
						codef=code+lcl:rcodef=rcode+lrl
						;
						locfree lines():globfree lines()
						cc(cw)=getcurr{}:dcp=-1
						;
					Else	;not right file!
						Gosub eder12
					EndIf
					loaddone
					Free WriteFile 0:WindowInput 0
					If dcp Then Gosub refall
				Else
					Gosub eder11
				EndIf
			EndIf
		Case 2	;save
			f$=FileRequest$("NAME TO SAVE FILE AS...",fpa$,ffi$)
			Gosub wac
			If f$
				If ReadMem(0,f$)
					FileOutput 0			;send to file!
					PushItem lines()
					;
					Print "qAsM"		;ID for qasm file.
					pw{hl}:pw{hil}:pw{eqs}:pw{dup}:pw{unk}
					pl{code}:pl{codef-code}
					pl{rcode}:pl{rcodef-rcode}
					;
					;write out lines
					;
					locfree lines()
					For k=1 To hl:globfree lines()
					Exists 0,lines(),SizeOf.aline
					ps{\ops}	;operands!
					;
					If \tok=4 ;equ?????
						If \rcode Then Exists 0,\rcode,\rcodel
					EndIf
					;
					Next
					;
					;write out labs
					;
					For k=0 To hil
					Exists 0,labs(k),SizeOf.label:ps{labs(k)\name}
					Next
					;
					;write out code!
					;
					Exists 0,code,codef-code
					;
					;write out rcode!
					;
					Exists 0,rcode,rcodef-rcode
					;
					PopItem lines()
					Free WriteFile 0:BitMapOutput 0
				Else
					Gosub eder11
				EndIf
			EndIf
		Case 3	;about
			;
			localstat 1,64,16,512,184,$1002,"ABOUT QUIK ASM",1,2,4

			WLocate 4,8:WColour 3,0
			Print "	 IN WHICH POOH ATTEMPTS TO WRITE A NO-PASS ASSEMBLER."
			WLocate 4,24:WColour 1,0
			Print "ONE MORNING, POOH WAS ASSEMBLING HIS SOURCE CODE WITH"
			WLocate 4,32
			Print "GENAM WHEN HE THOUGHT TO HIMSELF, 'GEE, WOULDN'T IT"
			WLocate 4,40
			Print "BE GREAT IF I COULD SPEND MORE TIME PROGRAMMING THAN"
			WLocate 4,48
			Print "WAITING FOR MY SOURCE CODE TO ASSEMBLE'. SUDDENLY, THERE"
			WLocate 4,56
			Print "WAS A KNOCK ON THE DOOR. 'HI POOH' SAID PIGLET, LETTING"
			WLocate 4,64
			Print "HIMSELF IN. 'WHAT'S UP?' 'CERTAINLY NOT ME' REPLIED POOH."
			WLocate 4,72
			Print "'AHHH' SAID PIGLET KNOWINGLY. 'THE ASSEMBLY BLUES AGAIN!'"
			WLocate 4,80
			Print "'YOU GOT IT' SAID POOH DEJECTEDLY. 'WELL' SAID PIGLET, 'I WAS"
			WLocate 4,88
			Print "JUST TALKING TO OWL, AND HE HAS THIS WEIRD IDEA ABOUT A"
			WLocate 4,96
			Print "ZERO PASS ASSEMBLER. PERSONALLY, I THINK HE'S BEEN HITTING THE"
			WLocate 4,104
			Print "JUICE A LITTLE HEAVILY LATELY, BUT HE SEEMED TO BE QUITE"
			WLocate 4,112
			Print "CONVINCED THE THEORY WAS UP TO IT.'"
			WLocate 4,128
			Print "'HMMM' SAID POOH. 'I THINK IT'S TIME FOR BREAKFAST.....'"

			##[$80BB]:Gosub readgad:##[$80BC] gad=1

			localstat 1,64,16,512,184,$1002,"ABOUT QUIK ASM",1,2,4

			WLocate 4,8
			Print "QUIK ASM IS A SIMPLE ZERO PASS 68000 ASSEMBLER."
			WLocate 4,20
			Print "QUIK ASM SUPPORTS THE FOLLOWING PSEUDO-OPS:"
			WLocate 4,28
			Print "DC	 DS	 EQU	 INCBIN"
			WLocate 4,40
			Print "QUIK ASM AUTOMATICALLY WORD ALIGNS ALL LINES."
			WLocate 4,52
			Print "LOAD AND SAVE WORK IN QUIK ASM'S OWN FORMAT, WHILE"
			WLocate 4,60
			Print "INSERT FROM DISK AND SAVE BLOCK WORK IN ASCII."
			WLocate 4,72
			Print "SORRY ABOUT THE LACK OF MACROS AND INCLUDES, BUT I HAVEN'T"
			WLocate 4,80
			Print "WORKED OUT HOW TO DO THEM YET!"
			WLocate 4,92
			Print "QUIK ASM WAS WRITTEN IN BLITZ BASIC ][."
			WLocate 4,100
			Print "FOR MORE INFORMATION ON BLITZ ][, PLEASE CONTACT:"
			WLocate 4,112:WColour 3,0
			Print "SIMON ARMSTRONG, ACID SOFTWARE;"
			WLocate 4,120
			Print "10 ST KEVINS ARCADE; AUCKLAND; NEW ZEALAND"
			WLocate 4,128
			Print "PHONE OR FAX : (64)9-358-1658"
			WColour 1,0
			;
			##[$80BB]:Gosub readgad:##[$80BC] gad=1
			Gosub closereq
			;
		Case 4	;quit
			If yesno{"DO YOU REALLY WANT TO QUIT?"} Then Goto quit
		End Select
	Case 1	;assembler
		Select ItemHit
		Case 0	;run!
			Gosub runcode
		Case 1	;make executable!

		Case 2	;jump to error
			If erl Then cl=erl:putcurr{erc}:Gosub qrefcw Else Gosub eder7
		Case 3	;find next duplicate label
			PushItem lines():k=0:j=cl
			While globfree(lines())
				j+1
				If \lab<>-1
					*lab=labat+\lab
					If *lab\init>1	;duplicate?
						k=getcurr{}:Goto dupfnd
					EndIf
				EndIf
			Wend
			dupfnd:PopItem lines()
			If k
				putcurr{k}:cl=j:Gosub qrefcw
			Else
				Gosub eder7
			EndIf
		Case 4	;reprocess incbins!
			PushItem lines():locfree lines():dcl=0
			While globfree(lines())
				dcl+1 ;next line!
				If \tok=3 ;incbin?
					f$=\ops:k=Instr(f$,";")
					If k Then f$=Left$(f$,k-1)
					Gosub doincbin2
					If erf	;any error!
						dcp=getcurr{}:Goto repdone
					EndIf
				EndIf
			Wend:dcl=0
			repdone:PopItem lines()
			erl=dcl:erc=dcp
		Case 5	;reprocess EVERYTHING!
.
.help0
.
			If yesno{"ARE YOU SURE? THIS MAY TAKE A WHILE!"}
				PushItem lines()
				locfree lines():jimi_=0
				While globfree(lines()) AND jimi_<hl
					Gosub calctext
					Gosub zapold
					Gosub linechange2
					jimi_+1
				Wend
				PopItem lines()
			EndIf
		End Select
	Case 2	;source
		Select ItemHit
		Case 0
			;top of file
			;
			If cl>1
				k=locfree(lines())
				k=globfree(lines()):cl=1:Gosub refresh
			Else
				Gosub eder1
			EndIf
		Case 1
			;bottom of file
			;
			If cl<hl
				k=LastItem(lines())
				k=PrevItem(lines()):cl=hl:Gosub refresh
			Else
				Gosub eder2
			EndIf
		Case 2
			;insert line
			;
			k=PrevItem(lines()):pc=\pc+\ln
			If globalloc(lines()) ;can we insert?
				;
				If blkt
					If cl<=blkt
						blkt+1:blkb+1
					Else
						If cl<=blkb Then blkb+1
					EndIf
				EndIf
				;
				Gosub zeroline:\pc=pc,0
				;
				y=(cy+wt(cw))LSL 3
				;
				Scroll 0,y,windwp,wbp-y-7,0,y+8
				Boxf 0,y,windwp-1,y+7,0:hl+1
				;
				l=cl:nu=1:Gosub insfix:Gosub qrefall
				;
			Else
				k=globfree(lines()):Gosub eder5
			EndIf
		Case 3
			;delete line!
			;
			If blkt
				If cl<blkt
					blkt-1:blkb-1
				Else
					If cl<=blkb Then blkb-1:If blkb<blkt Then blkt=0:blkb=0
				EndIf
			EndIf
			;
			pc=\pc:Gosub zapold:ln=0:Gosub newlen
			y=(cy+wt(cw))LSL 3
			;
			If hl=1	 ;only one line to delete?
				Boxf 0,y,windwp-1,y+7,0:Gosub zeroline:\pc=pc
				y=cy:l=1:Gosub showcwline:Gosub qrefall:Goto deldone
			EndIf
			;
			l=cl:nu=1:freelast lines()
			;
			If cl<hl
				Scroll 0,y+8,windwp,wbp-y-7,0,y
				k=globfree(lines()):hl-1:Gosub showbottom
			Else
				cl-1:hl-1:Gosub qrefcw
			EndIf
			;
			Gosub delfix:Gosub qrefall
			;
			deldone
			;
		Case 4	;insert from disk!
			;
			f$=FileRequest$("NAME OF FILE TO INSERT...",bpa$,bfi$)
			Gosub wac
			If f$
				If WriteMem(0,f$) ;open file?
					FileInput 0:PrevItem lines():nu=0	;no lines yet!
					While NOT DosBuffLen(0)	;more?
						pc=\pc+\ln
						If globalloc(lines()) ;free line?
							nu+1:hl+1:Gosub zeroline:\pc=pc
							li$=Edit$(256)
							;
							;change tabs to spaces...
							;
							li$=StripTrail$(Replace$(li$,Chr$(9)," "),32)
							;
							erf=0
							Gosub linechange2 ;newline!
							;
						Else
							Gosub eder5:Goto insdone
						EndIf
					Wend
					insdone
					CloseFile 0:WindowInput 0
				Else
					Gosub eder11
				EndIf
				Gosub findcl:l=cl:Gosub insfix
				;
				;adjust block
				;
				If blkt
					If cl<=blkt
						blkt+nu:blkb+nu
					Else
						If cl<=blkb Then blkb+nu
					EndIf
				EndIf
				;
				Gosub qrefcw:Gosub qrefall
			EndIf
		End Select
	Case 3	;blocks
		Select ItemHit
		Case 0	;mark
			If blkb=0 Then blkb=cl:Goto markdone
			If blkt=0
				blkt=cl
				If blkb<blkt Then ##[$80C9] blkt,blkb
				Goto markshow
			EndIf
			If cl<blkt Then blkt=cl:Goto markshow
			blkb=cl
			markshow:Gosub qrefcw:Gosub qrefall
			markdone
		Case 1	;forget
			If blkt=0 AND blkb=0
				Gosub eder8
			Else
				doforget
				blkt=0:blkb=0:Goto markshow
			EndIf
		Case 2	;copy
			If blkt=0 Then Gosub eder8:Goto copydone
			If cl>blkt AND cl<=blkb Then Gosub eder9:Goto copydone
			If hl+(blkb-blkt)>=maxlines-1 Then Gosub eder10:Goto copydone
			;
			k=PrevItem(lines()):dec=getcurr{}
			Gosub findtop:blc=getcurr{}:knt=blkb
			;
			;dec=destination item, blc=block current item
			;
			While knt>=blkt
				Gosub calctext:k=globfree(lines()):blc=getcurr{}
				putcurr{dec}:pc=\pc+\ln
				k=globalloc(lines()):hl+1:dec=getcurr{}
				Gosub zeroline:\pc=pc
				erf=0 ;no errs
				Gosub linechange2:putcurr{blc}
				knt-1
			Wend
			;
			Gosub findcl:l=cl:nu=blkb-blkt+1:Gosub insfix
			;
			If cl<=blkt
				k=blkb-blkt+1:blkt+k:blkb+k
			EndIf
			;
			Goto markshow
			copydone
			;
		Case 3	;delete
			If blkt=0 Then Gosub eder8:Goto bdedne
			Gosub findtop
			;
			PushItem lines():l=blkb:ln=0
			;
			While l>=blkt
				ln+\ln:Gosub zapold
				If l<>blkb Then freelast lines()
				l-1:hl-1:k=globfree(lines())
			Wend
			;
			PopItem lines()
			\ln=ln:ln=0:Gosub newlen:freelast lines()
			;
			If hl=0 ;no lines left!
				k=locfree(lines()):k=globalloc(lines())
				Gosub zeroline:\pc=code:hl=1
			EndIf
			;
			Gosub findcl
			l=blkt:nu=blkb-blkt+1
			Gosub delfix:Goto doforget
			bdedne
			;
		Case 4	;to disk
			;
			If blkt=0 Then Gosub eder8:Goto btddne
			;
			f$=FileRequest$("NAME TO SAVE BLOCK AS...",bpa$,bfi$)
			Gosub wac
			If f$
				If ReadMem(0,f$)
					FileOutput 0
					PushItem lines():Gosub findtop
					For dcl=blkt To blkb
					Gosub calctext
					;
					;convert spaces to tabs!
					;
					mtabs
					k=Instr(li$," ")
					If k
						j=k
						##[$80BB]
							j+1
						##[$80BC] Mid$(li$,j,1)<>" "
						li$=Left$(li$,k-1)+Chr$(9)+Mid$(li$,j)
						Goto mtabs
					EndIf
					;
					NPrint li$:globfree lines():Next
					PopItem lines()
					CloseFile 0:BitMapOutput 0
				Else
					Gosub eder11
				EndIf
			EndIf
			;
			btddne
		End Select
	Case 4	;search
		;
		Select ItemHit
		Case 0
			localstat 1,96,32,448,88,$1002,"FIND/REPLACE",1,2,2
			WLocate 4,16:Print "FIND		:"
			WLocate 4,32:Print "REPLACE :"
			ClearString 1,6
			##[$80BB]
				Gosub readgad
				If gad=1 OR gad=7 Then Gosub closereq:Goto dofind
				If gad=2 Then Gosub closereq:Goto serdon
				If gad=3 Then sla=1-sla
				If gad=4 Then sca=1-sca
				If gad=5 Then snw=1-snw
				If gad=6 Then ClearString 1,7 Else ClearString 1,6
			##[$80C7]
			serdon
		Case 1	;next!
			dofind	;find next occurance - cx=cursor X
			;
			Gosub initfind:dcl-1
			;
			##[$80BB]
				dcl+1:Gosub isfihere
			##[$80BC] (NOT globfree(lines())) OR dcl>=hl OR dcp
			;
			Gosub finitfind
			;
		Case 2	;previous!
			;
			Gosub initfind:dcl+1
			;
			##[$80BB]
				dcl-1:Gosub isfihere
			##[$80BC] (NOT PrevItem(lines())) OR dcl<2 OR dcp
			;
			Gosub finitfind
			;
		Case 3	;replace
			;
			Gosub calctext
			;
			fi$=GadgetPens(2,6)
			s$=Mid$(li$,cx+1,Len(fi$))
			;
			If csa
				If fi$=s$ ;here?
					doreplace
					;
					li$=Left$(li$,cx)+GadgetPens(2,7)+Mid$(li$,Len(fi$)+cx+1)
					;
					Gosub zapold:Gosub linechange2
					y=(wt(cw)+cy)LSL 3
					Boxf 0,y,windwp-1,y+7,0
					l=cl:y=cy:Gosub showcwline:Gosub qrefall
					;
					Goto repldone
					;
				EndIf
			Else
				If LCase$(fi$)=LCase$(s$) Then Goto doreplace
			EndIf
			;
			Gosub eder7
			;
			repldone
		End Select
	Case 5	;windows
		Select ItemHit
		Case 0
			;open new window
			;
			If wo<maxwins
				Gosub oldwin:Gosub newwindow:Gosub fromcurr
				cw=wo:Gosub newwin
				Gosub refall
			Else
				Gosub eder3
			EndIf
		Case 1
			;close window
			;
			If wo>1 Then Gosub closewin Else Gosub eder4
		End Select
	Case 6
		Select ItemHit
		Case 0	;last error
			If ler$ Then er$=ler$ Else er$="Just kidding!"
			Gosub err
		Case 1	;stats
			;
			j=0
			For k=0 To hil
			If labs(k)\flags Then j+1
			Next
			;
			localstat 1,80,32,480,128,$1002,"PROGRAM STATISTICS...",1,2,3
			WLocate 4,16
			Print "SOURCE LINES : ",hl
			WLocate 4,32
			Print "LABELS : ",j," (",dup," DUPLICATE, ",unk," UNKNOWN)"
			WLocate 4,48
			Print "EQUATES : ",eqs
			WLocate 4,64
			Print "OBJECT CODE AT $",Hex$(code)," ; LENGTH $",Hex$(codef-code)
			WLocate 4,80
			Print "RCODE AT $",Hex$(rcode)," ; LENGTH $",Hex$(rcodef-rcode)
			;
			##[$80BB]
				Gosub readgad
			##[$80BC] gad=1
			Gosub closereq
		Case 2	;cli
			lo=##[$FE01]("con:0/0/640/"+Str$(DispHeight)+"/CLI",1006)
			If lo
				##[$FFB5]
				##[$FE21] ?azero,lo,0
				##[$FFB4]
				##[$FE02] lo
			EndIf
		End Select
	End Select
End Select
;
Goto main

;******************** SUBROUTINES ********************

azero:Dc.l 0

updatemouse ;update all mousable labels!
;
setbps{2}:Boxf windwp+8,12,639,windhp+11,2
;
Locate 0,1.5:Colour 3,2
;
PushItem lines()
;
locfree lines()
While globfree(lines())
If \lab<>-1
	*lab=labat+\lab
	If *lab\flags&2
		Locate windw+1,CursY
		NPrint Left$(*lab\name,mousew-1)
	EndIf
EndIf
Wend
;
mout
PopItem lines()
Colour 1,0:setbps{1}:Return

.subs
.
initfind
PushItem lines():dcl=cl:dcp=0	;found line,item!
CaseSense Off:If sca Then CaseSense On
fi$=GadgetPens(2,6)
fx=cx+2 ;start find pos.
Return

.insfix ;line inserted before, nu=number inserted!
;
If wo>1
	For k=1 To wo
	If k<>cw AND cl(k)>=l Then cl(k)+nu
	Next
EndIf
Return

.delfix ;l=line deleted, nu=number deleted.
;
If wo>1
	PushItem lines()
	For k=1 To wo
	If k<>cw AND cl(k)>=l
		If cl(k)>=l+nu Then cl(k)-nu Else cl(k)=l+nu
		If cl(k)>hl Then cl(k)=hl
		;
		j=locfree(lines()):j=cl(k)
		While j
			zz=globfree(lines()):j-1
		Wend
		cc(k)=getcurr{}
	EndIf
	Next
	PopItem lines()
EndIf
Return

finitfind
PopItem lines()
If dcp	;found somewhere!
	If snw AND wo<maxwins	;open new window for the find!
		Gosub oldwin:Gosub newwindow
		cw=wo:cl(cw)=dcl:cc(cw)=dcp
		Gosub newwin:Gosub refall
	Else
		cl=dcl:putcurr{dcp}
		Gosub qrefcw
	EndIf
Else
	Gosub eder7
EndIf
Return

isfihere
If sla	;find only label?
	If fx=1 AND \lab<>-1
		*lab=labat+\lab
		If sca
			If *lab\name=fi$ Then j=1:Goto isfound
		Else
			If LCase$(*lab\name)=LCase$(fi$) Then j=1:Goto isfound
		EndIf
	EndIf
Else		;whole thing!
	Gosub calctext
	j=Instr(li$,fi$,fx):If j Then Goto isfound
EndIf
fx=1:Return
isfound
cx=j-1:dcp=getcurr{}
Return

closereq
Free localstat 1:Use localstat 0:BitMapOutput 0
wac
##[$80BB]
##[$80BC] WaitEvent=$40000
Return

showbottom
Boxf 0,wbp,windwp-1,wbp-7,0
;
If vl(cw)-cy+cl<hl+3
	PushItem lines():y=cy:l=cl
	While y<vl(cw)-1
		y+1:l+1:k=globfree(lines())
	Wend
	Gosub showcwline
	PopItem lines()
EndIf
Return

opts
;
If WriteMem(0,"l:qasm.opts")
	FileInput 0
	maxlines=Cvl(Inkey$(4))
	maxlabs=Cvl(Inkey$(4))
	maxequs=Cvl(Inkey$(4))
	maxcode=Cvl(Inkey$(4))
	maxrcode=Cvl(Inkey$(4))
	CloseFile 0
Else
	maxlines=1000
	maxlabs=100
	maxequs=20
	maxcode=16384
	maxrcode=1024
EndIf
;
x=196:SetString 1,1
workstart 0,8,104,0,1," OK "
workstart 0,368,104,0,2," CANCEL "
;
StringGadget 0,x,17,0,3,8,64
ButtonId 0,3,Str$(maxlines)
StringGadget 0,x,17+16,0,4,8,64
ButtonId 0,4,Str$(maxlabs)
StringGadget 0,x,17+32,0,5,8,64
ButtonId 0,5,Str$(maxequs)
StringGadget 0,x,17+48,0,6,8,64
ButtonId 0,6,Str$(maxcode)
StringGadget 0,x,17+64,0,7,8,64
ButtonId 0,7,Str$(maxrcode)
;
workstart 0,412,17+48,0,8,"Y":omem=2
workstart 0,412,17+64,0,9,"N":rmem=1
;
workstart 0,196,104,0,10," SAVE "
;
localstat 1,96,24,448,120,$1002,"OPTIONS",2,1,0
WColour 1,0
;
WLocate 4,08:Print "MAXIMUM SOURCE LINES :"
WLocate 4,24:Print "MAXIMUM LABELS			 :"
WLocate 4,40:Print "MAXIMUM EQUATES			:"
WLocate 4,56:Print "MAXIMUM OBJ CODE		 :"
WLocate 268,56:Print "....USE CHIPMEM?"
WLocate 4,72:Print "MAXIMUM RCODE				:"
WLocate 268,72:Print "....USE CHIPMEM?"
;
##[$80BB]
	Gosub readgad
	If gad=2 Then End ;cancel
	If gad=1					;ok
		Gosub readstuff
		Free localstat 1:Return
	EndIf
	If gad=8
;		omem=3-omem:WLocate 412,56
;		If omem=2 Then Print "Y" Else Print "N"
	EndIf
	If gad=9
;		rmem=3-rmem:WLocate 412,72
;		If rmem=2 Then Print "Y" Else Print "N"
	EndIf
	If gad=10 ;save!
		If ReadMem(0,"l:qasm.opts")
			Gosub readstuff
			FileOutput 0
			Print Mkl$(maxlines)
			Print Mkl$(maxlabs)
			Print Mkl$(maxequs)
			Print Mkl$(maxcode)
			Print Mkl$(maxrcode)
			CloseFile 0
			WindowOutput 1
		Else
			##[$FF8C] 0
		EndIf
	EndIf
	If gad>=3 AND gad<=6
		ClearString 1,gad+1
	EndIf
##[$80C7]

readstuff
maxlines=Val(GadgetPens(0,3))
maxlabs=Val(GadgetPens(0,4))
maxequs=Val(GadgetPens(0,5))
maxcode=Val(GadgetPens(0,6))
maxrcode=Val(GadgetPens(0,7))
Return

readgad
##[$80BB]
	ev=WaitEvent
##[$80BC] EventWindow=1
If ev=64 Then gad=GadgetHit:Return
If ev=$400
	If Inkey$=Chr$(13) Then gad=1:Return
	If Inkey$=Chr$(27) Then gad=2:Return
EndIf
Goto readgad

.findtop	;find top of block
locfree lines():l=1
While globfree(lines()) AND l<blkt
l+1:Wend
Return

.findcl
If cl>hl Then cl=hl
;
k=locfree(lines()):l=1
While globfree(lines()) AND l<cl
l+1:Wend
;
Return

.runcode
;
##[$80CA] lines()
;
erl=0
;
If dup	;any duplicate labels?
	PushItem lines():k=locfree(lines())
	While globfree(lines())
		erl+1
		If \lab<>-1
			*lab=labat+\lab
			If *lab\init>1 Then erc=getcurr{}:Goto dlabfnd
		EndIf
	Wend:erl=0	;just in case!
	dlabfnd:PopItem lines():Goto aser1
EndIf
;
If unk	;any unknown labels?
	PushItem lines():k=locfree(lines())
	While globfree(lines())
		erl+1
		For k=0 To #maxlaref-1
		If \laref[k]<>-1
			*lab=labat+\laref[k]
			If *lab\init=0 Then erc=getcurr{}:##[$80BE] For:Goto unfnd
		EndIf
		Next
	Wend:erl=0	;just in case!
	unfnd:PopItem lines():Goto aser10
EndIf
;
If eqs	;any equs?
	;
	;execute equ code FIRST! (and in order, damnit!)
	;
	newmem equs()
	While globfree(equs())
		GetReg d0,equs()
		MOVE.l #runerr,d1:JSR execcode
	Wend
EndIf
;
;OK to run rcode!
;
Poke.w rcodef,$4e75
GetReg d0,rcode
MOVE.l #runerr,d1
JSR execcode
;
If NOT yesno{"RCODE EXECUTED OK - RUN OBJECT CODE?"} Then Return
;
;OK to run REAL code!
;
MOVEM.l d0-d7/a0-a6,thedregs
GetReg a0,code
MOVE.l #mylibbase,a5
JSR (a0)
MOVEM.l thedregs,d0-d7/a0-a6
Return
;
thedregs:Ds.l 16
;
dumpregs:Ds.l 16
;
runerr	;rcode error!
;
ADDQ #4,a7
PushItem lines():k=locfree(lines()):k=Peek.l(?errat)
While globfree(lines())
	erl+1
	If \rcode
		If k>\rcode AND k<=\rcode+\rcodel
			erc=getcurr{}:Goto erfownd
		EndIf
	EndIf
Wend:erl=0
;
erfownd:PopItem lines():Goto err

mylibbase		 ;my own little routines here!
JMP regdump

regdump ;a little register dumper!
MOVEM.l d0-d7/a0-a7,dumpregs				 ;save regs
;
MOVEM.l thedregs,d0-d7/a0-a6				;get blitz regs
;
localstat 1,56,12,528,176,$1002,"REGISTER DUMP",1,2,5
y=8
For k=0 To 15
WLocate 4,y:WColour 3,0
If k<8 Then Print "D" Else Print "A"
Print k&7," : ":WColour 1,0
j=Peek.l(?dumpregs+k LSL2)
Print RSet$(Str$(j),12),"	$",Hex$(j),"	%",Bin$(j)
If k=7 Then y+4
y+8:Next
##[$80BB]
	Gosub readgad
##[$80BC] gad=1
Gosub closereq
;
MOVEM.l dumpregs,d0-d7/a0-a7
RTS

CNIF #unbug=1

deon
Gosub oldwin:setbps{2}
Boxf 0,12,windwp-1,windhp+11,0 ;cls
Colour 1,0:Locate 0,1.5:Return

deoff
##[$80BB]
##[$80BC] Inkey$
setbps{1}:Gosub newwin:Goto refall

viewsrc
;
Gosub deon:NPrint "SOURCE:"
;
##[$80CA] lines()
PushItem lines()
If locfree(lines())
	While globfree(lines())
		NPrint \ops
	Wend
EndIf
PopItem lines()
;
Goto deoff

viewrcode
;
Gosub deon:NPrint "RCODE:"
;
NPrint "$",Hex$(rcode)," -> $",Hex$(rcodef)
;
For k=rcode To rcodef-2 Step 2
NPrint "$",Mid$(Hex$(Peek.w(k)),5)
Next
;
Goto deoff

viewcode
;
Gosub deon:NPrint "CODE:"
;
NPrint "$",Hex$(code)," -> $",Hex$(codef)
;
##[$80CA] lines()
;
PushItem lines()
k=locfree(lines())
While globfree(lines())
	If \ln
		Print "$",Hex$(\pc)
		For k=0 To \ln-2 Step 2
		Locate 10,CursY
		NPrint "$",Mid$(Hex$(Peek.w(\pc+k)),5)
		Next
	EndIf
Wend
PopItem lines()
;
Goto deoff

viewasm
;
Gosub deon:NPrint "ASM:"
;
NPrint np
For k=0 To np-1
NPrint mo(k)," ",re(k)," ",ex(k),"		 "
Next
;
For j=0 To np-1
NPrint "":NPrint "Rcode",j
;
For k=0 To rl(j)-2 Step 2
NPrint "$",Mid$(Hex$(Peek.w(tr(j)+k)),5)
;
Next k,j
;
NPrint "":NPrint "Code @ $",Hex$(tc)
;
For k=0 To tcl-2 Step 2
NPrint "$",Mid$(Hex$(Peek.w(tc+k)),5)
Next
;
Goto deoff

viewlabs
;
Gosub deon:NPrint "LABELS:"
;
For y=0 To hil
If labs(y)\flags
	NPrint labs(y)\name," ",labs(y)\init," ",labs(y)\acc," $",Hex$(labs(y)\lval)
EndIf
Next
;
Goto deoff

CEND

Function$ ch{}
Shared lz$,p
p+1:Function Return Mid$(lz$,p,1)
End Function

Function rn{c$}
If c$>="0" AND c$<="7" Then Function Return -1
Function Return 0
End Function

Function nu{c$}
If c$>="0" AND c$<="9" Then Function Return -1
Function Return 0
End Function

Function al{c$}
If LCase$(c$)>="a" AND LCase$(c$)<="z" Then Function Return -1
Function Return 0
End Function

Function he{c$}
If nu{c$} OR (c$>="a" AND c$<="f") Then Function Return -1
Function Return 0
End Function

Function an{c$}
If nu{c$} OR al{c$} OR c$="_" Then Function Return -1
Function Return 0
End Function

Statement putcw{k}
Shared c,tcl
Poke.w c,k:c+2:tcl+2
End Statement

Statement putcl{k}
Shared c,tcl
Poke.l c,k:c+4:tcl+4
End Statement

Statement putrw{k}
Shared r(),rl(),np
Poke.w r(np),k:r(np)+2:rl(np)+2
End Statement

Statement putrl{k}
Shared r(),rl(),np
Poke.l r(np),k:r(np)+4:rl(np)+4
End Statement

fetchabs
Gosub fetchd:If mo(np)<>$100 Then Goto aser1
Return

fetchcon	;fetch a constant value!
Gosub fetchabs
If no(np)<>nc(np) Then Goto aser11
evalrcode
putrw{$4e75}	;rts!
GetReg d0,tr(np):MOVE.l #aserr,d1:JSR execcode
##[$80BD] d0,va:Return

makeeven
If c&1 Then c+1:tcl+1
Return

doincbin2:MOVE.l a7,ssp:nla=0 ;no label refs
doincbin	;f$=file to incbin
;
lo=##[$FE0A](f$,2)												 ;read lock!
If lo=0 Then Goto aser12							;can't do it!
If ##[$FE0D](lo,lok)=0 Then Goto aser12
If Peek.l(lok+4)>=0 Then Goto aser12	 ;not directory
ln=Peek.l(lok+124):##[$FE0B] lo ;size of file in bytes
If ln&1 Then ln+1 ;align!
;
If codef-code-\ln+ln>maxcode Then Goto aser18
;
lo=##[$FE01](f$,1005):If lo=0 Then Goto aser12
Gosub newlen:##[$FE03] lo,\pc,ln:##[$FE02] lo
Return

prepdc:MOVE.l #0,a2
dcbyte:MOVE.b d0,(a2)+
dcword:MOVE.w d0,(a2)+
dclong:MOVE.l d0,(a2)+

.assem
;
;INPUTS:
;
;t=token#, sz=size, lines()\pc=pc of line, li$=operands
;
;OUTPUTS:
;
;put code into tc , rcode into tr
;
;code len in	 tcl, rcode len in trl
;
;no(0) - # of source ops, nc(0) - number of source constants
;
;no(1) - # of dest ops,	 nc(1) - number of dest constants
;
If codef-code>maxcode Then Goto aser15 ;not enough code space!
;
If rcodef-rcode>maxrcode Then Goto aser16 ;not enough rcode
;
##[$80CA] lines()
lz$=li$
k=Instr(lz$,";"):If k Then lz$=StripTrail$(Left$(lz$,k-1),32)
lz$+",":ll$=LCase$(lz$)
p=0												 ;character fetch position
For k=0 To 1
r(k)=tr(k):rl(k)=0:npc(k)=0
Next
c=tc:tcl=0:nla=0:np=0:MOVE.l a7,ssp
;
If t<11
	;handle pseudo ops!
	Select t
	Case 1	;dc
		;
		;set up so only 1 pc ref on line!
		;
		Select sz ;what size is this dc?
		Case 1
			dcp=?dcbyte:dcl=1
		Case 3
			dcp=?dclong:dcl=4
		Default
			If sz=4 Then Goto aser7
			dcp=?dcword:dcl=2
		End Select
		dcp=Peek.w(dcp)
		putrw{Peek.w(?prepdc)}	;move.l #pc,a2
		Gosub addpcref:putrl{c}
		ldok=0	;not ok to compare const with last!
		;
		dcmore
		te$=Mid$(ll$,p+1,1)
		If (te$="'" OR te$=Chr$(34)) AND dcl=1	;quote?
			;
			;shit
			;
			putrw{Peek.w(?getbase)}:putrw{28}:p+1 ;make string copy jsr!
			;
			ploop
			If p+1>=Len(ll$) Then Goto aser17
			c$=ch{}
			If c$<>te$
				c+1:tcl+1
				Poke.b r(np),Asc(c$):r(np)+1:rl(np)+1:Goto ploop
			EndIf
			Poke.b r(np),0:r(np)+1:rl(np)+1
			If rl(np)&1 Then r(np)+1:rl(np)+1
			c$=ch{}
		Else
			oldr=r(np):oldrl=rl(np)
			Gosub fetchabs	;get dc val!
			If no(np)=nc(np)					;ez const?
				Gosub evalrcode
				r(np)=oldr:rl(np)=oldrl
				;
				;OK to re-use last constant?
				;
				If ldok=0 OR va<>lcon
					Gosub makevaimm
				EndIf
				ldok=-1:lcon=va
				;
			Else
				ldok=0
			EndIf
			putrw{dcp}:c+dcl:tcl+dcl
		EndIf
		;
		If p<Len(ll$) Then Goto dcmore
		Gosub makeeven:np=1
	Case 2	;ds ;must use consants only!
		;
		Select sz
		Case 1
			dcp=0 ;no shift for size!
		Case 3
			dcp=2 ;lsl 2
		Default
			If sz=4 Then Goto aser7
			dcp=1
		End Select
		;
		Gosub fetchcon
		;
		ln=va LSL dcp:If ln&1 Then ln+1 ;make length even!
		##[$80BE] Select:Goto newlen
		;
	Case 3	;incbin! WOW!
		f$=Left$(lz$,Len(lz$)-1):Gosub doincbin
		##[$80BE] Select:Return
	Case 4	;equ - shit!
		;
		If \lab=-1 Then Goto aser13 ;no label on line!
		;
		;find out what number equ we are!
		;
		k=0
		PushItem lines()
		While PrevItem(lines())
			If \tok=4 Then k+1
		Wend
		PopItem lines()
		;
		;OK, now, insert at right pos in equs
		;
		newmem equs()
		While k:globfree equs():k-1:Wend
		;
		Gosub fetchabs	;get equ value!
		;
		If no(np)=nc(np)	;constant value?
			Gosub evalrcode ;va=value
			r(np)=tr(np):rl(np)=0
			Gosub makevaimm
		EndIf
		;
		If NOT globalloc(equs()) Then Goto aser14	;OK to add?
		;
		putrw{Peek.w(?putequ)}:putrw{\lab}:putrw{$4e75}
		;
		;all done!
		;
		\rcode=equs(),rl(np)
		;
		For k=0 To rl(np)-2 Step 2
		Poke.w equs()+k,Peek.w(tr(np)+k)
		Next
		;
		np+1:Gosub adjtemp:ln=0:Gosub newlen
		Gosub makepcrefs:Gosub makelarefs
		eqs+1:##[$80BE] Select:Return
		;
	End Select
	Goto asmed
	;
EndIf
;
If Len(ll$)>1
	Gosub fetchd:If Mid$(ll$,p,1)<>"," Then Goto aser4
	np+1:If p<Len(ll$)
		Gosub fetchd:If Mid$(ll$,p)<>"," Then Goto aser4
		np+1
	EndIf
EndIf
;
p=tokp(t)
##[$80BB]
	If np=0 AND tokd(p)=0 AND tokd(p+1)=0				 ;simple!
		Poke.w c,tokd(p+2):c+2:tcl+2:Goto asmed
	EndIf
	If np=1 AND tokd(p)&mo(0)>0 AND tokd(p+1)=0		 ;1 op only!
		Gosub asmit:Goto asmed
	EndIf
	If np=2 AND tokd(p)&mo(0)>0 AND tokd(p+1)&mo(1)>0 ;2 ops!
		Gosub asmit:Goto asmed
	EndIf
	p+5
##[$80BC] tokd(p)=-1
;
;error
;
Goto aser6
;
asmed ;successfully assembled!
;
Gosub copycode
Gosub copyrcode
Gosub makepcrefs
Gosub makelarefs
;
;all done! (hopefully!)
;
Return

putequ:MOVE.l d0,0(a1)

copycode
;first, add code
;
Gosub adjtemp:ln=tcl:Gosub newlen
For k=0 To tcl-2 Step 2
Poke.w lines()\pc+k,Peek.w(tc+k)
Next
Return

copyrcode
;make new rcode refs...
;
If rl(0)+rl(1)	;any rcode?
	lines()\rcode=rcodef,rl(0)+rl(1)
	For j=0 To np-1
	For k=0 To rl(j)-2 Step 2
	Poke.w rcodef,Peek.w(tr(j)+k):rcodef+2
	Next k,j
Else
	lines()\rcode=0,0
EndIf
Return

makepcrefs
;make offsets into rcode for pc refs
;
lines()\npc=npc(0)+npc(1) ;pc refs
If np
	j=0
	For k=1 To npc(0)
	lines()\pcref[j]=pcr(k,0):j+1
	Next
	If np>1
		For k=1 To npc(1)
		lines()\pcref[j]=pcr(k,1)+rl(0):j+1
		Next
	EndIf
EndIf
Return

makelarefs
;now, label refs!
;
For k=1 To nla
lines()\laref[k-1]=lar(k)
Next
Return

ssp:Dc.l 0

.asmit ;do the asm
;
If sz
	k=(tokd(p+3)LSR 4)&15
	If (sz=1 OR sz=4) AND k&1=0 Then Goto aser7
	If sz=2 AND k&2=0 Then Goto aser7
	If sz=3 AND k&4=0 Then Goto aser7
EndIf
;
op.w=tokd(p+2):c+2:tcl+2
;
If tokd(p+3)&15 ;size stuff?
	k=sz:If sz=0 Then k=2 Else If sz=4 Then k=1
	Select tokd(p+3)&15
	Case 1	;00=b, 01=w, 10=l @ bp 6
		op+(k-1)LSL 6
	Case 2	;011=w, 111=long @ bp 6
		If k=2 Then op+192 Else op+448
	Case 3	;010=w, 011=long @ bp 6
		If k=2 Then op+128 Else op+192
	Case 4	;01=byte, 11=w, 10=long @ bp 12
		Select k
		Case 1:op+4096
		Case 2:op+12288
		Case 3:op+8192
		End Select
	Case 5	;0=w, 1=l @ bp 6
		If k=3 Then op+64
	End Select
EndIf
;
gb=Peek.w(?getbase):np2=np:np=0
;
Select tokd(p+4)	;special case stuff!
;
Case 1	;imm src data (1-8) @ bp 9 of opcode
	putrw{gb}:putrw{8}
	For k=?code4 To ?code7+2 Step 2
	Poke.w r(np),Peek.w(k):r(np)+2:rl(np)+2
	Next
	Gosub addpcref
	putrl{tc}
	putrw{Peek.w(?code8)}
	Gosub addpcref
	putrl{tc}
	mo(np)=0
Case 2	;branch lab in src
	dothebra
	If sz<>1 AND sz<>4		;word branch!
		putrw{Peek.w(?subcode)}
		Gosub addpcref
		putrl{c}
		putrw{gb}:putrw{20}
		putrw{Peek.w(?code1)}
		Gosub addpcref
		putrl{c}:putcw{0}
	Else		;short branch
		putrw{Peek.w(?subcode)}
		Gosub addpcref
		putrl{c}
		putrw{gb}:putrw{24}
		putrw{Peek.w(?code2)}
		Gosub addpcref
		putrl{tc+1}
	EndIf
	mo(np)=0
Case 4	;branch lab in dest
	np=1:Goto dothebra
Case 8	;swap movem bits in src if dest is -(an)
	If mo(1)=$10
		j=ex(0):ex(0)=0
		For k=0 To 15
		If j ##[$80CD] k Then ex(0) ##[$80CE] (15-k)
		Next
	EndIf
Case 16 ;imm data (-128->127) @ bp 0 of opcode
	putrw{gb}:putrw{16}		 ;check range
	putrw{Peek.w(?code2)}	 ;move.b #x,abs.l
	Gosub addpcref
	putrl{tc+1}:mo(np)=0
Case 32 ;trap vector (0-15) in opcode
	putrw{gb}:putrw{12}		 ;check range
	putrw{Peek.w(?trcode)}	;or #$40,d0
	putrw{Peek.w(?code2)}	 ;move.b d0,abs.l
	Gosub addpcref
	putrl{tc+1}						 ;address
	mo(np)=0
End Select
;
For np=0 To np2-1
;
j=tokd(p+3) LSR 12:If np Then j=(tokd(p+3) LSR 8)&15
;
If j
	mo2=mo(np):mo=-1
	;
	##[$80BB]
		mo+1:mo2 LSR 1
	##[$80BC] mo2=0
	;
	If mo>6 Then re=mo-7:mo=7 Else re=re(np)
	;
	If j&1 Then op+re
	If j&2 Then op+mo LSL 3
	If j&4 Then op+re LSL 9
	If j&8 Then op+mo LSL 6
	;
EndIf
;
Select mo(np)
Case $20			;d(an)
	putw
	putrw{gb}:putrw{20}:putrw{Peek.w(?code1)}
	Gosub addpcref
	putrl{c}:c+2:tcl+2
Case $40			;d(an,xi)
	putrw{gb}:putrw{16}
	putrw{Peek.w(?code2)}
	Gosub addpcref
	putrl{c+1}
	putcw{ex(np)}
Case $80			;abs.w
	Goto putw
Case $100		 ;abs.l
	putlong
	putrw{Peek.w(?code3)}
	Gosub addpcref
	putrl{c}
	c+4:tcl+4
Case $200		 ;d(pc)
	putrw{Peek.w(?subcode)}
	Gosub addpcref
	putrl{c}
	putrw{gb}:putrw{20}
	putrw{Peek.w(?code1)}
	Gosub addpcref
	putrl{c}
	c+2:tcl+2
Case $400		 ;d(pc,xi)
	putrw{Peek.w(?subcode)}
	Gosub addpcref
	putrl{c}
	putrw{gb}:putrw{16}
	putrw{Peek.w(?code2)}
	Gosub addpcref
	putrl{c+1}
	putcw{ex(np)}
Case $800		 ;immediate data!
	If sz=3 Then Goto putlong	;long?
	putrw{Peek.w(?code1)}
	Gosub addpcref
	putrl{c}
	c+2:tcl+2
Case $4000
	putcw{ex(np)}
End Select
Next
;
Poke.w tc,op
;
;this dinky loop here will automatically calculate
;any expressions with no labels.
;
For np=0 To np2-1
If no(np)>0
	If no(np)=nc(np)
		putrw{$4e75}	;rts!
		GetReg d0,tr(np):MOVE.l #aserr,d1:JSR execcode
		rl(np)=0:npc(np)=0
	EndIf
EndIf
Next
;
np=np2:Return

.execcode
;
;d0=address of rcode to run
;d1=address of error routine
;
;a0=routines, a1=labels base
;
GetReg a1,labat+SizeOf.label\lval
MOVE.l d0,a2:MOVE.l d1,-(a7)
LEA routines(pc),a0:JSR (a2):ADDQ #4,a7:RTS
;
routines
BRA routine1	;long multiply							;0
BRA routine2	;long divide								;4
BRA rchk1		 ;chk 1...8									;8
BRA rchk2		 ;chk 0...15								 ;12
BRA rchk3		 ;chk -128...+127						;16
BRA rchk4		 ;chk -32768...+32767				;20
BRA rchk5		 ;chk non zero for short bra ;24
BRA routine3	;put in dc.b								;28
;
null:RTS

routine1	;long multiply	;d0=d0*d1
;
MOVEM.l d2-d4,-(a7)
MOVEQ #0,d2:TST.l d0:BPL 'skip:NEG.l d0:MOVEQ #-1,d2
'skip:TST.l d1:BPL 'skip2:NEG.l d1:NOT d2
'skip2
MOVE.l d0,d3:MOVE.l d0,d4
MULU d1,d0:SWAP d3:MULU d1,d3
SWAP d3:ADD.l d3,d0
;
SWAP d1:MULU d1,d4:SWAP d4:ADD.l d4,d0
;
TST d2:BEQ 'skip3:NEG.l d0
'skip3:MOVEM.l (a7)+,d2-d4:RTS

routine2	;long divide		;d0=d0/d1
;
ldivide:MOVE.l d5,-(a7):MOVEQ #31,d5
;
divide:MOVEM.l d2-d4,-(a7):MOVEQ #0,d2
TST.l d1:BEQ 'infinity:BPL 'skip:NEG.l d1:MOVEQ #-1,d2
'skip:TST.l d0:BPL 'skip2:NEG.l d0:NOT d2
'skip2:MOVEQ #0,d3:MOVEQ #0,d4
'loop:LSL.l #1,d4:LSR.l #1,d1:BEQ 'skip6
ROXR.l #1,d3:DBF d5,'loop:BRA 'skip7
'skip6:ROXR.l #1,d3:BEQ 'skip3:CMP.l d3,d0:BCS 'skip3
SUB.l d3,d0:ADDQ #1,d4
'skip3:DBF d5,'loop
'skip7:TST d2:BEQ 'skip4:NEG.l d4
'skip4:MOVE.l d4,d0
'skip5:MOVEM.l (a7)+,d2-d4:MOVE.l (a7)+,d5
RTS

'infinity:;LARGEST POSITIVE NUMBER
MOVE.l #$7fffffff,d0:BRA 'skip5

routine3	;put in dc.b
MOVE.l (a7)+,a3 ;address of string
'loop:MOVE.b (a3)+,d0:BEQ 'skip:MOVE.b d0,(a2)+:BRA 'loop
'skip
EXG a3,d0:ADDQ.l #1,d0:BCLR #0,d0:EXG a3,d0 ;align!
JMP (a3)

rchk1
CMP.l #1,d0:BLT rerr1:CMP.l #8,d0:BGT rerr1:RTS
rerr1:er$="Illegal quick size":BRA dorerr
;
rchk2
CMP.l #16,d0:BCC rerr2:RTS
rerr2:er$="Illegal trap vector":BRA dorerr
;
rchk3
CMP.l #-128,d0:BLT rerr3:CMP.l #127,d0:BGT rerr3:RTS
rerr3:er$="Illegal byte size":BRA dorerr
;
rchk4
CMP.l #-32768,d0:BLT rerr4:CMP.l #32767,d0:BGT rerr4:RTS
rerr4:er$="Illegal word size":BRA dorerr
;
rchk5
TST.l d0:BEQ rerr5:BRA rchk3
rerr5:er$="Illegal branch":BRA dorerr
;
dorerr
MOVE.l (a7)+,errat:ADDQ #4,a7
MOVE.l (a7)+,a0:JMP (a0)

errat:Dc.l 0	;to find out where in RCODE the error was!

addpcref	;a new pc reference in rcode
;
npc(np)+1:If npc(np)>#maxpcref Then Goto aser8
;
pcr(npc(np),np)=rl(np)
;
Return

.tcodes
code1:MOVE.w d0,code1
code2:MOVE.b d0,code2
code3:MOVE.l d0,code3
;
;for addq, subq etc...
;
code4:ANDI.w #7,d0
code5:LSL.w #8,d0
code6:LSL.w #1,d0
code7:ANDI.w #$f1ff,code7
code8:OR.w d0,code8
;
subcode:SUBI.l #0,d0
trcode:ORI.w #$40,d0

getbase:JSR 0(a0)

getareg
If c$<>"a" AND c$<>"d" Then Goto aser4
k=0:If c$="a" Then k=8
c$=ch{}:If NOT rn{c$} Then Goto aser4
k+Asc(c$)-48:c$=ch{}:ex(np) ##[$80CE] k:Return

.fetchd
;
;put rcode into r(np), rl(np).... return no(np) and nc(np)
;
;return mo(np)=mode, re(np)=reg, ex(np)=extension word.
;
no(np)=0:nc(np)=0:mo(np)=0:re(np)=0:ex(np)=0
;
;first, check for simple ones:
;
;dn, an, (an), (an)+, -(an)
;
c$=Mid$(ll$,p+1,1)
If c$="d" AND rn{Mid$(ll$,p+2,1)} AND Mid$(ll$,p+3,1)=","
	mo(np)=1:re(np)=Asc(Mid$(ll$,p+2,1))-48:p+3:Return
EndIf
If c$="d" AND (Mid$(ll$,p+3,1)="/" OR Mid$(ll$,p+3,1)="-")
	;
	getregs
	mo(np)=$4000
	;
	getrlist	;fetch register list
	c$=LCase$(ch{}):Gosub getareg
	;
	getrlist2
	If c$="," Then Return
	If c$<>"-" AND c$<>"/" Then Goto aser4
	If c$="/" Then Goto getrlist
	j=k:c$=LCase$(ch{}):Gosub getareg
	If j<k
		For k2=j To k
		ex(np) ##[$80CE] k2
		Next
	Else
		For k2=k To j
		ex(np) ##[$80CE] k2
		Next
	EndIf
	Goto getrlist2
	;
EndIf
If c$="a" AND rn{Mid$(ll$,p+2,1)} AND Mid$(ll$,p+3,1)=","
	mo(np)=2:re(np)=Asc(Mid$(ll$,p+2,1))-48:p+3:Return
EndIf
If c$="a" AND (Mid$(ll$,p+3,1)="/" OR Mid$(ll$,p+3,1)="-")
	Goto getregs
EndIf
If c$="#" ;immediate?
	p+1:Gosub eval0 ;get it!
	If mo(np)<>$100 Then Goto aser4
	mo(np)=$800:Return
EndIf
c$=Mid$(ll$,p+1,2)
If c$="(a" AND rn{Mid$(ll$,p+3,1)} AND Mid$(ll$,p+4,2)="),"
	mo(np)=4:re(np)=Asc(Mid$(ll$,p+3,1))-48:p+5:Return
EndIf
If c$="(a" AND rn{Mid$(ll$,p+3,1)} AND Mid$(ll$,p+4,3)=")+,"
	mo(np)=8:re(np)=Asc(Mid$(ll$,p+3,1))-48:p+6:Return
EndIf
c$=Mid$(ll$,p+1,3)
If c$="-(a" AND rn{Mid$(ll$,p+4,1)} AND Mid$(ll$,p+5,2)="),"
	mo(np)=$10:re(np)=Asc(Mid$(ll$,p+4,1))-48:p+6:Return
EndIf
If c$="sr," Then mo(np)=$2000:p+3:Return
c$=Mid$(ll$,p+1,4)
If c$="ccr," Then mo(np)=$1000:p+4:Return
If c$="usp," Then mo(np)=$8000:p+4:Return
;
eval0
ra=0
;
eval
Gosub eval2 ;generate that rcode
ra+1
;
eval3
If c$="," ;eol?
	ra-1:mo(np)=$100:Return
EndIf
;
;check for operators!
;
If c$="+" ;plus
	Gosub eval2:op=$d080
	pokeop
	putrw{(ra-1) LSL 9+ra+op}
	Goto eval3
EndIf
;
If c$="-" ;minus
	Gosub eval2:op=$9080:Goto pokeop
EndIf
;
If c$="&" ;AND
	Gosub eval2:op=$c080:Goto pokeop
EndIf
;
If c$="|" ;OR
	Gosub eval2:op=$8080:Goto pokeop
EndIf
;
If c$="*" ;times
	Gosub eval2:ron=0 ;routine number
	makerout
	If ra>1
		j=0:j2=0 ;movem mask - push, pull
		For k=0 To ra-2:j=(j LSR 1)|$8000:j2=(j2 LSL 1)|1:Next
		putrw{$48e7}:putrw{j} ;movem.l reg,-(a7)
		putrw{$2000+ra-1}	 ;move.l regat-1,d0
		putrw{$2200+ra}		 ;move.l regat,d1
	EndIf
	putrw{Peek.w(?getbase)}:putrw{ron}
	If ra>1
		putrw{(ra-1)LSL 9+$2000}	;move.l d0,regat-1
		putrw{$4cdf}:putrw{j2}	;movem.l (a7)+,reg
	EndIf
	Goto eval3
EndIf
;
If c$="/" ;divide
	Gosub eval2:ron=4:Goto makerout
EndIf
;
If c$="<" ;lsl
	Gosub eval2:op=$e1a8
	pokeop2
	putrw{ra LSL 9+ra-1+op}
	Goto eval3
EndIf
;
If c$=">" ;lsr
	Gosub eval2:op=$e0a8:Goto pokeop2
EndIf
;
If c$=")" AND ra>1 Then Return
;
;check for op modes!
;
If c$="." ;abs.w or abs.l
	Select Mid$(ll$,p+1,2)
	Case "w,"
		mo(np)=$80
	Case "l,"
		mo(np)=$100
	Default
		Goto aser4
	End Select
	p+2:Return
EndIf
;
c$=Mid$(ll$,p,2)
;
If c$="(a"
	If NOT rn{Mid$(ll$,p+2,1)} Then Goto aser4
	;
	re(np)=Asc(Mid$(ll$,p+2,1))-48
	;
	If Mid$(ll$,p+3,2)="),"
		mo(np)=$20:p+4:Return
	EndIf
	;
	;must be d(an,xi) !
	;
	If NOT rn{Mid$(ll$,p+5,1)} Then Goto aser4
	ex(np)=(Asc(Mid$(ll$,p+5,1))-48) LSL 12
	Select Mid$(ll$,p+3,2)
	Case ",d"
	Case ",a"
		ex(np)|$8000
	Default
		Goto aser4
	End Select
	;
	If Mid$(ll$,p+6,2)="),"
		p+7
	Else
		Select Mid$(ll$,p+6,4)
		Case ".w),"
		Case ".l),"
			ex(np)|2048 ;.l
		Default
			Goto aser4
		End Select
		p+9
	EndIf
	mo(np)=$40:Return
EndIf
;
c$=Mid$(ll$,p,3)
If c$="(pc"
	If Mid$(ll$,p+3,2)="),"
		mo(np)=$200:p+4:Return
	EndIf
	;
	;must be d(pc,xi) !
	;
	If NOT rn{Mid$(ll$,p+5,1)} Then Goto aser4
	ex(np)=(Asc(Mid$(ll$,p+5,1))-48) LSL 12
	Select Mid$(ll$,p+3,2)
	Case ",d"
	Case ",a"
		ex(np)|$8000
	Default
		Goto aser4
	End Select
	If Mid$(ll$,p+6,2)="),"
		p+7
	Else
		Select Mid$(ll$,p+6,4)
		Case ".w),"
		Case ".l),"
			ex(np)|2048 ;.l
		Default
			Goto aser4
		End Select
		p+9
	EndIf
	mo(np)=$400:Return
EndIf
;
Goto aser4	;what!

.eval2
c$=ch{}
If c$="-" ;negate?
	Gosub eval2
	putrw{ra+$4480}
	Return
EndIf
;
If c$="(" ;bracket?
	If ra>6 Then Goto aser5
	Gosub eval:If c$<>")" Then Goto aser4
	c$=ch{}:ra-1:Return
EndIf
;
no(np)+1	;another operand!
;
If c$="$" ;hex?
	c$=LCase$(ch{}):If NOT he{c$} Then Goto aser4
	va=0
	##[$80BB]
		k=Asc(c$)-48:If k>9 Then k-39
		va=(va LSL 4)+k:c$=LCase$(ch{})
	##[$80BC] NOT he{c$}
	Goto putva
EndIf
;
If nu{c$} ;numeric? (decimal)
	va=0
	##[$80BB]
		va*10+(Asc(c$)-48):c$=ch{}
	##[$80BC] NOT nu{c$}
	putva:Gosub makevaimm
	nc(np)+1:Return
EndIf
;
If c$="%" ;bin?
	c$=ch{}:If c$<>"1" AND c$<>"0" Then Goto aser4
	va=0
	##[$80BB]
		k=Asc(c$)-48:va LSL 1+k
		c$=ch{}
	##[$80BC] c$<>"0" AND c$<>"1"
	Goto putva
EndIf
;
If c$="'" OR c$=Chr$(34)	;chars?
	te$=c$:va=0:c$=ch{}
	While c$<>te$ AND c$>""
		va LSL 8+Asc(c$)
		c$=ch{}
	Wend
	c$=ch{}:Goto putva
EndIf
;
If al{c$} ;alphabetic? (label)
	l$=""
	##[$80BB]
		l$+c$:c$=ch{}
	##[$80BC] NOT an{c$}
	;
	;label name in l$
	;
	Gosub makelab
	;
	nla+1:If nla>#maxlaref Then Goto aser9
	lar(nla)=lo:If *lab\init=0 Then unk+1
	*lab\acc+1:putrw{ra LSL 9+Peek.w(?labcode)}:putrw{lo}
	Return
EndIf
;
If c$="*" ;PC?
	putrw{ra LSL 9+$203c} ;move.l #x,dn
	Gosub addpcref
	putrl{tc}
	c$=ch{}:Return
EndIf
;
Goto aser4

makevaimm
If va>=-128 AND va<=127		 ;can we do a moveq?
	putrw{ra LSL 9+$7000+va&$ff}
Else												;no, do a move.l #x,dn
	putrw{ra LSL 9+$203c}:putrl{va}
EndIf
Return

labcode:MOVE.l 0(a1),d0

qrefcw	;quick refresh just the current window!
;
Gosub oldwin
Boxf 0,wtp,windwp-1,wbp,0
w=cw:Goto reftext

qrefall ;quick refresh of all text in all non current windows
If wo>1
	PushItem lines()
	For w=1 To wo
	If w<>cw
		setbps{2}
		Boxf 0,wt(w)LSL 3,windwp-1,(wt(w)+vl(w))LSL 3-1,0
		setbps{1}
		putcurr{cc(w)}
		Gosub reftext
	EndIf
	Next:PopItem lines()
EndIf
Return

.newlen
;
##[$80CA] lines()
;
;ln=new length
;
d=ln-\ln
;
If d
	;
	pc=\pc+\ln:Gosub movecode
	\ln=ln
	;
	;let's convert this bit to mcode!
	;
	CELSE
	PushItem lines()
	While globfree(lines())
		;
		If \npc
			j=\rcode
			For k=0 To \npc-1
			Poke.l j+\pcref[k],Peek.l(j+\pcref[k])+d
			Next
		EndIf
		;
		\pc+d
		If \lab<>-1
			*lab=labat+\lab:*lab\lval+d
		EndIf
	Wend
	PopItem lines()
	CELSE
	;
	;machine code version...
	;
	GetReg a0,lines()	 ;current item
	GetReg a1,labat		 ;labels base
	GetReg d0,d				 ;difference
	;
	MOVE.l -8(a0),d7	;next of link
	'loop
	MOVE.l d7,a0:MOVE.l (a0),d7:BEQ 'done	;no next, must be end
	LEA SizeOf.aline\npc+8(a0),a2
	MOVE (a2)+,d1:BEQ 'nonpc:SUBQ #1,d1
	MOVE.l SizeOf.aline\rcode+8(a0),a3
	;
	'npcloop
	MOVE (a2)+,d2:ADD.l d0,0(a3,d2):DBF d1,'npcloop
	;
	'nonpc
	ADD.l d0,SizeOf.aline\pc+8(a0)
	;
	MOVE SizeOf.aline\lab+8(a0),d2:CMP #-1,d2:BEQ 'loop
	ADD.l d0,SizeOf.label\lval(a1,d2):BRA 'loop
	;
	'done
	;
	;end of machine code
	;
EndIf
;
Return

blitwait2
BTST #6,$002(a0)
'loop
BTST #6,$002(a0):BNE 'loop:RTS

movecode
;
;move all the code!
;
;we use the blitter to do this.
;
;pc=program counter, d=distance (-1 means up in memory)
;
If d AND pc<codef
	;
	##[$FF48]
	;
	If d<0	;up in memory - asc mode blit!
		;
		GetReg d0,pc							;from (a)
		GetReg d1,pc+d						;to	 (d)
		MOVEQ #0,d3							 ;bltcon 1
		;
		blitmem
		GetReg d2,(codef-pc)LSR 1 ;length (words!)
		;
		MOVE.l #$dff000,a0:BSR blitwait2
		MOVE.l #-1,$044(a0)
		MOVE #$9f0,$040(a0):MOVE d3,$042(a0):CLR.l $064(a0)
		MOVE.l d0,$050(a0):MOVE.l d1,$054(a0)
		;
		MOVEQ #$3f,d3:AND d2,d3:BEQ 'skip:SUB.l d3,d2
		OR #$40,d3:MOVE d3,$058(a0):BSR blitwait2
		;
		'skip
		MOVE #$ffc0,d3:AND d2,d3:BEQ 'skip2
		SUB.l d3,d2:MOVE d3,$058(a0):BSR blitwait2
		;
		'skip2:SWAP d2:BEQ 'done:MOVEQ #0,d3
		'more:MOVE d3,$058(a0):BSR blitwait2
		SUBQ #1,d2:BNE 'more
		'done
		;
	Else		;down in memory - desc mode blit!
		;
		GetReg d0,codef-2
		GetReg d1,codef-2+d
		MOVEQ #2,d3:BRA blitmem
		;
	EndIf
	;
	##[$FF49]
	;
EndIf
;
codef+d
;
Return

.delrcode ;delete any rcode on current line
;
;
##[$80CA] lines()
;
If \rcode
	;
	k=\rcode
	;
	If \tok=4 ;equ? - special case
		;
		Poke.l equs(0)-40,k-8 ;make rcode for equate current item!
		freelast equs():eqs-1
		;
	Else
		;
		j=\rcodel
		;
		GetReg d0,k
		GetReg d1,k+j
		GetReg d2,rcodef
		;
		MOVE.l d0,a0:MOVE.l d1,a1
		'loop
		CMP.l d2,a1:BCC 'done
		MOVE (a1)+,(a0)+:BRA 'loop
		'done
		;
		PushItem lines():locfree lines()
		;
		;bye bye basic...let's convert this bit to mcode too.
		;
		CELSE
		While globfree(lines())
			If \rcode>k Then \rcode-j
		Wend
		CELSE
		;
		GetReg a0,lines() ;current
		GetReg d0,k
		GetReg d1,j			 ;move amount
		;
		MOVEQ #4,d2			 ;token for equate!
		;
		MOVE.l -8(a0),d7
		'loop2
		MOVE.l d7,a0:MOVE.l (a0),d7:BEQ 'done2
		CMP.b SizeOf.aline\tok+8(a0),d2:BEQ 'loop2
		CMP.l SizeOf.aline\rcode+8(a0),d0:BCC 'loop2
		SUB.l d1,SizeOf.aline\rcode+8(a0):BRA 'loop2
		;
		'done2
		;
		;end of machine code
		;
		PopItem lines()
		;
		rcodef-j
		;
	EndIf
	;
	\rcode=0,0
	;
EndIf
;
Return

.dellab ;delete any label stuff on current line
;
##[$80CA] lines()
For k=0 To #maxlaref-1
If \laref[k]<>-1
	*lab=labat+\laref[k]
	*lab\acc-1
	If *lab\init=0 Then unk-1:Gosub labgone
	\laref[k]=-1
EndIf
Next
;
If \lab<>-1 ;label on this line?
	;
	j=\lab:\lab=-1
	*lab=labat+j
	;
	If *lab\flags&2 ;mousable being deleted?
		upmo=-1
	EndIf
	;
	If *lab\init>1			;more than one instance of this label?
		;
		If *lab\init=2 Then dup-1
		;yes, we have to find the other!
		;
		PushItem lines()
		k=locfree(lines())
		While globfree(lines())
			If \lab=j ;here?
				*lab2.label=labat+\lab
				*lab2\lval=\pc
				Goto dlfnd
			EndIf
		Wend
		dlfnd:PopItem lines()
	Else
		;
		*lab\flags=1	;in case it used to be mousable!
		;
		unk+*lab\acc ;deleting an accessed label?
		;
	EndIf
	*lab\init-1:Gosub labgone
EndIf
;
Return

labgone ;has label *lab been zapped?
If *lab\init=0 AND *lab\acc=0
	*lab\flags=0
EndIf
Return

.adjtemp	;relocate temp code to \pc
;
##[$80CA] lines()
For j=0 To 1
For k=1 To npc(j)
Poke.l tr(j)+pcr(k,j),Peek.l(tr(j)+pcr(k,j))-tc+\pc
Next k,j
Return

zapold
##[$80CA] lines()
Gosub dellab		;delete any label stuff
Gosub delrcode	;and any rcode
\npc=0
Return

.linechange
;
Gosub zapold			;delete old references in line!
Gosub linechange2
;
Gosub calctext
w=cw:y=cy:Boxf 0,(y+wt(w))LSL 3,windwp-1,(y+wt(w))LSL 3+7,0
l=cl:Gosub showline
;
If wo>1
	PushItem lines():setbps{2}:Colour 2,0
	For k=1 To wo
	Gosub amihere
	If y
		Boxf 0,y LSL 3,windwp-1,y LSL 3+7,0
		Locate 0,y:Print li$
	EndIf
	Next
	setbps{1}:PopItem lines()
EndIf
Return

linechange2
;
##[$80CA] lines()
;first, work out l$ (label), t (token) and o$ (operands)
;and maybe also r - rcode
;
;suss out fields
;
j=0:ol$=li$
;
While j<3 AND Len(li$)
	j+1
	If j=3 OR Left$(li$,1)=";"
		fld$(j)=li$:li$=""
	Else
		k=Instr(li$," ")
		If k
			fld$(j)=Left$(li$,k-1)
			li$=StripLead$(Mid$(li$,k+1),32)
		Else
			fld$(j)=li$:li$=""
		EndIf
	EndIf
Wend
;
If Left$(fld$(1),1)=";" OR j=0
	;empty line or total comment.
	If j=0 Then fld$(1)=""
	ln=0:Gosub newlen
	\lab=-1,0,0,fld$(1),0:Return
EndIf
;
t=0:r=0:sz=0:li$="":l$=fld$(1)	;label!
;
If l$
	;
	;label error checking!
	;
	If hil+1>=maxlabs Then Gosub eder15:Goto laberr
	If Len(l$)>ltab-1
		Gosub eder13
		laberr:l$="":Goto makeline
	EndIf
	;
	lafl=0
	If Left$(l$,1)="."	;mousable?
		l$=Mid$(l$,2):If l$="" Then Gosub eder14:Goto laberr
		lafl=-1
	EndIf
	;
	If NOT al{Left$(l$,1)} Then Gosub eder14:Goto laberr
	For k=2 To Len(l$)
	If NOT an{LCase$(Mid$(l$,k,1))}
		##[$80BE] For:Gosub eder14:Goto laberr
	EndIf
	Next
	;
	Gosub makelab			 ;init'ed label offset
	;
	\lab=lo:*lab\lval=\pc
	If *lab\init
		Gosub aser1:erf=1
		If *lab\init=1 Then dup+1
		If *lab\flags&2 Then upmo=-1
	Else
		If lafl Then *lab\flags|2:upmo=-1
		unk-*lab\acc	;it was unknown, but now it's not!
	EndIf
	*lab\init+1
EndIf
;
If j>1	;more?
	li$=fld$(2)
	If Left$(li$,1)=";" ;comment in mnenomic area
		li$=Chr$(1)+li$:ln=0:Gosub newlen
	Else
		m$=UCase$(li$)
		k=Instr(m$,".")
		sz=0
		If k ;size specifier?
			sz$=LCase$(Mid$(m$,k+1))
			m$=Left$(m$,k-1)
			Select sz$
			Case "b":sz=1
			Case "w":sz=2
			Case "l":sz=3
			Case "s":sz=4
			Default:Gosub aser3
			End Select
		EndIf
		;
		For k=1 To hit
		If m$=tok$(k) Then ##[$80BE] For:Goto tokfound
		Next
		Gosub aser2:Goto doop
		tokfound	;token found!
		t=k
		If j>2	;operands?
			doop
			li$=fld$(3)
			If Left$(li$,1)<>";"
			EndIf
		Else
			li$=""
		EndIf
		If erf>=0
			ola$=l$
			Gosub assem ;no errors? assemble!
			l$=ola$
		EndIf
	EndIf
Else
	ln=0:Gosub newlen
EndIf
;
;now, make line!
;
makeline
;
If erf<0	;any real errors
	t=0:sz=0:r=0:li$=";*;"+ol$
	If l$ ;label made?
		li$=Chr$(1)+";*;"+StripLead$(Mid$(ol$,Len(l$)+1),32)
	EndIf
EndIf
;
\tok=t,sz,li$
;
Return

.findlab ;find label l$
;
e=-1:*lab=labat-32768
For k=0 To hil
If *lab\flags
	If *lab\name=l$ ;is it here?
		lo=*lab-labat
		##[$80BE] For:Return
	EndIf
Else
	If e<0 Then e=k
EndIf
*lab+SizeOf.label
Next
lo=-1:Return

.makelab	;find label, make if necessary
;
Gosub findlab
If lo=-1		;label not found!
	If e=-1 Then hil+1:e=hil
	*lab=labs(e):lo=*lab-labat
	*lab\flags=1,l$,0,0,0
EndIf
Return

refresh
cl(cw)=cl:Boxf 0,wtp,windwp-1,wbp,0
w=cw:Goto reftext

aser1:er$="DUPLICATE LABEL":Goto err

aser2:er$="MNEMONIC NOT FOUND":Goto err

aser3:er$="ILLEGAL SIZE":Goto err

aser4:er$="SYNTAX ERROR":Goto aserr

aser5:er$="CRACKETS TOO DEEP":Goto aserr

aser6:er$="BAD ADDRESSING MODE":Goto aserr

aser7:er$="ILLEGAL SIZE":Goto aserr

aser8:er$="TOO MANY PC REFERENCES":Goto aserr

aser9:er$="TOO MANY LABEL REFERENCES":Goto aserr

aser10:er$="LABEL NOT FOUND":Goto err

aser11:er$="MUST BE CONSTANT":Goto aserr

aser12:er$="CAN'T LOAD FILE":Goto aserr

aser13:er$="NO LABEL TO EQUATE":Goto aserr

aser14:er$="NO FREE EQUS":Goto aserr

aser15:er$="NO FREE OBJECT CODE":Goto err

aser16:er$="NO FREE RCODE":Goto err

aser17:er$="NO TERMINATING QUOTE":Goto aserr

aser18:er$="INCBIN FILE TOO LARGE":Goto aserr

eder1:er$="ALREADY AT TOP OF FILE":Goto err

eder2:er$="ALREADY AT BOTTOM OF FILE":Goto err

eder3:er$="TOO MANY WINDOWS":Goto err

eder4:er$="CAN'T CLOSE LAST WINDOW":Goto err

eder5:er$="NO FREE LINES":Goto err

eder6:er$="CAN'T OPEN WINDOW":Goto err

eder7:er$="NOT FOUND":Goto err

eder8:er$="NO BLOCK MARKED":Goto err

eder9:er$="CAN'T COPY BLOCK OVER ITSELF":Goto err

eder10:er$="NOT ENOUGH ROOM FOR BLOCK":Goto err

eder11:er$="CAN'T OPEN FILE":Goto err

eder12:er$="NOT A QASM FILE":Goto err

eder13:er$="LABEL TOO LONG":Goto err

eder14:er$="ILLEGAL LABEL CHARACTER":Goto err

eder15:er$="NO FREE LABELS":Goto err

aserr ;error assem'ing line...first, fix up label refs.
;
MOVE.l ssp,a7
;
For k=1 To nla
*lab=labat+lar(k)
If *lab\init=0 Then unk-1
*lab\acc-1:Gosub labgone
Next
;
.err ;er$=error
;
If erf	;already an error there????
	If Len(err$)>80 Then Return
	err$+"/"+er$
Else
	##[$FF8C] Peek.l(##[$80B8] allocst(0))	;beep screen!
	err$="ERROR! : "+er$:erf=-1
EndIf
;
##[$FFAA] wad,-1,&err$
;
Return

amihere	 ;am i in window k?
;
y=Int(vl(k)LSR 1)
If cl>=cl(k)-y AND cl<cl(k)-y+vl(k) AND k<>cw
	y=cl-(cl(k)-y)+wt(k)
Else
	y=0
EndIf
Return

edcurs
Boxf cx LSL 3,cy LSL 3,cx LSL 3+7,cy LSL 3+7,-1
If f AND wo>1
	setbps{2}:For k=1 To wo
	Gosub amihere
	If y
		Boxf cx LSL 3,y LSL 3,cx LSL 3+7,y LSL 3+7,-2
	EndIf
	Next:setbps{1}
EndIf
Return

chkerr
If erf
	##[$FFAA] wad,-1,&sct$:erf=0
	ler$=Mid$(err$,10)
EndIf
Return

.calctext
##[$80CA] lines()
;
li$=""
If \lab<>-1
	*lab=labat+\lab:li$=*lab\name
	If *lab\flags&2 Then li$="."+li$
EndIf
If \tok
	li$=LSet$(li$,ltab)+tok$(\tok)
	If \sz Then li$+"."+sz$(\sz)
	If \ops Then li$=LSet$(li$,otab)
EndIf
m$=\ops
If Left$(m$,1)=Chr$(1) Then li$=LSet$(li$,ltab):m$=Mid$(m$,2)
li$=Left$(li$+m$,windw)
Return

.edsrcline
Gosub calctext
edsrc2
f=-1:l=windw
cy+wt(cw):Gosub edline:cy-wt(cw):Return
;
.edline
;routine to edit a line - cx,cy,li$,f,l
;
;f non 0 for multi window operation. l = max length.
;
alt=0
ed1
Gosub edcurs
ed2
ev=WaitEvent:i$=Inkey$:bq=Qualifier
;
Gosub chkerr
;
If i$>=" " AND i$<Chr$(127) ;ascii?
	;
	If bq AND $f8
		Goto edcurs
	EndIf
	;
	alt=-1
	p$=i$+Mid$(li$,cx+1,l-cx-1):Gosub edprint
	If cx>Len(li$) Then li$+String$(" ",cx-Len(li$))
	li$=Left$(li$,cx)+p$:If cx<l-1 Then cx+1
	Goto ed1
EndIf
;
If i$=Chr$(30)	;curs rite?
	If bq AND 3 ;shifted?
		Gosub edcurs:li$=StripTrail$(li$,32):cx=Len(li$)
		If cx>=l Then cx-1
		Goto ed1
	Else
		crite
		If cx<l-1 Then Gosub edcurs:cx+1:Goto ed1 Else Goto ed2
	EndIf
EndIf
;
If i$=Chr$(31)	;curs left?
	If bq AND 3 ;shift left
		Gosub edcurs:cx=0:Goto ed1
	Else
		If cx Then Gosub edcurs:cx-1:Goto ed1 Else Goto ed2
	EndIf
EndIf
;
If i$=Chr$(8) ;del left?
	If cx=0 Then Goto ed2
	Gosub edcurs
	dodel
	alt=-1
	p$=Mid$(li$,cx+1)+" ":cx-1:Gosub edprint
	li$=Left$(li$,cx)+p$:Goto ed1
EndIf
;
If i$=Chr$(127) Then Gosub edcurs:cx+1:Goto dodel
;
If i$=Chr$(9)
	;
	If cx<ltab Then Gosub edcurs:cx=ltab:Goto ed1
	If cx<otab Then Gosub edcurs:cx=otab:Goto ed1
	Goto crite
	;
EndIf
;
li$=StripTrail$(li$,32)		;get rid of trailing spaces
Goto edcurs

edprint
Colour 1,0:k=0
If f
	If blkt
		If cl>=blkt AND cl<=blkb
			Colour 0,1:k=-1
		EndIf
	EndIf
EndIf
;
Locate cx,cy:Print p$
If f AND wo>1
	setbps{2}
	Colour 2,0:If k Then Colour 0,2
	For k=1 To wo
	Gosub amihere
	If y Then Locate cx,y:Print p$
	Next
	setbps{1}
EndIf
Return

.closewin	 ;close current window
;
Gosub oldwin	;save old stuff
If cw>1
	vl(cw-1)=wt(cw)+vl(cw)-wt(cw-1)
Else
	vl(2)=wt(2)+vl(2)-2:wt(2)=2
EndIf
;
For k=cw To wo-1
	wt(k)=wt(k+1):vl(k)=vl(k+1)
	cl(k)=cl(k+1):cc(k)=cc(k+1)
Next
;
wo-1:If cw>1 Then cw-1
Gosub newwin:Goto refall

.newwindow		;introduce a new window...current item...
;
wox=Int(vl(wo)LSR 1):If wox<3 Then wox=3
;
y=wt(wo)+vl(wo)-(windhp LSR3-wox)
;
If y>0	;other windows need to be adjusted
	For k=1 To wo
	If k>1 Then wt(k)=wt(k-1)+vl(k-1)+1 Else wt(k)=2
	If vl(k)-y>(wox-1)	;OK to change!
		vl(k)-y:y=0
	Else					;change as much as we can!
		y-(vl(k)-wox):vl(k)=wox
	EndIf
	Next
EndIf
;
;now to open new window!
;
wt(wo+1)=wt(wo)+vl(wo)+1
vl(wo+1)=(windhp LSR 3+1.5)-wt(wo+1):wo+1
;
Return

.mouseclick	;mouse has been clicked!
;
mx=EMouseX:my=EMouseY
If mx>=windwp
	;
	If my>=12
		;in mousables area!
		;
		PushItem lines():locfree lines():dcl=0:dcp=0
		;
		While globfree(lines())
			dcl+1
			If \lab<>-1
				*lab=labat+\lab
				If *lab\flags&2
					If my<20
						dcp=getcurr{}:cx=0:Goto finitfind
					EndIf
					my-8
				EndIf
			EndIf
		Wend
		;
		PopItem lines()
		;
	EndIf
	Return
EndIf
;
;on screen...size a window?
;
For w=1 To wo
y=wt(w)LSL 3
If my>=y-4 AND my<y
	;
	;grab top of window...
	;
	##[$80BE] For
	If w>1 Then y=wt(w-1)LSL 3+vl(w-1)LSL 3 Else y=12;min y for top!
	y2=wt(w)LSL 3+vl(w)LSL 3-28 ;max y for top!
	oy=-8
	;
	While Event<>8	;wait for mouse event!
		VWait:my=WMouseY & $fffffff8+4
		If my<y Then my=y Else If my>y2 Then my=y2
		If my<>oy Then Gosub invtop:oy=my:Gosub invtop
	Wend
	;
	Gosub invtop
	;
	y=oy ASR 3+.5:If y>wt(w) Then Gosub wclear
	;
	vl(w)+(wt(w)-y):wt(w)=y
	;
	updatewin
	PushItem lines()
	If w=cw Then Gosub oldwin:Gosub newwin Else putcurr{cc(w)}
	Gosub showbord:Gosub reftext
	PopItem lines():Return
	;
EndIf
y2=y+vl(w)LSL 3
If my>=y2 AND my<y2+4
	;
	;got bottom of window...
	;
	##[$80BE] For
	y=wt(w)LSL 3+24
	If w<wo Then y2=wt(w+1)LSL 3-8 Else y2=windhp+8
	oy=-8
	;
	While Event<>8
		VWait:my=WMouseY & $fffffff8
		If my<y Then my=y Else If my>y2 Then my=y2
		If my<>oy Then Gosub invbot:oy=my:Gosub invbot
	Wend
	;
	Gosub invbot
	;
	y=oy LSR 3-wt(w):If y<vl(w) Then Gosub wclear
	;
	vl(w)=y:Goto updatewin
	;
EndIf
If my>=y AND my<y2
	;
	;click in window! - main current...
	;
	##[$80BE] For:If w=cw Then Return
	;
	Gosub oldwin
	##[$80C9] w,cw:Gosub showbord:Gosub reftext
	w=cw:Gosub newwin:Gosub showbord
	Goto reftext
	;
EndIf
Next:Return

wclear
setbps{2}
Boxf 0,wt(w)LSL 3-4,windwp-1,wt(w) LSL3+vl(w)LSL 3+3,0
setbps{1}
Return

invtop
Boxf 0,oy,windwp-1,oy+1,-1
Line 0,oy+2,0,oy+3,-1
Line windwp-1,oy+2,windwp-1,oy+3,-1
Return

invbot
Boxf 0,oy+2,windwp-1,oy+3,-1
Line 0,oy,0,oy+1,-1
Line windwp-1,oy,windwp-1,oy+1,-1
Return

.oldwin ;cw=old window!
;
cl(cw)=cl:cc(cw)=getcurr{}
;
Return

.fromcurr
cl(wo)=cl(cw):cc(wo)=cc(cw)
Return

.newwin ;cw=new window!
;
cx=0
cl=cl(cw):putcurr{cc(cw)}
cy=Int(vl(cw)LSR 1)			 ;cursor y
wtp=wt(cw)LSL 3
wbp=wtp+vl(cw)LSL 3-1
;
Return

.quit
;
Gosub frees
##[$FE9F] lok,260
;
ClrInt 5:setbps{2}
;
End

.refall ;refresh EVERYTHING!
;
setbps{2}:Boxf 0,12,windwp-1,windhp+11,0
setbps{1}
;
PushItem lines()
For w=1 To wo
	;
	putcurr{cc(w)}
	Gosub showbord
	Gosub reftext
	;
Next
PopItem lines()
;
Return

.reftext ;w=window, current item is middle line.
;
PushItem lines()
;
y=Int(vl(w)LSR 1):l=cl(w):y2=y:l2=l:PushItem lines()
;
While y<vl(w) AND l<=hl+1
	Gosub showline
	y+1:l+1:k=globfree(lines())
Wend
;
y=y2:l=l2:PopItem lines()
;
While y>0 AND l
	y-1:l-1:k=PrevItem(lines())
	Gosub showline
Wend
;
PopItem lines()
Return

showcwline:w=cw
;
.showline
;
;y=Curs Y, w=window, l=src line, current item=just that!
;
##[$80CA] lines()
If w<>cw
	setbps{2}
	If blkt
		If l>=blkt AND l<=blkb
			Boxf 0,(y+wt(w))LSL 3,windwp-1,(y+wt(w))LSL 3+7,2
			Colour 0,2:Goto showline3
		EndIf
	EndIf
	Colour 2,0
	showline3:Gosub showline2
	setbps{1}
	Return
Else
	If blkt
		If l>=blkt AND l<=blkb	;in the block?
			Boxf 0,(y+wt(w))LSL 3,windwp-1,(y+wt(w))LSL 3+7,1
			Colour 0,1:Goto showline2
		EndIf
	EndIf
	Colour 1,0
EndIf
;
showline2
Gosub calctext:Locate 0,y+wt(w)
Print li$
Return

.showbord ;w=window
;
setbps{2}
;
y=wt(w)LSL 3-4
y2=y+vl(w)LSL 3+7
;
c=2:If w=cw Then c=3
;
Boxf 0,y,windwp-1,y+1,c
Line 0,y,0,y+3,c:Line windwp-1,y,windwp-1,y+3,c
;
Boxf 0,y2,windwp-1,y2-1,c
Line 0,y2,0,y2-3,c:Line windwp-1,y2,windwp-1,y2-3,c
;
y=wt(w)LSL 3
Boxf 0,y,windwp-1,y+vl(w)LSL 3-1,0
;
If w=cw
	y+Int(vl(w)LSR 1)LSL 3
	Boxf 0,y,windwp-1,y+7,2
EndIf
;
setbps{1}
Return

.frees
If code Then ##[$FE9F] code,maxcode+codexs:code=0
If rcode Then ##[$FE9F] rcode,maxrcode+rcodexs:rcode=0
If tc Then ##[$FE9F] tc,maxctemp:tc=0
If tr(0) Then ##[$FE9F] tr(0),maxrtemp:tr(0)=0
If tr(1) Then ##[$FE9F] tr(1),maxrtemp:tr(1)=0
Return

.allox
Gosub frees
code=##[$FE9D](maxcode+codexs,omem)
rcode=##[$FE9D](maxrcode+rcodexs,rmem)
tc=##[$FE9D](maxctemp,1)
tr(0)=##[$FE9D](maxrtemp,1)
tr(1)=##[$FE9D](maxrtemp,1)
Return

.new	;erase entire program
;
##[$80CA] lines()
;
codef=code:rcodef=rcode
;
wo=1:cw=1:hl=1		;windows open, current window, highest line
hil=-1						;highest label.
dup=0						 ;number of duplicate labels.
unk=0						 ;number of unknown labels.
ler$=""					 ;last error
erl=0						 ;error line (erc=item)
blkt=0						;block top (or zero for no block)
blkb=0						;block bottom
eqs=0						 ;no equates
upmo=-1					 ;update mousables
;
cl(1)=1:wt(1)=2:vl(1)=windhp LSR 3-1
;
newmem lines()
While globfree(lines())
	MaxLen \ops=0
Wend
ClearList lines():ClearList equs()
;
For k=0 To hl+1
	If AddLast(lines())
		Gosub zeroline:\pc=code
		If k
			If k=hl+1
				\ops=String$("*",ltab-1)+" END OF SOURCE"
			Else
				If k=1 Then cc(1)=getcurr{}
			EndIf
		Else
			\ops=String$("*",ltab-1)+" TOP OF SOURCE"
		EndIf
	EndIf
Next
;
Goto newwin

.zeroline
##[$80CA] lines()
MaxLen \ops=0
\pc=0,0,-1,0,0
\rcode=0,0,0 ;no pcrefs
For j=0 To #maxpcref-1:\pcref[j]=-1:Next
For j=0 To #maxlaref-1:\laref[j]=-1:Next
Return

.edon	 ;turn on editor screen
;
sct$="QUIK-ASM V 1.0 - WRITTEN BY MARK SIBLY IN BLITZ BASIC ]["
allocst 0,0,0,640,windhp+12,2,$8000,sct$,3,2
Green 0,0,4,11
Green 1,0,15,15
Green 2,0,0,8
Green 3,15,15,15
Return

windon	;turn on window
localstat 0,0,0,640,windhp+12,$1900,"",3,0:CatchDosErrs
wad=Peek.l(##[$80B8] localstat(0))	;intution window struct
arrmult 0:ScreensBitMap 0,0:BitMapOutput 0
setbps{1}:Return

init
newlocarr 0,0," PROJECT "
	MenuItem 0,0,0,0,"NEW","Y"
	MenuItem 0,0,0,1,"LOAD","L"
	MenuItem 0,0,0,2,"SAVE","S"
	MenuItem 0,0,0,3,"ABOUT		 ","Z"
	MenuItem 0,0,0,4,"QUIT","Q"

newlocarr 0,1," ASSEMBLER "
	MenuItem 0,0,1,0,"RUN!","X"
	MenuItem 0,0,1,1,"CREATE EXECUTABLE"
	MenuItem 0,0,1,2,"JUMP TO ERROR","J"
	MenuItem 0,0,1,3,"FIND NEXT DUPLICATE LABEL		 ","A"
	MenuItem 0,0,1,4,"RE-PROCESS INCBIN'S","1"
	MenuItem 0,0,1,5,"RE-PROCESS ALL!","2"

	MenuColour 0,1,1,Off ;no create executable yet!

newlocarr 0,2," SOURCE "
	MenuItem 0,0,2,0,"TOP OF SOURCE","T"
	MenuItem 0,0,2,1,"BOTTOM OF SOURCE		 ","B"
	MenuItem 0,0,2,2,"INSERT LINE","I"
	MenuItem 0,0,2,3,"DELETE LINE","D"
	MenuItem 0,0,2,4,"INSERT FROM DISK","J"

newlocarr 0,3," BLOCK "
	MenuItem 0,0,3,0,"MARK","M"
	MenuItem 0,0,3,1,"FORGET","W"
	MenuItem 0,0,3,2,"COPY","V"
	MenuItem 0,0,3,3,"KILL","K"
	MenuItem 0,0,3,4,"SAVE TO DISK		 ","U"

newlocarr 0,4," SEARCH "
	MenuItem 0,0,4,0,"FIND","F"
	MenuItem 0,0,4,1,"FIND NEXT","N"
	MenuItem 0,0,4,2,"FIND PREVIOUS		 ","P"
	MenuItem 0,0,4,3,"REPLACE","R"

newlocarr 0,5," WINDOWS "
	MenuItem 0,0,5,0,"OPEN NEW","O"
	MenuItem 0,0,5,1,"CLOSE CURRENT		 ","C"

newlocarr 0,6," MISC "
	MenuItem 0,0,6,0,"LAST ERROR		 ","E"
	MenuItem 0,0,6,1,"STATS","G"
	MenuItem 0,0,6,2,"CLI","H"

;
;yes no req...
SelectMode 3,0
workstart 1,8,48,0,1," YES "
workstart 1,432,48,0,2," NO "
;
;search...
workstart 2,8,73,0,1," OK "
workstart 2,384,73,0,2," EXIT "
workstart 2,56,73,1,3," LABEL "
workstart 2,128,73,1,4," CASE SENSITIVE "
workstart 2,272,73,1,5," NEW WINDOW "
StringGadget 2,84,25,0,6,80,348
StringGadget 2,84,41,0,7,80,348
;
;stats...
workstart 3,224,112,0,1," OK "

;about...
workstart 4,240,168,0,1," OK "
SelectMode 1,0

;reg dump...
workstart 5,240,160,0,1," OK "

hit=-1
##[$80BB]
	hit+1:Read tok$(hit)
##[$80BC] tok$(hit)=""
;
hit=10:k=?asmtable:j=0
;
##[$80BB]
	l$=""
	##[$80BB]
		p=Peek.b(k):k+1
		If p
			l$+Chr$(p)
		EndIf
	##[$80BC] p=0
	If k&1 Then k+1
	If l$
		hit+1:tok$(hit)=l$:tokp(hit)=j
		##[$80BB]
			tokd(j)=Peek.w(k):k+2:j+1
		##[$80BC] tokd(j-1)=-1
	EndIf
##[$80BC] l$=""
sz$(1)="b":sz$(2)="w":sz$(3)="l":sz$(4)="s"
;
lok=##[$FE9D](260,1) ;for dos lok's
;
Goto allox

Data$ "REM"
Data$ "DC","DS","INCBIN","EQU"
Data$ ""

asmtable
IncBin "asm.bin"
