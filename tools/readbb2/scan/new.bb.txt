; ascii translation of /Users/simon/Google Drive/amiga/w/sega/shit/new.bb
+;
;
;
;	#skipval..
;	start button for player 123 on champsel..
;	headers for ugly things.. ("options")
;	starting grids
;	major shadow glitches
;	collisions

;simons list
;	jcart..


;misc
;	samples
;	smoke/dust
;	sidelines
;	walls

;signside is crap..
;check odd err for info...
; overflow array of anim (fram)
; coll for after warp!!!!!!!




DEFTYPE.q blah

.N



#title=On
#frontend=Off
#race=Off

#maxcar=7
#contcomp=10


#spoon=63

#smfontdest=$e000-41*32	;$e8e0..

#collisions=On

#bars=Off
#maketri=Off

#uscar=5

#a=1
#j=2
#s=3
#n=4

#c=#s

CNIF #c=#j
	If Peek.w($f00004)=Peek.w($f00004)
		End
	EndIf
CEND


Statement Safe{}
	CNIF #c=#j
		MOVE.l #320000,d0
		toplup
			MOVE d0,$f0002a
			SUBQ.l #1,d0
		BGE toplup
	CEND
	CNIF #c=#a
		For cnt.w=0 To 15
			VWait:##[$80BB]:##[$80BC] VPos>50:Poke.w $dff180,cnt
		Next
		MouseWait
	CEND
	CNIF #c=#s
		uphere
		MOVE #$8701,$c00004
		MOVE #$8702,$c00004
		MOVE #$8703,$c00004
		MOVE #$8704,$c00004
		MOVE #$8705,$c00004
		MOVE #$8706,$c00004
		MOVE #$8707,$c00004
		MOVE #$8708,$c00004
		BRA uphere
	CEND

End Statement

Macro showblk
	CNIF (#c=#s) AND (#bars=On)

	CEND
End Macro
Macro showwht
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8701,$c00004
	CEND
End Macro

Macro showred
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8709,$c00004
	CEND
End Macro

Macro showyel
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8708,$c00004
	CEND
End Macro

Macro showgre
	CNIF (#c=#s) AND (#bars=On)
		MOVE #$8707,$c00004
	CEND
End Macro


CNIF #frontend
	#delay1=15
	#delay2=3


	#options=0
	#main=1
	#pause=2
	#change=3
	#finish=4
	#scoreb=5
	#rego=6
	#option=7
	#champsel=8
CEND



CNIF #c=#j
	BSR initjagos
CEND

;Safe{}

Gosub InitOs
Gosub InitMem

Gosub InitVars

CNIF #title
	Gosub SetUpTitle
	Gosub DoTitle
CEND


CNIF #frontend

	Gosub SetUpFront

	Gosub DoFront
CELSE

	lapdir=-1
	bigdone.w=Off
	##[$80BB]
		Gosub GetNewTrack

		Gosub SetUpWorld

		Gosub SkidMain
		mytrk.w=mytrk.w+1
		If mytrk=24 Then mytrk=0
	##[$80BC] bigdone

	End
CEND


.NTypes

NEWTYPE .quadratic ; x=at*t+bt+c :y=dt*t+et+f
	la.q:ma:lb:lc
	ld	:md:le:lf
	lb1 :lb2		 ;boundaries..
	lstraight.w
	lodd1.w:lodd3.w
	langst.q:langadd.q

	ra.q:na:rb:rc
	rd	:nd:re:rf
	rb1 :rb2
	rstraight.w
	rodd1.w:rodd3.w
	rangst.q:rangadd.q
End NEWTYPE:#hquad=SizeOf.quadratic ASR 1

NEWTYPE .xtra
	cai.q:caj:cbi:cbj:midi:midj	; just for fun
	dai	:daj:dbi:dbj:diri:dirj
	swivi:swivj
	centi:centj	;centre or part-circle
	desti:destj	; destination for computer cars..

End NEWTYPE

NEWTYPE .theader
	nmp.l						;8k+ contours NOT CRUNCHED
	blockmap.l			 ;8k crunched
	blocks.l[8]			;40k+ crunched
	info.l
End NEWTYPE

NEWTYPE .view
	mx.q:my:sx:sy:px:py:dx:dy	; for new scrlnslc :-)
End NEWTYPE
NEWTYPE .scr
	scrw.q:scrwh:scrh:scrhh
End NEWTYPE
;	scr.scr\scrw=scrw,scrwh,scrh,scrhh


DEFTYPE.view tempview
CNIF 1=0
	ibm version
	no myview.. sx, sy instead
	no channel.w...
;	CNIF #c=#s NOT in..
	ibmpad.w(10)

CEND


NEWTYPE .segasp					 ;sort points here
	dpth.w
	sy.w:l.w:spdata.w:sx.w:wptr.l	;points to ?mytable+spwid*8

	h0.w:p0.w[3]
	h1.w:p1.w[3]
	h2.w:p2.w[3]
	h3.w:p3.w[3]

;	dpth.w:car.w						;car=0 for car or numsprites for bridge
;	binfo.l[0]							;ptr to bridge info in rom
;	shady.w:rshady						;
;	sx:sy:spdata.w			;bridge
End NEWTYPE


NEWTYPE .newp
	nam1.l:nam2.l:npt.l
	sel.w:ed.w:moved.w:del.w:score.w
	car.w:col.w:pl.w
End NEWTYPE

NEWTYPE .car
		 i.q :	 j:k:	 headi:	 headj:headk:	 movi:	 movj:
	swai.q:swaj:	swaheadi:swaheadj:			swamovi:swamovj

	myview.view
	dir.q[0]:head.w:bdir.w:rot.q:qc:qs:jox.q
	pitch.w:roll:mpitch:mroll:lap.w	:control.w:fr.w
	inair.w:channel.w:idle.w:drop.w:warp.w:pos.w:coll.w

CNIF #c=#s
	shady.w:upd.w:dpth.w:carnum.w
	*segasp.segasp
;	rshady.w:segapad.w
CELSE
	spr1.l:sprnum1.w:spr2.l:sprnum2.w
CEND

	spdat.l:bnk.w:vehicle.w:carcol.l:colowner.w

	nrev.q:rev.q:vel:traction
	lasttime.w:bestlap.w:tottime.w
	accel.q:engfric:bounce:predef.w[0]:newp.w

	op1car.l:op2car.l:fp2car.l

	*towed.car:*hanged.car
	disc.w:oldpos.w	;the funky position thingee..

	q.l			 :; Quadrilateral.. the shadow
	retard.q:steering:
	curdt.w:side.w:top.w
	difi.q:difj.q:swiv		 :; normal for if there's a collision..


	score.w:newscore.w:voldpos.w:newwarps.w:numwarps.w
	gravity.q

CNIF 1=0
		 i.q :	 j:k:	 headi:	 headj:headk:	 movi:	 movj:
	swai.q:swaj:	swaheadi:swaheadj:			swamovi:swamovj

	myview.view
	dir.q[0]:head.w:bdir.w:rot.q:qc:qs:jox.q
	pitch.w:roll:mpitch:mroll:lap.w	:control.w:fr.w
	inair.w:channel.w:idle.w:drop.w:warp.w:pos.w:coll.w

	spr1.l:sprnum1.w:spr2.l

	sprnum2.w[0]:shady.w

	spdat.l:bnk.w:vehicle.w:carcol.l:colowner.w

	nrev.q:rev.q:vel:traction
	lasttime.w:bestlap.w:tottime.w
	accel.q:engfric:bounce:predef.w

	op1car.l:op2car.l:fp2car.l

	*towed.car:*hanged.car
	disc.w:oldpos.w	;the funky position thingee..

	q.l			 :; Quadrilateral.. the shadow
	retard.q:steering:
	curdt.w:side.w:top.w
	difi.q:difj.q:swiv		 :; normal for if there's a collision..


	score.w:newscore.w:voldpos.w:newwarps.w:numwarps.w
	gravity.q

;	space.w[10]
CEND
End NEWTYPE
NEWTYPE .shcar :car.w:h.w	:End NEWTYPE

NEWTYPE .ij		:i.q:j:k:l				:End NEWTYPE
NEWTYPE .frend :lti.w:ltj:rti:rtj:End NEWTYPE
NEWTYPE.guide
	mi.q:mj.q
	di:dj
	li:lj
	ri:rj:dtp.q	;is dtp needed?
End NEWTYPE


NEWTYPE .parse
	fi.q:fj:di:dj:i:j	 ; see below
	diri:dirj					 ; artificial!
	boom.w							; if impact with wall
	norm								; normal.w at point(!) (lookup in cos/sins table)
End NEWTYPE


NEWTYPE .ShadPt
	ri0.q:rj0:ri1:rj1:ri2:rj2:ri3:rj3:ri4:rj4:ri5:rj5
	rx0.w:ry0:rx1:ry1:rx2:ry2:rx3:ry3
End NEWTYPE
NEWTYPE .quad	:v0x.w:v0y:v1x:v1y:v2x:v2y:v3x:v3y:End NEWTYPE


NEWTYPE .phrase:a.l:b.l:End NEWTYPE
NEWTYPE .jbmap

	dwidth.w	 ;0
	dheight.w	;2
	iwidth.w	 ;4
	iheight.w	;6

	dtype.w		;8
	depth.w		;10
	pitch.w		;12

	idata.l		;14
	ilink.l		;18

	xpos.w		 ;22
	ypos.w		 ;24
	iscroll.w	;26
	flags.w		;28

	hscale.b	 ;30
	vscale.b	 ;31

	firstphrase.phrase ;32
	secondphrase.phrase
	thirdphrase.phrase

	pixwidth.w
	realflags.l
	bltwidth.w
	blitflags.l

End NEWTYPE







;NEWTYPE .sprite
;	vp.w
;	size.b:
;	spdata.w
;	hp.w
;End NEWTYPE




.DefTypes
DEFTYPE.w i,j,ipl,pl
DEFTYPE.car *p
DEFTYPE.l sincos
DEFTYPE.l trisize
DEFTYPE.ij bez
DEFTYPE.w pts,pts1,pts2,pts3,pts3
DEFTYPE.parse test

CNIF #c=#j
	DEFTYPE.l bld
	DEFTYPE.jbmap *bmr1,*bmr2,*bmr
	#framecnt=$440		;frames...

CEND

DEFTYPE.ij skidbasememory
DEFTYPE.l skbm



.Consts

	CNIF #c=#s

		DEFTYPE.l myinfo
		;
		; sega megadrive skidmarks code
		;

		; $0000 = 64x32 map	(4096)
		; $1000 = blocks
		; $e000 = sprite pointers (2048)?
		; $f000 = sprites		(640)
		; $f200 = spdata		 (start at #$760)
		; $fc00 = scroll

		#vd=$c00000	;vdp data port
		#cp=$c00004	;vdp control port
		#hv=$c00008	;hv counter

		#wvram=$40000000:#wcram=$c0000000:#wsram=$40000010
		#vram=$0:#cram=$80000000:#vsram=$40000000
		#z80=$a11100:#z80sram=$a00000:#z80dram=$ff8000

		Macro reg #$8000+`1*256:End Macro
		Macro setreg:MOVE.w #$8000+`1*256+`2,cp:End Macro
		Macro setmem:MOVE.l `1,cp:MOVE.w `2,vd:End Macro
		Macro pokemem:MOVE.l `1,cp:Poke.w #vd,`2:End Macro


		NEWTYPE .vp
			sx.w:sy.w:wid:x.w:y.w			 ;top left
		End NEWTYPE

		NEWTYPE.nvp
			y0.w:l0:s0:x0
			y1.w:l1:s1:x1
			y2.w:l2:s2:x2
			y3.w:l3:s3:x3
		End NEWTYPE



CNIF #race
;	#dpth=SizeOf .car\dpth




	Macro car SizeOf .segasp\`1(a2):End Macro





Statement doSortSprites{cars.l}
	MOVE.l d0,d1
	sortem:MOVEQ#0,d0:MOVE.l d1,a1:MOVE.l(a1)+,a2:MOVE (a2),d2
	nxvals:MOVE.l a2,a3:MOVE d2,d3
	wowo:MOVE.l (a1)+,d7:BEQ endlist:MOVE.l d7,a2:MOVE (a2),d2
	CMP d2,d3:BPL nxvals
	flip:MOVEM.l a2-a3,-8(a1):MOVEQ#-1,d0:BRA wowo
	endlist:TST d0:BNE sortem:AsmExit
End Statement


Statement doSegaSprites{cars.l,vp.l,vram.l}
	;
	MOVEM.l a4-a6,-(a7)
	MOVE.l d2,a2:LEA 640(a2),a3													;a2a3=ptrs
	MOVE.l d0,a0:MOVE.l d1,a1:MOVEM.l(a1),d0-d5/a4-a5		;d7
	;
nxtspri:																												 ;a6=?
	MOVE.l (a0)+,a1:CMP.l #0,a1:BEQ dunspri:MOVEM.l 2(a1),d6-d7/a6 ;a4-a6
	MOVEM.l d0-d1,-(a7)
	;
dotl:
	ADD.l d0,d6:ADD d1,d7:MOVEM.l d6-d7,(a2):ADDQ#8,a2
	CMP#448,d7:BCC cltl:CMP#96,d7:BCS cltl
	CMP (a6),d7:BCS dobl:MOVE d7,d0:SUB #288,d0:BCC cltl
	NEG d0:ADD d0,d0:MOVE d6,d1:AND #$3ff,d1:OR mytab(pc,d0),d1
	MOVE d1,-6(a2):BRA dobl:cltl:MOVE#0,-8(a2)
dobl:
	ADD.l d2,d6:ADD d3,d7:MOVEM.l d6-d7,(a3):ADDQ#8,a3
	CMP#448,d7:BCC clbl:CMP#96,d7:BCS clbl
	CMP (a6),d7:BCS dotr:MOVE d7,d0:SUB #288,d0:BCC clbl
	NEG d0:ADD d0,d0:MOVE d6,d1:AND #$3ff,d1:OR mytab(pc,d0),d1
	MOVE d1,-6(a3):BRA dotr:clbl:MOVE#0,-8(a3)
	BRA dotr
	;
	;Dc.w 288-24,16

mytab:Dc.w 0,0,0,0,0,0,0,0
			Dc.w $400,$400,$400,$400,$400,$400,$400,$400
			Dc.w $800,$800,$800,$800,$800,$800,$800,$800
			Dc.w $c00,$c00,$c00,$c00,$c00,$c00,$c00,$c00
	;
dotr:
	ADD.l d4,d6:ADD d5,d7:MOVEM.l d6-d7,(a2):ADDQ#8,a2
	CMP #449,d7:BCC cltr:CMP #288,d7:BCC dobr
	;
	MOVE #288,d0:SUB d7,d0:CMP 2(a6),d0:BPL cltr:AND#$fff8,d0
	MOVE 14(a1,d0),d1:ADD d1,-4(a2):MOVEM mytab2(pc,d0),d0-d1
	SUB d0,-6(a2):ADD d1,-2(a2):BRA dobr:cltr:MOVE#0,-8(a2)
	;
dobr:
	ADD.l a4,d6:ADD a5,d7:MOVEM.l d6-d7,(a3):ADDQ#8,a3
	CMP #449,d7:BCC clbr:CMP #288,d7:BCC donx
	;
	MOVE #288,d0:SUB d7,d0:CMP 2(a6),d0:BPL clbr:AND#$fff8,d0
	MOVE 14(a1,d0),d1:ADD d1,-4(a3):MOVEM mytab2(pc,d0),d0-d1
	SUB d0,-6(a3):ADD d1,-2(a3):BRA donx:clbr:MOVE#0,-8(a3):BRA donx
	;
mytab2:Dc $400,8,0,0,$800,16,0,0,$c00,24,0,0
	;
donx:
	MOVEM.l (a7)+,d0-d1:ADDQ#2,d0:BRA nxtspri
	;
dunspri:
	MOVE.b #0,-5(a2):MOVE.b #0,-5(a3):MOVEM.l (a7)+,a4-a6:AsmExit
	;
	;
End Statement

Statement dodoSegaSprites{cars.l,vp.l,vram.l}
	;
	MOVEM.l a4-a6,-(a7):MOVE.l d2,a2:LEA 640(a2),a3			;a2a3=ptrs
	MOVE.l d0,a0:MOVE.l d1,a1:MOVEM.l(a1),d0-d5/a4-a5		;d7
	;
nxtspri2:																												 ;a6=?
	MOVE.l (a0)+,a1:CMP.l #0,a1:BEQ dunspri2:MOVEM.l 2(a1),d6-d7/a6	;a4-a6
dotl2:
	ADD.l d0,d6:ADD d1,d7:MOVEM.l d6-d7,(a2):ADDQ#8,a2
	CMP#96,d7:BCS cltl2:CMP #448,d7:BCS dobl2:cltl2:MOVE#0,-8(a2)
dobl2:
	ADD.l d2,d6:ADD d3,d7:MOVEM.l d6-d7,(a3):ADDQ#8,a3
	CMP#96,d7:BCS clbl2:CMP #448,d7:BCS donx2:clbl2:MOVE#0,-8(a3)
donx2:
	ADDQ#1,d0:BRA nxtspri2
dunspri2:
	MOVE.b #0,-5(a2):MOVE.b #0,-5(a3):MOVEM.l (a7)+,a4-a6:AsmExit
	;
End Statement



CEND

mytable:
	Dc.w 288-08,0
	Dc.w 288-16,8
	Dc.w 288-24,16
	Dc.w 288-32,24


Statement setupvps{nvbase.l,vpbase.l}
	MOVE.l d0,a0:MOVE.l d1,a1

	MOVEM SizeOf.vp\sx(a1),d2-d3
	MOVE #$80,d0:MOVE.w #$80,d1
	SUB d2,d0:SUB d3,d1:MOVE d0,SizeOf.nvp\x0(a0):MOVE d1,SizeOf.nvp\y0(a0)


	MOVEQ #0,d0:MOVE #120,d1:ADD d2,d0:ADD d3,d1
	LEA SizeOf.vp(a1),a1:MOVEM SizeOf.vp\sx(a1),d2-d3
	SUB d2,d0:SUB d3,d1:MOVE d0,SizeOf.nvp\x1(a0):MOVE d1,SizeOf.nvp\y1(a0)


	MOVE #168,d0:MOVE #-120,d1:ADD d2,d0:ADD d3,d1
	LEA SizeOf.vp(a1),a1:MOVEM SizeOf.vp\sx(a1),d2-d3
	SUB d2,d0:SUB d3,d1:MOVE d0,SizeOf.nvp\x2(a0):MOVE d1,SizeOf.nvp\y2(a0)

	MOVEQ #0,d0:MOVE #120,d1:ADD d2,d0:ADD d3,d1
	LEA SizeOf.vp(a1),a1:MOVEM SizeOf.vp\sx(a1),d2-d3
	SUB d2,d0:SUB d3,d1:MOVE d0,SizeOf.nvp\x3(a0):MOVE d1,SizeOf.nvp\y3(a0)




	AsmExit
End Statement


;		*nv0\x0= $80-vp(0)\sx
;		*nv0\y0= $80-vp(0)\sy
;
;		*nv1\x0=	 0-vp(1)\sx+vp(0)\sx
;		*nv1\y0= 120-vp(1)\sy+vp(0)\sy
;
;		*nv2\x0= 160-vp(2)\sx+vp(1)\sx
;		*nv2\y0=-120-vp(2)\sy+vp(1)\sy
;
;		*nv3\x0=	 0-vp(3)\sx+vp(2)\sx
;		*nv3\y0= 120-vp(3)\sy+vp(2)\sy



;;		*nv1\y0= 120,1,0,0
;;		*nv2\y0=-120,0,0,160
;;		*nv3\y0= 120,1,0,0








	CEND
	CNIF #c=#a
		#sc=2
	CEND





Function .q jsin{a.q} ;0..1=2*pi
Shared sincos.l
	myang=##[$C383](a)ASL 9:ad.l=sincos+((myang&511) ASL 2)
	f=##[$C383](myang):qs=Peek.w(ad	)*(1-f)+Peek.w(ad+4)*f
	Function Return ##[$C583](qs) ASL 1
End Function

Function .q jcos{a.q} ;0..1
Shared sincos.l
	myang=##[$C383](a)ASL 9:ad.l=sincos+((myang&511) ASL 2)
	f=##[$C383](myang):of=1-f
	qc=Peek.w(ad+2)*of+Peek.w(ad+6)*f
	Function Return ##[$C583](qc) ASL 1
End Function


Function.q jsqr{a.q}	;worlds slowest sqr command

	If a=0 Then Function Return 0
	ntry.q=1:try=0

	While ##[$C385](try-ntry)>0.01
		try=ntry:fx=try*try-a
		ntry=try-fx/try*0.5
	Wend
	Function Return try
End Function



Function.l GetMem32{size.l}
	CNIF #c=#j
		MOVEQ #0,d1:ADD.l #16,d0:##[$80C2] $c002

		ADD.l #31,d0
		AND #$ffe0,d0
		AsmExit
	CELSE
		MOVEQ #0,d1:##[$80C2] $c002:AsmExit
	CEND
End Function



Function.l GetMem{size.l}
	MOVEQ #0,d1:##[$80C2] $c002:AsmExit
End Function



NEWTYPE .char
	y.w:t.w:l.w:x.w
	sx.w:sy.w
End NEWTYPE




.InitMem
	skbm.l=&skidbasememory.ij
	sincos.l=?sincos
	sqlu.l=?sqludat
	CNIF #frontend
		fsize.l=?fsize
	CEND

	Dim chars.char(80)

	Dim Pl.car(#maxcar)
	*p0.car=Pl(0):*p1.car=Pl(1):*p2.car=Pl(2):*p3.car=Pl(3):*maxp.car=Pl(#uscar)
	CNIF #uscar>3:*p4.car=Pl(4):*p5.car=Pl(5):CEND

	Dim newp.newp(#maxcar)
	For cnt.w=0 To #uscar
		base.l=&newp(cnt)
;		If cnt&1
;			GetReg a0,base
;			MOVE.l #"AMIK",(a0):MOVE.l #"SHHH",4(a0)
;		Else
;			GetReg a0,base
;			MOVE.l #"AANA",(a0):MOVE.l #"NDDD",4(a0)
;		EndIf
		newp(cnt)\nam1=$52414345
		newp(cnt)\nam2=$52410001+cnt ASL 16
		newp(cnt)\sel=0:newp(cnt)\ed=-32
		newp(cnt)\col=cnt+4
		CNIF #frontend
		newp(cnt)\moved=-1:newp(cnt)\del=#delay2
		CEND
		newp(cnt)\pl=cnt
	Next


	Dim edge.quadratic(70):*e.quadratic=edge(0)
	Dim grot.xtra(70)		 :*g.xtra		 =grot(0)
	Dim mass.guide(137),firstmass.w(70)	;,leadtime.w(70)
	Dim fram.w(64)
	Dim spoon.w(#spoon)

	Dim qsin(63),qcos(63)	 :; look up table for car motion
	For cnt.w=0 To 63
		qcos(cnt)=jcos{cnt/64}
		qsin(cnt)=jsin{cnt/64}
	Next

	*par.parse=test

	CNIF #c<>#s
		Dim shcars.shcar(7):shcar.l=&shcars(0)

	CEND

	Dim tdist.shcar(7) :tdist.l=&tdist(0)

	CNIF #c=#j
		*bmr1.jbmap=GetMem32{SizeOf.jbmap}
		*bmr2.jbmap=GetMem32{SizeOf.jbmap}
		*bmr.jbmap=*bmr1

		CreateBmap{320,200,3,1,0,*bmr1.jbmap}
		CreateBmap{320,200,3,1,0,*bmr2.jbmap}



		MOVE #$ffff,$f00058
		MOVE.l #$418f418f,$f00058

		MOVE #$6c7,$f00028	 ;RGB!

	CEND

	CNIF #c=#a
		allocst 0,4
		ScreensBitMap 0,0
		BitMapOutput 0:Locate 0,0
	CEND




	CNIF #maketri
		trisize.l=(16*17/2)*8;SizeOf.xy
		tritemp.l=$f1cf80-8-trisize;GetMem{dist.l} ;internal dsp ram!
		Gosub InitLatMem
	CEND


	CNIF #c=#s
		*nv0.nvp=GetMem32{SizeOf.nvp}
		*nv1.nvp=*nv0+8
		*nv2.nvp=*nv0+16
		*nv3.nvp=*nv0+24


		*nv0\y0= $80,0,0,$80
		*nv1\y0= 120,0,0,0
		*nv2\y0=-120,1,0,160
		*nv3\y0= 120,0,0,0

		Dim vp.vp(#uscar) ;don't ask me...
		Dim quadverts.w(16)
		buffa1.l=GetMem32{640*4}
		buffb1.l=buffa1+ 640*1
		buffa2.l=buffa1+ 640*2
		buffb2.l=buffa1+ 640*3


;		Dim map.w(63,63)

;		hmmmmmmmmmmm
		Dim map.w(63,72)	;0..72 = 2*64*73= 9344..
		blockmap.l=&map(0,0)
;		blockmap.l=GetMem{9216+64}


		tkptr.l=Peek.l(Peek.l($ff0004))
		tkbin.l=tkptr+1056
;		clist.l=Peek.l($ff0008) ;implied..
;		cars.l=Peek.l(clist+0*4)

; y.w:l.w:d.w:x.w:wptr.l	;points to ?mytable+spwid*8

		Dim spr.segasp(64)
		For ipl=0 To #uscar
			Pl(ipl)\segasp=&spr(ipl)
			CNIF #uscar<4
				dkt.w=(ipl&2)ASR 1 + (ipl&1) ASL 1
			CELSE
				dkt.w=(ipl&1)*3+(ipl&6)ASR 1
			CEND

			spr(ipl)\wptr=?mytable+3*4-4

			spr(ipl)\l=$b05
			CNIF #uscar<4
				spr(ipl)\spdata=$a798+21*dkt+(ipl&1)*$2000
			CELSE
				spr(ipl)\spdata=$a762+21*dkt+(ipl&1)*$2000 ;ASR 1
			CEND

			spr(ipl)\h0=3
			spr(ipl)\h1=6
			spr(ipl)\h2=8
			spr(ipl)\h3=12

			spr(ipl+#uscar+1)\wptr=spr(ipl)\wptr
			spr(ipl+#uscar+1)\l=$a05
			spr(ipl+#uscar+1)\h0=spr(ipl)\h0
			spr(ipl+#uscar+1)\h1=spr(ipl)\h1
			spr(ipl+#uscar+1)\h2=spr(ipl)\h2
			spr(ipl+#uscar+1)\h3=spr(ipl)\h3
			spr(ipl+#uscar+1)\spdata=(spr(ipl)\spdata&$1fff) + $e00c
			spr(ipl+#uscar+1)\dpth=0


;			spr(ipl)\spdata=$a798+18*dkt+(ipl&1)*$2000

;			Pl(ipl)\carsn=$a770+18*ipl +(ipl&1)*$2000	;bit $2000


			If ipl<2
				CNIF #uscar<4
					Pl(ipl)\q=GetMem{672*2}
				CELSE
					Pl(ipl)\q=GetMem{672*3}
				CEND
			Else
				Pl(ipl)\q=Pl(ipl&1)\q+672*(ipl&6) ASR 1
			EndIf

		Next
		Pl(0)\bnk=0
		Pl(1)\bnk=0
		Pl(2)\bnk=1
		Pl(3)\bnk=1
		Pl(4)\bnk=2
		Pl(5)\bnk=3


		Dim cptr.l(64)
		Dim hisview.view(#uscar)


	CEND

	CNIF #frontend
		Dim maxit(10)	;cardinal number..
		maxit(#main)=3
		maxit(#pause)=4
		maxit(#change)=8
		maxit(#finish)=4
		maxit(#scoreb)=0
		maxit(#rego)=0
		maxit(#option)=6
		maxit(#champsel)=4;8
	CEND


Return






;jaguar stuff

CNIF #c=#j
	Macro rungpu
		MOVE.l `1 LSL 2+$f03000,$f02110:MOVE.l #1,$ff8:MOVE.l #1,$f02114
	End Macro

	Macro waitgpu
		'w_g`@:MOVE.l $ff8,d0:BTST #0,d0:BNE 'w_g`@
	End Macro

	Macro rundsp
		MOVE.l `1 LSL 2+$f1b000,$f1a110:MOVE.l #1,$ff0:MOVE.l #1,$f1a114
	End Macro

	Macro waitdsp
		'w_d`@:MOVE.l $ff0,d0:BTST #0,d0:BNE 'w_d`@
	End Macro

	Macro waitblit
		MOVE.l $f02238,d0
		w_b`@
		MOVE.l $f02238,d0:BTST #0,d0:BEQ w_b`@
	End Macro


.JagBlitter

	Include jblit.inc

	Macro bm SizeOf .jbmap\`1(a0):End Macro
	Statement RefrBmap{*bmap.jbmap}
		;
		MOVE.l d0,a0
		;
		MOVE.l !bm{idata},d0:LSR.l#3,d0:MOVEQ#43-32,d2:ASL.l d2,d0
		MOVE.l !bm{ilink},d1:LSR.l#3,d1:MOVE.l d1,d2:LSR.l#8,d2:OR d2,d0
		MOVEQ#24,d2:LSL.ld2,d1
		MOVE !bm{dheight},d2:EXT.l d2:MOVEQ#14,d3:ASL.ld3,d2:OR.ld2,d1
		MOVE !bm{ypos},d2:ASL#3,d2:OR d2,d1:OR !bm{dtype},d1
		MOVEM.l d0-d1,!bm{firstphrase}
		;
		MOVE !bm{iscroll},d0:EXT.l d0:ASL.l#8,d0:ASL.l#3,d0
		OR !bm{flags},d0:ASL.l#6,d0
		MOVE !bm{iwidth},d1:EXT.l d1:ROR.l#4,d1:OR d1,d0
		ROL.l#8,d1:ROL.l#6,d1
		OR!bm{dwidth},d1:ASL.l#3,d1:OR!bm{pitch},d1:ASL.l#3,d1:OR!bm{depth},d1
		ASL.l#8,d1:ASL.l#4,d1:OR !bm{xpos},d1
		MOVEM.l d0-d1,!bm{secondphrase}

		MOVEQ #0,d0:MOVE.w !bm{hscale},d0:ROR.w #8,d0
		MOVE.l d0,!bm{thirdphrase+4}

		;
		AsmExit
		;
	End Statement


	Statement HeadBmap{*bmap1.jbmap}
		ADD.l #32,d0:SWAP d0:MOVE.l d0,$f00020:AsmExit
	End Statement



	Statement BlPoly{*bm.jbmap,dat.l,cols.l}
	Shared bld

		!waitblit
		!waitgpu


		Poke.l $f03f00,dat
		Poke.l $f03f04,cols

		!waitblit
		Poke.l bld		,*bm\idata											;destination
		Poke.l bld+	4,*bm\blitflags;+$10000					;
		Poke.l bld+ $8,##[$C581](*bm\bltwidth,*bm\iheight)	;clip
		Poke.l bld+$10,##[$C581](-24,1)	;step

		!rungpu{0}

	End Statement


	Statement BlRot{*bms.jbmap,*bmd.jbmap,xfac,yfac}	;a2=dest a1=source
	Shared bld

	;	srcxadd=3
	;	desxadd=1

		!waitblit

		Poke.l bld+$24,*bmd\idata					 ;dest
		Poke.l bld+$28,*bmd\blitflags +(1 ASL 16)			;flags
		Poke.l bld+$30,0										;start xy
		temp.l=1 LSL 16										 ;plus one y
		temp=temp+(-*bmd\bltwidth&$ffff)		;minus width
		Poke.l bld+$34,temp


		Poke.l bld,*bms\idata							 ;source
		Poke.l bld+$4,*bms\blitflags +(3 ASL 16)			 ;flags
		Poke.l bld+$8,jin{*bms\bltwidth,*bms\iheight} ;clip x
		Poke.l bld+$c,jin{30,30}										 ;start xy

		pw=*bmd\bltwidth

		xdif=-yfac-pw*xfac
		ydif=xfac-pw*yfac

		Poke.l bld+$10,jin{xdif,ydif}
		Poke.l bld+$14,jfr{xdif,ydif}

		Poke.l bld+$18,0 ;start value! HAH!

		Poke.l bld+$1c,jin{xfac,yfac}
		Poke.l bld+$20,jfr{xfac,yfac}

		Poke.l bld+$3c,(*bmd\iheight ASL 16) + *bmd\bltwidth ;counter

		temp.l=1 + (1 ASL 6)
		temp=temp + (1 ASL 8) +(1 ASL 9)
		temp=temp +(1 ASL 11)
		temp=temp + (1 ASL 23)+ ( 1 ASL 24)
		Poke.l bld+$38,temp


	End Statement


CEND


.IOStuff

	Statement GetJoy{x.l,y.l,butt.l,port.w}
	 CNIF #c=#j

			MOVE.l d0,a0
			MOVE.l d1,a1
			MOVE.l d2,a2
			MOVEQ #0,d3
			MOVEQ #0,d4
			MOVEQ #0,d5

			MOVE #$800e,$f14000:MOVE $f14000,d0
			BTST	#8,d0:BNE notup:ADDQ #1,d4:notup
			BTST	#9,d0:BNE notdo:SUBQ #1,d4:notdo

			BTST #10,d0:BNE notle:ADDQ #1,d3:notle
			BTST #11,d0:BNE notri:SUBQ #1,d3:notri

			MOVE #$800e,$f14000:MOVE $f14002,d0
			BTST #1,d0:BNE notbc:ADDQ #2,d5:notbc
			MOVE #$800b,$f14000:MOVE $f14002,d0
			BTST #1,d0:BNE notba:ADDQ #1,d5:notba


			MOVE.w d3,(a0)
			MOVE.w d4,(a1)
			MOVE.w d5,(a2)
			AsmExit
		CEND
		CNIF #c=#a
			Poke.l x,Joyx(1-port)
			Poke.l y,Joyy(1-port)
			Poke.l butt,Joyb(1-port)
		CEND
		CNIF #c=#s
			temp=##[$C484](port)
			Poke.l x,(temp&4=4)-(temp&8=8)
			Poke.l y,(temp&16=16);JLimit((temp&1=1)-(temp&2=2)+(temp&16=16),-1,1)
			Poke.l butt,0
;		If a AND 1 Then ya=-1
;		If a AND 2 Then ya=1
;		If a AND 4 Then xa=-1:fr=JLimit(fr+1,0,799)		;xa=-1
;		If a AND 8 Then xa=1:fr=JLimit(fr-1,0,799)


		CEND
	End Statement

	Function.w trx{pl.w}
		Shared segjoy.w

		If segjoy=-2 Then pl+4
		If segjoy=-4
			If pl<2 Then pl+4:Else pl+6
		EndIf

		Function Return pl
	End Function


Macro MyVWait
		CNIF #c=#s
;			MOVE #0,$ff0000
			myvbwaitlp`@:TST $ff0000:BPL myvbwaitlp`@:MOVE#0,$ff0000
		CEND
		CNIF #c=#a
			VWait
		CEND
End Macro



	##[$80CA] *p
Statement UpDateNuPlayer{lup.l} ;	 ;,diff.w ,slidmod.w,speedmod.w,accelmod.w
	Shared cvh(),Pl(),newp();*p0,*p7

	For pl=0 To #uscar
		*p.car=Pl(pl)

		If *p\control=#contcomp Then nlup.l=lup+3:Else nlup=lup
		fric=(Peek.b(nlup) ASR 7)*0.98+0.01

		topspeed=(Peek.b(nlup+1)) ASR 4
		acc=topspeed*(1/fric-1)
		initacc=(Peek.b(nlup+2)) ASR 8
		reta=initacc/acc/fric

		\engfric =fric; ASL 6
		\retard	=reta ASR 3;ASL 6
		\steering=Peek.b(lup+6) ASR 5
		\bounce	=0.5
		\gravity =0.5
		\accel	 =acc	ASR 3;ASL 6
		If newp(pl)\nam1=$53415641 Then \accel*1.2

	Next

End Statement


;------------------------------------------------------


CNIF #frontend

Statement addmini{x.q,y.q,t.w,c.w}
	Shared chars(),minioff.w,nxlink.w
	sn.w=minioff+$8000+(c AND 6)ASL 12+(t+t+(c AND 1))*5*4
	x=(x LSL 3)+128:y=(y LSL 3)+124
	ld.w=nxlink+1+$f00
	If nxlink<79 Then chars(nxlink)\y=y,ld,sn,x:ld+1:nxlink+1
	sn+16:If t<6 Then ld.w=nxlink+1+$300 Else ld.w=nxlink+1+$f00
	If nxlink<79 Then chars(nxlink)\y=y,ld,sn,x+32:ld+1:nxlink+1
End Statement


Statement dofence{x.w,y.w,w.w,c.w,p1.w,p2.w}
	Shared map(),numchars.w
	DEFTYPE.w choff,hi,ch,cc,i
	;
	c+1
	If (c&7)=0 Then c-8
	ch=c AND 7:c=c ASR 3:hi=2+c+c
	;
	choff=$8180+numchars
	While ch>2:choff+$2000:ch-2:Wend
	;
	If c=1 Then choff+48
	If c=2 Then choff+144
	;
	For i=0 To w-1
		Select i
			Case 0:		 co=ch*8+0
			Case 1:		 co=ch*8+1
			Case w-1:	 co=ch*8+4
			Case p1-1:	If c<2 Then co=ch*8+3
			Case p1:		co=2
			Case p1+1:	co=1
			Case p2-1:	If c<2 Then co=3
			Case p2:		co=ch*8+2
			Case p2+1:	co=ch*8+1

		End Select
		cc=choff+co*hi:For j=0 To hi-1:map(x,y+j)=cc+j:Next:x+1
	Next
End Statement






home:nxlink.w=0:Return

Statement displaychars{vmem.l}
	Shared chars(),nxlink
	temp.l=0

	!MyVWait
	For cnt.w=0 To nxlink-1
		##[$C489] &chars(cnt),vmem,4:vmem+8
	Next

	##[$C489] &temp,vmem,2:##[$C489] &temp,vmem+4,2
;		SegaDMA buffa1,$fc00,320

End Statement

Function.w translate{ch.w}
	blah.w=-1
	If ch=64 Then ch=95
	If ch=91 Then ch=32 ;AHHAHA
	If ch>64 AND ch<91 Then blah=ch-65
	If ch>47 AND ch<58 Then blah=ch-15
	If ch=46 Then blah=26 ;.
	If ch=43 Then blah=27 ;!
	If ch=63 Then blah=28 ;?
	If ch=58 Then blah=29 ;:
	If ch=95 Then blah=30 ;_
	If ch=40 Then blah=31 ;(
	If ch=41 Then blah=32 ;)
	Function Return blah
End Function

Statement addstring{charbase.l,l.w,x.q,y.q,col.w,hil.l}
	Shared chars(),fsize.l,nxlink.w,fps.w
	If (hil>-1) Then col=13

	x=(x LSL 3)+128:y=(y LSL 3)+124
	sn.w=((col AND 6) ASL 12) + $8182

	If col AND 8 Then big.w=1 Else big=0:sn+4*43:y-2
	If col AND 1 Then sn+8*43 ;was 5

	osn=$c182:If fps&4 Then osn+8*43

	ld.w=nxlink+1+$500:xx=x:ll=nxlink	;was big*$500
	hil+charbase
	For look.l=charbase To charbase+l
		blah.w=translate{Peek.b(look)}
		If blah<0
			x+6*(1+big)
		Else
			If nxlink<79
				oldx=x
				x+Peek.w(fsize+blah+blah+(1-big)*86)+2
				blah ASL 2
				If hil<>look Then blah+sn:Else blah+osn
				chars(nxlink)\y=y,ld,blah,oldx
				ld+1:nxlink+1
			EndIf
		EndIf
	Next
	ww.w=(xx-x) ASR 1
	For i=ll To nxlink-1
		chars(i)\x+ww
	Next
End Statement






	Statement Draw{item.w,col}
	Shared menu.w
	Shared disptyp.w

		y=item*3+7:x=20

		Select menu
			Case #pause	 :base.l=?pausedat
			Case #main		:base.l=?maindat		 :y+10
			Case #finish	:base.l=?finishdat	 :y+10
			Case #change	:base.l=?changedat
			Case #scoreb	:base.l=?scoredat
			Case #rego		:base.l=?scoredat
			Case #option	:base.l=?optiondat
			Case #champsel:base.l=?champseldat
		End Select
		base=base+item ASL 2

		If menu=#option
			If item=3
				base=?displaydat+disptyp ASL 2
			EndIf
		EndIf

		If menu=#champsel
			x=2+(item&1)*19
			y=1+((item&2)*15)ASR 1
			x+9:y+12

		EndIf


		l.w=Peek.l(base+4)-Peek.l(base)-1


		;segaprint{Peek.l(base),l,x,y,col-dum}
		addstring{Peek.l(base),l,x,y,col,-1}



		Goto donedraw



		Event
	.pausedat:Dc.l m00,m01,m02,m03
		m00:Dc.b "CONTINUE"
		m01:Dc.b "QUIT RACE"
		m02:Dc.b "CHANGE SETTINGS"
		m03:Event

	champseldat:Dc.l m10,m11,m12,m13,m14
		m10:Dc.b "RALLY"
		m11:Dc.b "BEACH"
		m12:Dc.b "SNOW"
		m13:Dc.b "RANCH"
		m14:Event

	finishdat:Dc.l m20,m21,m22,m23,m24
		m20:Dc.b "RACE AGAIN"
		m21:Dc.b "NEXT RACE"
		m22:Dc.b "MAIN MENU"
		m23:Dc.b "SETTINGS"
		m24:Event

	changedat:Dc.l m30,m31,m32,m33,m34,m35,m36,m37,m38
		m30:Dc.b "CLASSIC"
		m31:Dc.b "GRUNTY"
		m32:Dc.b "ZIPPY"
		m33:Dc.b "NIPPY"
		m34:Dc.b "SLIPPERY"
		m35:Dc.b "PATHETIC"
		m36:Dc.b "SNEEZY"
		m37:Dc.b "BASHFUL"
		m38:Event


	scoredat:Dc.l m40,m41
		m40:Dc.b "QUIT"
		m41:Event


	maindat:Dc.l m50,m51,m52,m53
		m50:Dc.b "MATCH RACE"
		m51:Dc.b "CHAMPIONSHIP"
		m52:Dc.b "OPTIONS"
		m53:Event

	optiondat:Dc.l m60,m61,m62,m63,m64,m65,m66
		m60:Dc.b "LAPS"
		m61:Dc.b "DIFFICULTY"
		m62:Dc.b "PASSWORD"
		m63:Dc.b "DISPLAY"
		m64:Dc.b "CONTROL"
		m65:Dc.b "EXIT"
		m66:Event


	displaydat:Dc.l m70,m71,m72,m73
		m70:Dc.b "DISPLAY: TEAM"
		m71:Dc.b "DISPLAY: VERT"
		m72:Dc.b "DISPLAY: HORIZ"
		m73:Event


		donedraw
	End Statement


CNIF 1=0
		If menu=#pause
			Select item
				!ft{0,"CONTINUE"}
				!ft{1,"QUIT RACE"}
				!ft{2,"CHANGE SETTINGS"}
			End Select
		EndIf

		If menu=#change
			Select item
				!ft{0,"COMPGRIP"}
				!ft{1,"COMPTOP"}
				!ft{2,"COMPACC"}
				!ft{3,"HUMGRIP"}
				!ft{4,"HUMTOP"}
				!ft{5,"HUMACC"}
				!ft{6,"STEERING"}
				!ft{7,"DONE"}
			End Select
		EndIf



CEND




CEND


CNIF #frontend AND (#c=#s)

.myvint
RTS
			myx=##[$851A](myx+jsin{myfirstang} *3 )
			myfirstang=##[$C384](myfirstang+(myangvel ASR 5),0,1)
			myangvel=(myangvel+##[$8481](myangvel,myfirstang) ASR 4)*0.98

			!pokemem{#wvram+$20020000,myx&15}					 ;horizontal
			!pokemem{#wsram+$00020000,-32*8+myy&15}			 ;vertical
			RTS

;Return




	.SetUpFront
		!MyVWait
		##[$C48A] Off
		!MyVWait
		!MyVWait
		!MyVWait
		inrace.w=Off

		!MyVWait
		MOVE.l a5,$ff0018
		Poke.l $ff001c,?myvint
		Poke.l $ff0020,0	;turn off vint!!!


		numchars=(?fontf-?font)/32
		##[$C489] ?font,#vram+$3000,(?fontf-?font) ASR 1
		##[$C489] ?fence,#vram+$3000+numchars*32,(?miniatf-?fence) ASR 1
		minioff.w=(?miniat-?fence) ASR 5+ 384+numchars
;		SegaTransfer ?miniat,

		selptr.w=minioff+(?miniatf-?miniat) ASR 5
		##[$C489] ?seldat,#vram+selptr*32,(?seldatf-?seldat) ASR 1

		##[$C489] ?checkers,#vram+$ff80,32


		For x=0 To 63:For y=0 To 33; AHHAHAH3
;			If (x&2+y&2)&2 Then map(x,y)=$e7fc:Else map(x,y)=$e7fd
			If (x+y)&1 Then map(x,y)=$e7fd:Else map(x,y)=$e7fc
		Next:Next
		##[$C482] &map(0,0),#vram+8192,2048;4096

		Gosub frontsetreg

		Gosub DoPal
		Gosub redr
		##[$C48A] On
;		!setreg{0,$14}	;split vertical
;		!setreg{10,119}


	Return

.frontsetreg
;		!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
;		!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical
;		!pokemem{#wvram+$10020000,-(vp(2)\sx AND 7)+(64-21)*8} ;horizontal
;		!pokemem{#wsram+$00020000, (vp(2)\sy AND 7)}					 ;vertical
		!pokemem{#wvram+$3c000003,0}					 ;sprite base?
		!pokemem{#wvram+$3c020003,0}
		!pokemem{#wvram+$3c040003,0}
		!pokemem{#wvram+$3c060003,0}


		!pokemem{#wvram+$20000000,0}					 ;horizontal
		!pokemem{#wsram+$00000000,4}					 ;vertical
		!pokemem{#wvram+$20020000,0}					 ;horizontal
		!pokemem{#wsram+$00020000,0};-32*8}			 ;vertical

		!setreg{2,0}		 ;map location=0*8192
		!setreg{4,1}		 ;map location=1*8192
		!setreg{5,$7e}	 ;sprites location=$fc00
		!setreg{11,0}		;scroll=entire screen + no external interupts (8)
		!setreg{12,$89}	;32 cell mode shadows no interlace
		!setreg{13,$8}	 ;hs=$1000
		!setreg{16,1+48} ;64x128 sized map
		!setreg{3,$38}	 ;windowpos= $e000
		!setreg{17,$0};$8a}
		!setreg{18,$0};$ff}
		!setreg{7,0}

Return



Event
	sup0:Dc.b "SUPER SKIDMARKS"
	rac0:Dc.b "RACE RESULTS"
	reg0:Dc.b "REGISTRATION"
	press:Dc.b "PRESS START"
	space:Dc.b "										"
	lptxt:Dc.b"PTS"
	Event


Macro showit
	##[$C482] &map(0,0),#vram,2048;4096
End Macro

	.DoFront


		##[$80BB]
			Gosub dotext


;			!MyVWait
			fps.w+1



			displaychars{$fc00}
			!showit


;			myy=FixAng(myy+jcos{myfirstang} *3 )
;			myx=FixAng(myx+jsin{myfirstang} *3 )
			Poke.q $ff0020,jcos{myfirstang} *3
			Poke.q $ff0024,jsin{myfirstang} *3

			myfirstang=##[$C384](myfirstang+(myangvel ASR 5),0,1)
			myangvel=(myangvel+##[$8481](myangvel,myfirstang) ASR 4)*0.98
;			!pokemem{#wvram+$20020000,myx&15-48}					 ;horizontal
;			!pokemem{#wsram+$00020000,myy&15}			 ;vertical
;		Macro pokemem:MOVE.l `1,cp:Poke.w #vd,`2:End Macro



			newmenu.w=menu.w

			Select menu
				Case #rego:Gosub processlogin
				Default: Gosub processmenu
			End Select

			If menu<>newmenu.w
				If menu=#champsel Then cnt.w=0:Gosub DoPal
				menu.w=newmenu.w:itemsel.w=newsel.w
				If menu=#champsel

					cnt.w=-42:Gosub DoPal
					For cnt.w=0 To 5
						newp(cnt)\sel=Off
					Next

				EndIf
				Gosub redr

			EndIf

		##[$80BC] 1=0
	Return


	processlogin

		If ##[$C484](trx{0})&128	;ARGH
			newmenu=#champsel:newsel=0
		EndIf

		For i=0 To numseg.w
			temp.w= ##[$C484](trx{i})&255
			If newp(i)\moved<0
				If temp<>0 Then newp(i)\moved=newp(i)\del:newp(i)\del=#delay2

			Else
				newp(i)\moved-1
				If temp=0 Then newp(i)\moved=-1:newp(i)\del=#delay1
				temp=0
			EndIf


			delx=(temp&4=4)-(temp&8=8)
			dely=(temp&1=1)-(temp&2=2)

			Select newp(i)\sel
				Case	0:If temp&$ff Then newp(i)\sel=-3:newp(i)\ed=-1:Gosub doone:delx=0
				Case -1
					dely-(temp&16=16)
					If dely<>0 Then newp(i)\col=##[$C384](newp(i)\col+dely,0,8):Gosub DoPal
				Case -3
					dely-(temp&16=16)
					If dely<>0 Then newp(i)\car=##[$C384](newp(i)\car+dely,0,6):Gosub doone
				Case -2:
					If newp(i)\ed>-1
						delx-(temp&16=16)
						temp.w=newp(i)\ed+delx
						If temp>5 OR temp<0
							temp=-1
						Else
							base.l=&newp(i)\nam1+newp(i)\ed
							If dely<>0 OR delx<>0 Then Poke.b base,##[$C384](Peek.b(base)+dely,64,92):Gosub doone

						EndIf
						newp(i)\ed=temp
						delx=0
					Else
						If temp&16
							newp(i)\ed=0
							If newp(i)\nam2&1
								newp(i)\nam1=$40404040
								newp(i)\nam2=$40404040
							EndIf

						EndIf
					EndIf

				Default
			End Select

			If delx<>0 Then newp(i)\sel=##[$C384](newp(i)\sel+delx,-3,0):Gosub doone

		Next

	Return

	processmenu

			temp.w=##[$C484](trx{0}) ;OR SegaJoy(1)
			If menu=#champsel
				delta=itemsel
				If (temp&4) OR (temp&8) Then delta=delta&2+1-delta&1
				If (temp&2) OR (temp&1) Then delta=(delta+2)&3
				delta-itemsel
			Else
				delta=0:delx=0
				If temp&2 Then delta+1
				If temp&1 Then delta-1
				If menu=#option Then delx=(temp&4=4)-(temp&8=8)
			EndIf

			If moved<0
				nu=##[$C384](itemsel+delta,0,maxit(menu))
				If nu<>itemsel
					itemsel=nu
					moved=del
					del=#delay2
				Else
					If temp&$70 ;highlite
						##[$80BB]
							temp.w=##[$C484](trx{0})
						##[$80BC] temp&$70=0
						Gosub hitbutton
					EndIf

				EndIf
				If delx<>0
					If itemsel=3 Then disptyp=##[$C384](disptyp+delx,0,3)
					moved=del
					del=#delay2
				EndIf
			Else
				moved-1
				If (delta=0) AND (delx=0) Then moved=-1:del=#delay1

			EndIf


	Return


Macro yca
	i*5+1
End Macro


	.doone

		If newp(i)\sel
			Select newp(i)\sel
				Case -3:dofence{2,!yca,36,i+8,2,10}
				Case -2:dofence{2,!yca,36,i+8,10,26}
				Case -1:dofence{2,!yca,36,i+8,26,34}
			End Select

			base.l=&newp(i)\nam1
			For cnt.w=0 To 7
				col=i+i+2
				If newp(i)\ed>-1
					If cnt=newp(i)\ed Then col=0
				EndIf

				base+1

			Next
		Else
			dofence{2,!yca,36,15,-4,-11}
		EndIf

	Return


	.dotext
		Gosub home
		For cnt.w=0 To maxit(menu)-1
			If (itemsel=cnt)
				Draw{cnt,6}
			Else
				Draw{cnt,5}
			EndIf
		Next

		If menu=#rego
			For i.w=0 To 5
				If newp(i)\sel
					base.l=&newp(i)\nam1
					addstring{base,5,20,!yca+1,i+8,newp(i)\ed}
					addmini{5,!yca,newp(i)\car,i}
					addmini{29,!yca+0.25,6,6}
				Else
					addstring{?press,10,20,!yca+1,13,-1}
				EndIf
			Next
		EndIf

		If menu=#scoreb
			For i=0 To 5
				addstring{&newp(i)\nam1,5,22,!yca+1,i+8,-1}
				cnt.w=Pl(newp(i)\pl)\pos+49;=1..
				addstring{&cnt+1,0,4,!yca+1,5+8,-1}
				addstring{?lptxt,2,34,!yca,6,-1}

				cnt=newp(i)\score+48
				addstring{&cnt +1,0,34,!yca+2,7,-1}
				addmini{7,!yca,newp(i)\car,i}
			Next
		EndIf

	Return

	.redr
		For x=0 To 63:For y=0 To 31:map(x,y)=257:Next:Next


		Select menu
			Case #rego
				For i=0 To 5
					Gosub doone
				Next
			Case #scoreb
				For i=0 To 5
					dofence{2,!yca,36,i+8,4,11}

				Next
			Default


				Select menu
					Case #main		:roll.w=24
					Case #champsel:roll=18
					Default:	roll.w=20
				End Select

				If menu=#champsel
					base.l=?selmap
					For i.w=0 To 3
						roll.w=2+(i&1)*19
						pitch.w=1+((i&2)*15)ASR 1



						For dy=0 To 11
							For dx=0 To 16
								map(roll+dx,pitch+dy)=Peek.w(base)+selptr+$8000:base+2
							Next
						Next
					Next
				Else

;					dofence {0,1 ,40,16+7,4,35}
					For item.w=0 To maxit(menu)-1
						y=item*3+7
						If menu=#main OR menu=#finish Then y+10
						dofence{20-roll ASR 1,y,roll,0,2,roll-2}
					Next
				EndIf

;				segaprint{?sup0,14,5,2,8}

		End Select

	Return



abcde:Dc.b "ABCDGHIJ"	;even...


	.hitbutton
		If menu=#main
			If itemsel<2 Then newmenu=#rego:newsel=0
			If itemsel=2 Then newmenu=#option:newsel=maxit(#option)-1
		EndIf

		If menu=#option
			If itemsel=maxit(#option)-1 Then newmenu=#main:newsel=2
		EndIf


		If menu=#champsel
			mytrk.w=(itemsel&3)*2

			lapdir=-1:If itemsel<4 Then lapdir=1

			Gosub NextRace:Return
		EndIf

		If menu=#finish
			If itemsel=0 Then Gosub NextRace:Return
			If itemsel=1
				If (mytrk.w&1)=0
					mytrk.w+1
				Else
					mytrk.w+7
				EndIf
				Gosub NextRace:Return
			EndIf
			If itemsel=2 Then newsel=0			:newmenu=#main
			If itemsel=3 Then newsel=skill.w:newmenu=#change
		EndIf


		If menu=#change
			skill.w=itemsel
			newsel=3
			newmenu=#finish
		EndIf

		If menu=#scoreb
			newmenu=#finish:newsel=0
		EndIf



	Return


	.NextRace

		Poke.q $ff0020,0;jcos{myfirstang} *3
		Poke.q $ff0024,0;jsin{myfirstang} *3
;		!setreg{0,$04}

		Gosub GetNewTrack
		Gosub SetUpWorld

		Gosub SkidMain
		menu=#scoreb:itemsel=0
;		menu=#finish:itemsel=0

		newmenu=menu:newsel=itemsel
		Gosub SetUpFront

	Return



CEND


CNIF #title
Statement squiggle{frame.w}
	MOVE d0,d2
	MOVEQ#0,d0:MOVE.l #cp,a1:MOVE.l#vd,a2
	MOVEQ #0,d3
	MOVE d2,d3:LSL.l #8,d3:LSL.l #1,d3
	MOVE #240,d4:SUB d2,d4:MULU d2,d4:LSL.l #8,d4
	MOVEQ #0,d6

nxlin
	wl1:MOVE.w $c00008,d1:LSR#8,d1:CMP d1,d0:BPL wl1


	BSR DoUpper
	ADDQ #1,d0
	wl2:MOVE.w $c00008,d1:LSR#8,d1:CMP d1,d0:BPL wl2
	BSR DoLower

	;
;	MOVE d2,d1:ADD d0,d1:AND#1023,d1:ASL#2,d1:MOVE 0(a0,d1),d1
;	ASR#8,d1:ASR#1,d1

	;
;	MOVE d0,d1:AND#15,d1:OR.w#$8700,d1:MOVE d1,$c00004
	ADDQ#1,d0:CMP #240,d0:BNE nxlin:AsmExit

.DoLower
	CMP d2,d0
		BLE half
		SUB.l d3,d6
		MOVE.l d6,d1:SWAP d1
		MOVE.l d2,d5:ADD d5,d5:SUB d0,d5

		CMP #0,d5
		BLE whole
		SUB d0,d5
		BRA twice



.DoUpper
	MOVE #240,d7:SUB d2,d7

	CMP d7,d0
	BGE half
;		MOVEQ #4,d1


		SUB.l d3,d4
		MOVE.l d4,d1:SWAP d1
		MOVE #480,d5
		SUB d2,d5:SUB d2,d5
		SUB d0,d5


		CMP #31*8,d5
		BGE whole
		SUB d0,d5


twice:MOVEQ #0,d7
			MOVE.l #wvram+$3c000003,(a1):MOVE d1,(a2)
			MOVE.l #wvram+$3c020003,(a1):MOVE d7,(a2)
			MOVE.l #wsram+$00000000,(a1):MOVE d5,(a2)
			MOVE.l #wsram+$00020000,(a1):MOVE #0,(a2)
			RTS

whole:MOVEQ #0,d7
			MOVE.l #wvram+$3c000003,(a1):MOVE d7,(a2)
			MOVE.l #wvram+$3c020003,(a1):MOVE d7,(a2)
			MOVE.l #wsram+$00000000,(a1):MOVE d7,(a2)
			MOVE.l #wsram+$00020000,(a1):MOVE d7,(a2)
			RTS

	half
		MOVEQ #0,d1:MOVE #32*8,d7

		MOVE.l #wvram+$3c000003,(a1):MOVE d1,(a2)
		MOVE.l #wvram+$3c020003,(a1):MOVE d1,(a2)
		MOVE.l #wsram+$00000000,(a1):MOVE d7,(a2)
		MOVE.l #wsram+$00020000,(a1):MOVE d7,(a2)
		RTS

End Statement

Statement squigb{src.l}
	MOVE.l d0,a0

	MOVEQ#0,d0:MOVE.l #cp,a1:MOVE.l#vd,a2

nxlin5
	wl3:MOVE.w $c00008,d1:LSR#8,d1:CMP d1,d0:BPL wl3

 MOVE.w (a0)+,d7

;		MOVE.l #wvram+$3c000003,(a1):MOVE #0,(a2)
;		MOVE.l #wvram+$3c020003,(a1):MOVE #0,(a2)
		MOVE.l #wsram+$00000000,(a1):MOVE d7,(a2)
;		MOVE.l #wsram+$00020000,(a1):MOVE d7,(a2)


	ADDQ#1,d0:CMP #240,d0:BNE nxlin5:AsmExit




End Statement







	NEWTYPE.batman
		numblocks.w
		pal.w[16]
		mmap.w[1200]
		bloks.w[10000]
	End NEWTYPE



	.SetUpTitle

	!setreg{2,0}		 ;map location=0*8192
	!setreg{4,0}		 ;map location=0*8192
	!setreg{5,$78}	 ;sprites location=$f000
	!setreg{11,0}		;scroll=entire screen + no external interupts (8)
	!setreg{12,$89}	;32 cell mode shadows no interlace
	!setreg{13,$3f}	;hs=$fc00
	!setreg{16,1+16}		;64x64 sized map
	!setreg{3,$38}	 ;windowpos= $e000
	!setreg{17,$0};$8a}
	!setreg{18,$0};$ff}
	!setreg{7,0}






		*batman.batman=?titlebdat
		##[$C482] &*batman\pal ,#cram+32,16
		base.l=&*batman\mmap
		For j=0 To 29
			For i=0 To 39
				map(i,j)=Peek.w(base)+$a300:base+2
			Next
		Next
		##[$C489] &*batman\bloks,#vram+$6000,*batman\numblocks*16
		##[$C482] &map(0,0),#vram+4096,2048


		*batman.batman=?titleadat
		##[$C482] &*batman\pal	 ,#cram,16
		base.l=&*batman\mmap
		For j=0 To 29
			For i=0 To 39
				map(i,j)=Peek.w(base)+$8180:base+2
			Next
		Next
		##[$C489] &*batman\bloks,#vram+$3000,*batman\numblocks*16
		##[$C482] &map(0,0),#vram,2048




		##[$80BB]
			!MyVWait{}
;			vbwait2:TST $ff0000:BEQ vbwait2:MOVE#0,$ff0000

			cc3:MOVE $c00004,d0:BTST #3,d0:BNE cc3

			count+1
;			squiggle{JLimit(count,0,300)}:count+3
			squigb{?squigdat+##[$C386](count,0,20)*480}

			If count>100 Then count=-50
			If count<-50 Then count=350
		##[$80BC] 1=0


	Return

	.DoTitle
	Return

CEND








.assignplayers
	reduce.w=0
	For pl.w=0 To #uscar
		*p=Pl(pl):Gosub SetStartCar
		If newp(pl)\sel Then reduce+1
		newp(pl)\pl=-1
		Pl(pl)\newp=-1
	Next

	Select reduce
		Case 0:	screenmode=0 ;???
		Case 1:	screenmode=0
		Case 2:	screenmode=disptyp
		Case 5:	screenmode=3
		Case 6:	screenmode=3
		Default: If disptyp=0 Then screenmode=0:Else screenmode=3
	End Select

	cnt.w=0	;gethumans/comp
	pitch.w=#uscar
	For pl=0 To #uscar
		If newp(pl)\sel
			Pl(cnt)\newp=pl
			Pl(cnt)\control=trx{pl}
			newp(pl)\pl=cnt :cnt+1
		Else
			Pl(pitch)\newp=pl
			Pl(pitch)\control=#contcomp
			newp(pl)\pl=pitch:pitch-1
		EndIf
	Next

	If screenmode=1	;HAHAHAHHA
		##[$80C9] Pl(1)\newp,Pl(2)\newp
		##[$80C9] Pl(1)\control,Pl(2)\control
		newp(Pl(1)\newp)\pl=1
		newp(Pl(2)\newp)\pl=2
	EndIf
Return



.
.
.
.SetUpWorld
	CNIF #c=#s
		Poke.l $ff0020,0
		##[$C48A] Off
	CEND

	lapdir2=lapdir ASL 1:lapdir4=lapdir ASL 2
	cmpacc=-1
	cmpacc7=-0.7
	inrace.w=On


	CNIF #maketri
		myang=64

		qs=0.2:qc=0.2
		delta.l=0

		deadx=2
		deady=0

		Gosub InitTris
	CEND

	CNIF #c=#a
		For dtp=2 To pts3 Step 0.1
			FindLo dtp,skbm
			Point bez\i ASL #sc,bez\j ASL #sc,1
			Point bez\k ASL #sc,bez\l ASL #sc,1
		Next
	CEND


	CNIF #c=#s AND #race
		;
		For cnt.w=0 To 31
			##[$C489] ?blank,#vram+cnt*64*2,64				;2048 bytes
		Next

		For cnt.w=0 To 7
			If *ath.theader\blocks[cnt]<>0
				If Peek.l(*ath\blocks[cnt]+tkbin)<>$43724d21 Then Safe{}
				##[$C387] *ath\blocks[cnt]+tkbin,blockmap.l
				##[$C489] blockmap,#vram+$1000+cnt*8192,4096;Peek.l(*ath\blocks[cnt]+tkbin+6)/2
			Else
				If cnt<3 Then Safe{}
			EndIf
		Next

		##[$C387]	*ath\blockmap+tkbin,blockmap.l
		skidm.l=blockmap+64


		!setreg{2,0}		 ;map location=0*8192
		!setreg{4,0}		 ;map location=0*8192
		!setreg{5,$7e}	 ;sprites location=$fc00
		!setreg{11,0}		;scroll=entire screen + no external interupts (8)
		!setreg{12,$89}	;32 cell mode shadows no interlace
		!setreg{13,$4}	 ;hs=$1000;$fc00
		!setreg{16,1}		;64x32 sized map
		!setreg{3,$38}	 ;windowpos= $e000
		!setreg{17,$0};$8a}
		!setreg{18,$0};$ff}
	CEND






	For dum.w=0 To #spoon:spoon(dum)=-1000:Next

	Gosub assignplayers
	Gosub PlaceNorm ;AHAHAHAHHAHAH



	##[$80CA] *p
	For ipl.w=0 To #maxcar
		*p=Pl(ipl)
		\carnum=newp(\newp)\car
	Next


	CNIF #c=#s
		UpDateNuPlayer{Peek.l(Peek.l($ff0004)+4)+8*skill.w}
	CELSE
		UpDateNuPlayer{?cardiff+8*2}
	CEND



	##[$C489] ?strip,#vram+$fe80,128 ;dinky sprites
	Gosub DoPal


	CNIF #c=#s
		##[$C48A] On
	CEND

	done.w=Off


Return


;testtrack
;IncBin "rat:track.1"



.PlaceCar	;i,j,fr,mycar.w
	CNIF #c=#a
		Circle ii ASL #sc,jj ASL #sc,3,mycar.w+2
	CEND
;	CNIF #c=#s
;		spr(mycar.w+8)\hp=JLimit(116+IOP(*p\myview\sx)-scrx,$40,$1e9)
;		spr(mycar.w+8)\vp=134+IOP(*p\myview\sy)-scry
;
;		spr(mycar)\vp=spr(mycar+8)\vp+*p\shady
;		spr(mycar)\hp=spr(mycar+8)\hp
;
;
;	CEND

Return



Statement SetupMiddle{x.w,l1.l,l2.l,eo.l}

	MOVE.l d1,a0:MOVE.l d2,a1
	EXT.l d0:MOVE.l d0,d5
	MOVE.l #$00800701,d4:ADD.l #$a7f40080,d5
	MOVE.l #$00200001,d6:MOVEQ #3,d7

	nxset
	MOVE.l d4,(a0)+:MOVE.l d5,(a0)+:ADD.l d3,d5:ADD.l #$780000,d4
	MOVE.l d4,(a1)+:MOVE.l d5,(a1)+:SUB.l d3,d5:SUB.l #$780000,d4
	ADD.l d6,d4

	DBRA d7,nxset
	AsmExit
End Statement


.NewScrMode
CNIF #c=#s
	!setreg{0,$04} ;disable vert int

	!MyVWait
	!MyVWait
	!MyVWait
	!MyVWait
	!MyVWait
	##[$C48A] On


	For cnt.w=0 To 31
		##[$C482] ?blank,#vram+cnt*64*2,64				;2048 bytes
	Next




	Select screenmode
		Case 0:scrw=320 :scrh=240	:blkh.w=31
		Case 1:scrw=160 :scrh=240	:blkh.w=31
		Case 2:scrw=320 :scrh=120	:blkh.w=16
		Case 3:scrw=160 :scrh=120	:blkh.w=16
	End Select

	vp(0)\wid=scrw,128		,128
	vp(2)\wid= -24,128+160,128
	vp(1)\wid= -24,128		,128+120
	vp(3)\wid= -24,128+160,128+120


	Select screenmode
		Case 0	;noint..
			SetupMiddle{312,buffa1,buffb1,$00000000}
			SetupMiddle{312,buffa2,buffb2,$00000000}
			Poke.w $ff0014,-1;$9303
		Case 1
			SetupMiddle{152,buffa1,buffb1,$00000000}
			SetupMiddle{152,buffa2,buffb2,$00000000}
			Poke.w $ff0014,-1;$9340
		Case 2
			SetupMiddle{312,buffa1,buffb1,$20000000}
			SetupMiddle{312,buffa2,buffb2,$20000000}
			Poke.w $ff0014,0;$9303
		Case 3
			SetupMiddle{152,buffa1,buffb1,$20000000}
			SetupMiddle{152,buffa2,buffb2,$20000000}
			Poke.w $ff0014,0;$9340
	End Select


;	If screenmode>0
		!setreg{0,$14}	;split vertical
		!setreg{10,119}


;	Else
;		!setreg{0,$04}
;
;	EndIf


	If screenmode>1
		vp(1)\wid=scrw
	Else
		If screenmode=1 Then vp(2)\wid=scrw
	EndIf


	If screenmode=3 Then vp(2)\wid=scrw:vp(3)\wid=scrw



	scrwh=scrw ASR 1:scrhh=scrh ASR 1
	scr.scr\scrw=scrw,scrwh,scrh,scrhh

	warpmode.w=(screenmode=0)
	##[$C48A] Off

	!MyVWait
CEND

Return


	CNIF #c=#s

		#row=192
		Statement animate{map.l,info.l,user.l}

			MOVEM.l a4-a5,-(a7)
			MOVE.l d0,a0:MOVE.l d1,a1:MOVE.l d1,a2:MOVE.l d2,a3
		getfat:
			MOVE (a2)+,d0:BMI dunlist:MOVE (a2)+,d1:MOVEM 0(a1,d1),d4-d7
			MOVE d6,d3:MULU d7,d3:SUBQ#1,d6:SUBQ#1,d7
		wrapuser:
			MOVE (a3),d1:BPL titus:mpos:ADD d5,d1:BMI mpos
			titus:SUB d5,d1:BPL titus:ADD d5,d1:MOVE d1,(a3)+
			MULU d1,d3:ADD d3,d4:LEA 0(a0,d0.w),a4
		nxx:
			MOVE d7,d0:MOVE.l a4,a5:ADDQ#2,a4	;:MOVE d4,(a4)
		nxy:
			MOVE d4,(a5):ADD #row,a5:ADDQ#1,d4:DBRA d0,nxy:DBRA d6,nxx
			BRA getfat
		dunlist:
			MOVEM.l (a7)+,a4-a5
			AsmExit
		End Statement

	CEND






.
.SkidMain
CNIF #race

	Gosub NewScrMode

		!MyVWait
		!MyVWait
		!MyVWait




	MOVE #$8700,$c00004


	Gosub DoSignStart


	##[$80CA] *p
	reduce.w=-1
	For pl=0 To #uscar
		*p=Pl(pl)
		*p\pos=pl	;huh?!
		tdist(pl)\car=pl
		*p\newscore=pl

		If \control=#contcomp
			*p\k=QHite(*p\i,*p\j,skbm)	 :\drop=On
		Else
			*p\k=QHite(*p\i,*p\j,skbm)+16:reduce+1
		EndIf
		##[$C48D] &newp(pl)\nam1,?tagbin,*p\q
		*p\oldpos=-2:*p\disc=32000
		*p\pos=*p\oldpos
	Next





	For pl=0 To #uscar
;		If pl>iscar
;			tdist(Pl(pl)\pos)\h=-10000
;		Else
			Pl(pl)\oldpos=Pl(pl)\pos
			tdist(Pl(pl)\pos)\h=Pl(pl)\newscore
;		EndIf
	Next
	##[$851E] tdist,iscar,*p0



	startrace.w=-1
	starthoppy.w=128*3+30	;three beeps
	hoppy.w=500						;credits
	If reduce.w=-1 Then hoppy=starthoppy ;demo race..


	*newleader.car=*p0:*oldleader.car=*p0:lead.w=0

	fps.w=0:endrace.w=30000-50:nureduce.w=#uscar ;HAHAH
	##[$80BB]


		CNIF #c=#s
			Gosub DoSegaGfx1
		CEND


		fps.w+1
		If fps>endrace Then done=On



;		If hoppy=500 Then Gosub Credits

		If (hoppy>-50) AND (hoppy<499)
			hoppy-1
			If (hoppy AND 127)=18
				dum.w=hoppy ASR 7
;				Select dum
;					Case 0:top$=" GO "
;					Case 1:top$="lmno"
;					Case 2:top$="hijk"
;					Case 3:top$="defg"
;				End Select

;				QPrint top$,Addr BitMap (4),Addr BitMap(2)
;				Use BitMap #signbmap
;				Scroll 32,0,32,16,0,0,4
;				If dum=3 Then Poke.w (Addr Sound(4) +4) , sndper ASL 1
				If dum=0
;					Poke.w (Addr Sound(4) +4) , sndper
					*ap.car=*p0
					For opl.w=0 To #uscar
;						If *ap\predef>-1 Then *ap\idle=On:*ap\disc=30:*ap\warp=0
						*ap\idle=On:*ap\disc=1:*ap\warp=0
						*ap+SizeOf.car
					Next
				EndIf
;				If snd Then Sound 4,6,30,30
			EndIf

			If (hoppy AND 127)=0
				dum.w=(hoppy ASR 7)
				If dum<>0
;					If snd Then Volume 6,8,8
					hoppy=((hoppy) AND $380)-128 +30
				Else
;					If squeal Then LoopSound 5,8,0	;screech!
				EndIf
			EndIf
			If hoppy=-48
;				If snd
;					If squeal
;						LoopSound 0,7,0,0,0 ;funkee!
;					Else
;						LoopSound 0,15,0,0,0,0 ;funkee!
;					EndIf
;				EndIf
			EndIf
		EndIf






		!showred
		!MyVWait
;		MyVWait{}
;		MyVWait{}
;		MyVWait{}
		!showblk


		CNIF #c=#s
			Gosub DoSegaGfx2
		CEND

		CNIF #c=#s
			If ##[$C484](trx{0})&32<>0
				screenmode=(screenmode+1)&3
				Gosub NewScrMode

			EndIf
			If ##[$C484](trx{0})&128>0
				done=On

				##[$80BB]:##[$80BC] ##[$C484](trx{0})&128=0
			EndIf

			If ##[$C484](trx{0})&64<>0
				Pl(0)\carnum=Pl(0)\carnum+1:Pl(0)\upd=3
				If Pl(0)\carnum=6 Then Pl(0)\carnum=0
				Pl(1)\carnum=Pl(1)\carnum+1:Pl(1)\upd=3
				If Pl(1)\carnum=6 Then Pl(1)\carnum=0
				Pl(2)\carnum=Pl(2)\carnum+1:Pl(2)\upd=3
				If Pl(2)\carnum=6 Then Pl(2)\carnum=0
				Pl(3)\carnum=Pl(3)\carnum+1:Pl(3)\upd=3
				If Pl(3)\carnum=6 Then Pl(3)\carnum=0

				##[$80BB]
				##[$80BC] ##[$C484](trx{0})&64=0

			EndIf
		CEND


;			temp=SegaJoy(port)
;			Poke.l x,(temp&4=4)-(temp&8=8)
;			Poke.l y,(temp&16=16);JLimit((temp&1=1)-(temp&2=2)+(temp&16=16),-1,1)
;			Poke.l butt,0

;		GetJoy{&sjoxa.l,&sjoya.l,&sbutt.l,0}
;		GetJoy{&sjoxb.l,&sjoyb.l,&sbutt.l,1}


		myfrcnt.w=(myfrcnt.w+1)&3



		CNIF #collisions
			myfredcar.w=myfredcar+1
			If myfredcar>#uscar Then myfredcar=0
			*p=Pl(myfredcar):Gosub HandleHeader
			pla=myfredcar:*ap=*p
			Gosub Crash
		CEND

		For ipl.w=0 To 3;#uscar
			*p=Pl(ipl):mynxcnt.w=(myfrcnt+ipl)&3


			If (mynxcnt&2)=0
				If *p\control<#contcomp
					temp=##[$C484](*p\control):jox=(temp&4=4)-(temp&8=8):joy=(temp&16=16)
				EndIf
;				Select *p\control
;					Case 0:temp=SegaJoy(0):jox=(temp&4=4)-(temp&8=8):joy=(temp&16=16)
;					Case 1:temp=SegaJoy(1):jox=(temp&4=4)-(temp&8=8):joy=(temp&16=16)
;					Default
;				End Select

				Gosub SpinIt;:Gosub DrawShadow
			EndIf

			If mynxcnt=0
				If *p\control<#contcomp
					temp=##[$C484](*p\control):jox=(temp&4=4)-(temp&8=8):joy=(temp&16=16)
				EndIf
;				Select *p\control
;					Case 0:temp=SegaJoy(*p\control):jox=(temp&4=4)-(temp&8=8):joy=(temp&16=16)
;					Case 1:temp=SegaJoy(1):jox=(temp&4=4)-(temp&8=8):joy=(temp&16=16)
;					Default
;				End Select

				If (\drop=Off) AND (joy<>0)
					\drop=On:reduce-1:
					If reduce.w<0 Then hoppy=starthoppy
				EndIf
				Gosub MoveIndiv
			EndIf
		Next


		CNIF #uscar>3
			Select myfrcnt
				Case 0:*p=*p4:Gosub MoveIndiv
				Case 1:*p=*p4:Gosub SpinIt:*p=*p5:Gosub SpinIt
				Case 2:*p=*p5:Gosub MoveIndiv
				Case 3:*p=*p4:Gosub SpinIt:*p=*p5:Gosub SpinIt

			End Select
		CEND


		CNIF #c=#a
			If Joyb(0)<>0 Then done=On
		CEND


		Gosub CheckWallLatent

		CNIF #c=#s
			MoveAll *p0,#uscar
		CELSE
			MoveAll *p0,shcar,#uscar
		CEND

;		myshadcar=JWrap(myshadcar+1,0,#uscar+1):*p=&Pl(myshadcar):Gosub DrawShadow
;		*p+(SizeOf.car*2):Gosub DrawShadow
;		*p+(SizeOf.car*2):Gosub DrawShadow



		##[$851E] tdist,#uscar,*p0




;		animate {skidm,myinfo.l,&fram(0)}
;		For cnt.w=myfrcnt To 63 Step 4
;			fram(cnt)+1
;		Next
;		EndIf





;		For mycar=0 To #uscar
;			*p=Pl(mycar)
;			Gosub PlaceCar
;		Next
;		*p=Pl(1):mycar=1
;		Gosub PlaceCar



		CNIF #c=#a
			If Joyb(0)<>0 Then done=On:bigdone=On
		CEND

	##[$80BC] done

	CNIF #c=#s
		!setreg{0,$04} ;disable vert int
	CEND

CEND

Return




				tempx=##[$C487](*p\myview\sx)
				tempy=##[$C487](*p\myview\sy)
				spr(cnt)\sx=tempx-12
				spr(cnt)\sy=tempy+6
				spr(cnt)\dpth=*p\dpth

				*v.view=hisview(cnt)

				*v\mx=((tempx-*v\px)ASR 1 +*v\mx)ASR 2:*v\px+*v\mx
				*v\my=((tempy-*v\py)ASR 1 +*v\my)ASR 2:*v\py+*v\my

				vp(cnt)\sx=##[$C386](tempx+##[$C381](tempx-*v\px)-scrwh,0,767.5-scrw)
				vp(cnt)\sy=##[$C386](tempy+##[$C381](tempy-*v\py)-scrhh,0,383.5-scrh)


;	a0=car,a1=spr,a2=view,a3=vp

Statement chunkycar{*car.car,*sp.segasp,*v.view,*u.vp,*scr.scr}
	MOVEM.l a4-a5,-(a7)
	MOVE.l d0,a0:MOVE.l d1,a1:MOVE.l d2,a2:MOVE.l d3,a3:MOVE.l d4,a4

	MOVEQ #uscar,d7
	onemorecar
		LEA SizeOf.segasp*uscar+SizeOf.segasp(a1),a5
		MOVEM.l SizeOf.car\myview+SizeOf.view\sx(a0),d0-d1
		ASR.l #1,d0:ASR.l #1,d1:MOVE.l d0,d2:MOVE.l d1,d3
		ASR.l #1,d2:ASR.l #1,d3:ADD.l d2,d0:ADD.l d3,d1

		MOVE.l d0,d2:MOVE.l d1,d3:SWAP d2:SWAP d3
		SUB #$c,d2:;ADD #6,d3
		SUB #2,d3
		MOVE d2,SizeOf.segasp\sx(a1):MOVE d3,SizeOf.segasp\sy(a1)
		MOVE d2,SizeOf.segasp\sx(a5):MOVE d3,d4:ADD #8,d4
		ADD SizeOf.car\shady(a0),d4

		MOVE d4,SizeOf.segasp\sy(a5)

		MOVE SizeOf.car\dpth(a0),SizeOf.segasp\dpth(a1)


		MOVEM.l SizeOf.view\px(a2),d4/d5
		MOVE.l d0,d2:MOVE.l d1,d3:SUB.l d4,d2:SUB.l d5,d3
		ASR.l #1,d2:ASR.l #1,d3
		ADD.l SizeOf.view\mx(a2),d2:ADD.l SizeOf.view\my(a2),d3
		ASR.l #2,d2:ASR.l #2,d3
		MOVEM.l d2/d3,SizeOf.view\mx(a2)
		ADD.l d2,d4:ADD.l d3,d5
		MOVEM.l d4/d5,SizeOf.view\px(a2)

		SUB.l d0,d4:SUB.l d1,d5:CLR.w d4:CLR.w d5
		SUB.l d4,d0:SUB.l d5,d1
		SUB.l SizeOf.scr\scrwh(a4),d0
		SUB.l SizeOf.scr\scrhh(a4),d1
		MOVE.l #$3000000,d2:SUB.l SizeOf.scr\scrw(a4),d2
		MOVE.l #$1800000,d3:SUB.l SizeOf.scr\scrh(a4),d3

		TST.l d0:BGE godoy1:MOVEQ #0,d0:godoy1
		CMP.l d2,d0:BLE godoy2:MOVE.l d2,d0:godoy2
		TST.l d1:BGE godox1:MOVEQ #0,d1:godox1
		CMP.l d3,d1:BLE godox2:MOVE.l d3,d1:godox2


;					spr(cnt+#uscar+1.w)\sx=spr(cnt)\sx
;					spr(cnt+#uscar+1)\sy=spr(cnt)\sy+*op\shady


		SWAP d0:SWAP d1
		MOVEM.w d0-d1,SizeOf.vp\sx(a3)




		LEA SizeOf.car(a0),a0
		LEA SizeOf.segasp(a1),a1
		LEA SizeOf.view(a2),a2
		LEA SizeOf.vp(a3),a3


		DBRA d7,onemorecar
		MOVEM.l (a7)+,a4/a5
	AsmExit
End Statement



CNIF (#c=#s) AND #race
	.DoSegaGfx1

		If warpmode.w

				mindist.w=*newleader\pos;9
				*dp.car=*newleader
				For cnt.w=0 To #uscar
					*op.car=Pl(cnt)
					If *op\control<#contcomp
						If *op\pos<mindist Then mindist=*op\pos:*dp.car=*op
					EndIf

					spr(cnt)\sx=##[$C487](*op\myview\sx)-12
					spr(cnt)\sy=##[$C487](*op\myview\sy)-2;+6
					spr(cnt)\dpth=*op\dpth
					spr(cnt+#uscar+1)\sx=spr(cnt)\sx
					spr(cnt+#uscar+1)\sy=spr(cnt)\sy+*op\shady+8


				Next
				If *dp.car<>*newleader
					*oldleader=*newleader
					*newleader=*dp:lead.w=16
				EndIf

				lead-1:If lead<0 Then lead=0
				olead=16-lead
				*v.view=hisview(0)

				*v\sx=##[$C487]( (*newleader\myview\sx*olead+*oldleader\myview\sx*lead) ASR 4)
				*v\sy=##[$C487]( (*newleader\myview\sy*olead+*oldleader\myview\sy*lead) ASR 4)

;				*v\sx=spr(cnt)\sx	 ;IOP(MapX(Pl(cnt)\i,Pl(cnt)\j))
;				*v\sy=spr(cnt)\sy+19;IOP(MapY(Pl(cnt)\i,Pl(cnt)\j,skbm))
				*v\mx=((*v\sx-*v\px)ASR 1 +*v\mx)ASR 2:*v\px+*v\mx
				*v\my=((*v\sy-*v\py)ASR 1 +*v\my)ASR 2:*v\py+*v\my
				vp(0)\sx=##[$C386](*v\sx+*v\sx-*v\px-scrwh,0,767.5-scrw)
				vp(0)\sy=##[$C386](*v\sy+*v\sy-*v\py-scrhh,0,383.5-scrh)

;				If startrace>0 Then
				spoon(spptr.w)=tdist(*newleader\pos)\h:spptr=(spptr+1)&#spoon

		Else


			chunkycar{*p0,&spr(0),&hisview(0),&vp(0),&scr.scr}
;			For cnt.w=0 To #uscar
;				chunkycar{&Pl(cnt),&spr(cnt),&hisview(cnt),&vp(cnt),&scr.scr}
;				*p=Pl(cnt )
;
;				tempx=IOP(*p\myview\sx)
;				tempy=IOP(*p\myview\sy)
;				spr(cnt)\sx=tempx-12
;				spr(cnt)\sy=tempy+6
;				spr(cnt)\dpth=*p\dpth
;
;				*v.view=hisview(cnt)
;
;				*v\mx=((tempx-*v\px)ASR 1 +*v\mx)ASR 2:*v\px+*v\mx
;				*v\my=((tempy-*v\py)ASR 1 +*v\my)ASR 2:*v\py+*v\my
;
;				vp(cnt)\sx=JLimit(tempx+JInt(tempx-*v\px)-scrwh,0,767.5-scrw)
;				vp(cnt)\sy=JLimit(tempy+JInt(tempy-*v\py)-scrhh,0,383.5-scrh)
;			Next

		EndIf




		setupvps{*nv0,&vp(0)}



		mptl.l=skidm+##[$C381](vp(0)\sx LSR 3)ASL1+##[$C381](vp(0)\sy LSR 3)*192;96*2

		If (screenmode&1)=1 ;split horizontal..
			mptr.l=skidm+##[$C381](vp(2)\sx LSR 3)ASL1+##[$C381](vp(2)\sy LSR 3)*192;96*2
		EndIf

		If screenmode=2
			 mptla.l=skidm+##[$C381](vp(1)\sx LSR 3)ASL1+##[$C381](vp(1)\sy LSR 3)*96*2
		EndIf
		If screenmode=3
			mptla.l=skidm+##[$C381](vp(1)\sx LSR 3)ASL1+##[$C381](vp(1)\sy LSR 3)*96*2
			mptra.l=skidm+##[$C381](vp(3)\sx LSR 3)ASL1+##[$C381](vp(3)\sy LSR 3)*96*2
		EndIf



;		wwb:CMP.w #$7700,$c00008:BCS wwb
		If (myfrcnt&1)=0
			!showgre
		Else
			!showyel
		EndIf

;		Poke.w $c00004,$870f
;		mymidwait:TST $ff0000:BEQ mymidwait:MOVE#0,$ff0000
;		Poke.w $c00004,$8700
;		!showblk


		doSortSprites{&cptr(0)}
;		doSegaSprites{&cptr(0),*nv0,buffa1+32}
		##[$80C9] buffa1,buffa2
		##[$80C9] buffb1,buffb2
		If (screenmode&1)=0
			dodoSegaSprites{&cptr(0),*nv0,buffa1+32}
		Else
			doSegaSprites{&cptr(0),*nv0,buffa1+32}
		EndIf

;		!showgre



#skipval=215

;		If (myfrcnt&1)=0


			While (Peek.w($c00008)LSR 8)&255<#skipval
;				Poke.w $c00004,$8702+ddcar
				ddcar=ddcar+1
				If ddcar>#uscar Then ddcar=0
				*p=Pl(ddcar)
				If *p\upd&2 Then ##[$C48B] 0,*p\fr,*p\q,*p\bnk ,*p\carnum
				If *p\upd&1 Then Gosub DrawShadow
				*p\upd=Off
			Wend
CNIF 1=0
				If (Peek.w($c00008)LSR 8)&255<#skipval
					##[$C48B] 0,*p2\fr,*p2\q,1	 ,*p2\carnum
					*p=*p2:Gosub DrawShadow
					CNIF #uscar>3
						If (Peek.w($c00008)LSR 8)&255<#skipval
							##[$C48B] 0,*p4\fr,*p4\q,2	 ,*p4\carnum
							*p=*p4:Gosub DrawShadow
						EndIf
					CEND
				EndIf
			EndIf

		Else
			##[$C48B] 0,*p1\fr,*p1\q,0	 ,*p1\carnum
			##[$C48B] 0,*p3\fr,*p3\q,1	 ,*p3\carnum
			CNIF #uscar>4
				##[$C48B] 0,*p5\fr,*p5\q,3	 ,*p5\carnum
			CEND

		EndIf
CEND


;		MOVE #$8709,$c00004
;		cnt.w=(Peek.w($c00008)LSR 8)&255
;		While cnt<200
;
;			cnt.w=(Peek.w($c00008)LSR 8)&255
;		Wend
;		MOVE #$8700,$c00004

	Return


	.DoSegaGfx2



		If (screenmode&1)=0

			!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
			!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical
			##[$C485] mptl,0,41,blkh

			If screenmode=2
				##[$C485] mptla,16*64*2					,41,blkh
			EndIf

		Else

			!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
			!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical
			!pokemem{#wvram+$10020000,-(vp(2)\sx AND 7)+(64-21)*8} ;horizontal
			!pokemem{#wsram+$00020000, (vp(2)\sy AND 7)}					 ;vertical
			##[$C485] mptl,0				,20,blkh
			##[$C485] mptr,(64-22)*2,20,blkh

			If screenmode=3
				##[$C485] mptla,16*64*2					,20,blkh
				##[$C485] mptra,16*64*2+(64-22)*2,20,blkh
			EndIf
		EndIf


		##[$C482] buffa1,$fc00,320


		If myfrcnt&1=0
;			SegaCar 0,Pl(0)\fr,$f300,0	 ,Pl(0)\carnum
		CNIF #uscar<4
			##[$C482]	 *p0\q ,$ec40,768;288
		CELSE
			##[$C482]	 *p0\q ,$ec40,1008
		CEND
;			SegaCar 0,Pl(2)\fr,$f540,1	 ,Pl(2)\carnum
;			SegaDMA	 Pl(2)\q ,$f540,288

		Else
;			SegaCar 0,Pl(1)\fr,$f780,0	 ,Pl(1)\carnum
			CNIF #uscar<4
				##[$C482]	 *p1\q ,$f420,768;288
			CELSE
				##[$C482]	 *p1\q ,$f420,1008
			CEND
;			SegaCar 0,Pl(3)\fr,$f9c0,1	 ,Pl(3)\carnum
;			SegaDMA	 Pl(3)\q ,$f9c0,288

		EndIf




		If screenmode=2
			Poke.w $ff0020, (vp(1)\sy &7)+8;-15*8
			Poke.w $ff0022, (vp(1)\sy &7)+8;-15*8
			Poke.w $ff0024,-(vp(1)\sx &7)
			Poke.w $ff0026,-(vp(1)\sx &7);+(64-21)*8
			Poke.l $ff0028,3	;sprite link
		EndIf
		If screenmode=3
			Poke.w $ff0020, (vp(1)\sy &7)+8;-15*8
			Poke.w $ff0022, (vp(3)\sy &7)+8;-15*8
			Poke.w $ff0024,-(vp(1)\sx &7)
			Poke.w $ff0026,-(vp(3)\sx &7)+(64-21)*8
			Poke.l $ff0028,3	;sprite link
		EndIf


		Poke.l $ff0010,buffb1
	Return
CEND




CNIF #collisions AND #race


Macro bitme					;!hitme{*ap,*sha,cra,*rp<>*ap}
	If `4
;		If (*rp\towed<>`1) AND (`1\towed<>*rp)
			If ##[$8524](`1\i,`1\j,`1\k,*rp\i,*rp\j,*rp\k)
				`3=Off
				If (`1\coll<0)
					If FastCollide(`1,*rp,`2)
						verydum.w=-1
;						chan(*rp\channel)\reqsam=2
;						chan(`1\channel)\reqsam=2
					EndIf
				EndIf
			EndIf
;		EndIf
	EndIf
End Macro


	.Crash
;		If myfrcnt.w>1 Then Return
;		!showred
		crash.w=0

;		pla.w=ipl:*ap.car=*cp0
;		pla=myfrcnt:*ap.car=Pl(pla)
		*rp.car=*p0:cra.w=On

		If *ap\coll<0
;			*sha=Bank(*ap\bnk)+*ap\head*SizeOf.ShadPt
;			*sha.ShadPt=?shadowdat+*ap\head*SizeOf.ShadPt
;				Peek.l($ff000c)+\carnum ASL 12
			*sha.ShadPt=Peek.l($ff000c)+\carnum ASL 12+*ap\head*SizeOf.ShadPt
			For *rp=*p0 To Pl(#uscar) Step SizeOf.car
				If *rp\coll<0
					!bitme{*ap,*sha,cra,*rp<>*ap}
				EndIf

			Next
		EndIf
;		!fixit{cra,*ap}

	Return
CEND


;			If myfrcnt=0
;				*ap.car=Pl(0):*rp.car=Pl(1)
;				Gosub DoMyColl
;			EndIf
;			If myfrcnt=1
;				*ap.car=Pl(1):*rp.car=Pl(0)
;				Gosub DoMyColl
;			EndIf
;
;.DoMyColl
;	*sha.ShadPt=?shadowdat+*ap\head*SizeOf.ShadPt
;	If MyRectsHit(*ap\i,*ap\j,*ap\k,*rp\i,*rp\j,*rp\k)
;		mydumvar.w=FastCollide(*ap,*rp,*sha)
;	EndIf
;Return
;CEND


.DoMainS
;Safe{}





.
.DoMainJ

CNIF #c=#j

	##[$80BB]

		!waitdsp:!waitgpu:!waitblit	;wait till previous frame rendered!

		##[$80C9] *bmr1.jbmap,*bmr2.jbmap
		MOVE framecnt,d7:'wdb:CMP framecnt,d7:BEQ 'wdb

		*bmr=*bmr1

		BlCls{*bmr,0,0};$1010101,$10101010}

		CNIF #bars
			Poke.w $f0002a,0
		CEND

		!waitgpu
		!waitblit
		!waitdsp

;		Poke.l *bmr\idata+320+8,$ffffffff

		Gosub PlaceCarold

		stt=jint{(mytau-2)*2}
		For gt=stt To stt+8 ;Step 2
			t=gt

			If t<2 Then t+pts
;			If t>pts2 Then t-pts
			##[$80C9] mapa.l,mapb.l
			map.l=mapa
			Gosub RotObj

			!waitdsp
			!waitgpu
			!waitblit
			BlCopyMem{tritemp.l,map.l,trisize.l }

			Gosub Draw
		Next

		!waitgpu
		!waitblit

		CNIF #bars
			Poke.l $f0002a,$ffff
			Poke.w $f0002a,mysilly.w:mysilly+1
		CEND

		GetJoy{&jox.l,&joy.l,&butt.l}

	##[$80BC] 1=0
CEND
Return

.
CNIF #c=#a
	.DoMainA


		##[$80BB]
			VWait
		##[$80BC] Joyb(0)<>0


	Return
CEND



Macro calc
	`1=base(t)+(`2+ ((`3)*((`3)+1)) ASR 1)*SizeOf.vec
End Macro

Macro mpc
	`1=map+(`2+ ((`3)*((`3)+1)) ASR 1)*SizeOf.xy
End Macro



.trijunk

NEWTYPE .vec
	x.q:y:z
End NEWTYPE

NEWTYPE.xy
	y.w:x.w
End NEWTYPE

NEWTYPE .tri
	a.w:b.w:c.w
End NEWTYPE


DEFTYPE.vec *dest,*dest2,*dest3,*dest4

.InitTris

CNIF #c=#j
		mapa.l=GetMem32{65536}
		mapb.l=GetMem32{65536}

		colbase.l=GetMem32{32768}
		map.l=mapa

	Dim vec.vec(10000):vecs.l=-1
	Dim tri.tri(10000)
	Dim base.l(100)


		sx1=-10:sy1=-30:sz1=30
		sx2=-10:sy2=30 :sz2=30
		sx3=20:sy3=0	 :sz3=30
		Gosub Generate
		For t=0 To tri.l
			base(t)=GetMem32{SizeOf.vec*9*10/2}
			a=tri(t)\a
			b=tri(t)\b
			c=tri(t)\c
			sx1=vec(a)\x; ASL 6
			sy1=vec(a)\y; ASL 6
			sz1=vec(a)\z; ASL 6
			sx2=vec(b)\x; ASL 6
			sy2=vec(b)\y; ASL 6
			sz2=vec(b)\z; ASL 6
			sx3=vec(c)\x; ASL 6
			sy3=vec(c)\y; ASL 6
			sz3=vec(c)\z; ASL 6
			Gosub Make
		Next

		For h.w=0 To 18*18
			col.q=(##[$8481](h,0)+1)*127+1:temp.l=col&255
			temp=temp ASL 8 + temp
			Poke.l colbase+h ASL 2,temp ASL 16+temp
		Next
	CEND

Return




.Make
CNIF #c=#j
	!calc{*dst.vec,0,0}:xx=sx1:yy=sy1:zz=sz1:Gosub Split
	!calc{*dst.vec,0,8}:xx=sx2:yy=sy2:zz=sz2:Gosub Split
	!calc{*dst.vec,8,8}:xx=sx3:yy=sy3:zz=sz3:Gosub Split

	scal=8:hscal=scal ASR 1
	For cnt.w=0 To 2

		For y=hscal To 7 Step scal
			For x=hscal To y Step scal

				!calc{*dest2,x-hscal,y-hscal}
				!calc{*dest3,x-hscal,y+hscal}
				!calc{*dest4,x+hscal,y+hscal}

				x2=*dest2\x:y2=*dest2\y:z2=*dest2\z
				x3=*dest3\x:y3=*dest3\y:z3=*dest3\z
				x4=*dest4\x:y4=*dest4\y:z4=*dest4\z

				!calc{*dest,x,y}
				!calc{*dest2,x-hscal,y}
				!calc{*dest3,x,y+hscal}

				xx=(x2+x4) ASR 1
				yy=(y2+y4) ASR 1
				zz=(z2+z4) ASR 1
				*dst.vec=*dest:Gosub Split

				xx=(x2+x3) ASR 1
				yy=(y2+y3) ASR 1
				zz=(z2+z3) ASR 1
				*dst.vec=*dest2:Gosub Split

				xx=(x3+x4) ASR 1
				yy=(y3+y4) ASR 1
				zz=(z3+z4) ASR 1
				*dst.vec=*dest3:Gosub Split

			Next
		Next
		scal ASR 1:hscal ASR 1
	Next
CEND

CNIF 1=0
	For y=0 To 8
		For x=0 To y
			!calc{*dst,x,y}
			xx=*dst\x ASR 6
			yy=*dst\y ASR 6
			zz=*dst\z ASR 6
			dist=(10 ASL 2)/jsqr{xx*xx+yy*yy+zz*zz}
;			*dst\x=Sin(ang1)*10;xx*dist
;			*dst\y=Cos(ang1)*10;yy*dist
;			*dst\z=0;zz*dist



			ad.l=?sincos+((x ASL 4) ASL 2)
			qs=Peek.w(ad	)ASR 15
			qc=Peek.w(ad+2)ASR 15

			ad.l=?sincos+(((8-y) ASL 4) ASL 2)
			ps=Peek.w(ad	)ASR 15
			pc=Peek.w(ad+2)ASR 15

			*dst\x=qs*30*pc
			*dst\y=qc*30*pc
			*dst\z=-ps*30
		Next
	Next
CEND
Return


.Split
CNIF #c=#j
	*dst\x=xx
	*dst\y=yy
	*dst\z=zz
CEND

Return




NEWTYPE .vert
	t.q:plus.w
	dx.q:dy.q
End NEWTYPE

CNIF #c=#a
		#sc=2
CEND




.InitLatMem

	Dim latchl(31),latchr(31)
	latls.w=-1:latrs.w=-1
	Dim vert.vert(240)
	vecs.l=-1:tri.l=-1
Return

CNIF #maketri
	Function.w FindNext{mmin,mmax,plus.w}
	Shared vert(),verts
		mptr=-1
		For cnt.w=0 To verts
			If vert(cnt)\plus=plus
				If mmin<vert(cnt)\t
					If vert(cnt)\t<mmax
						mmax=vert(cnt)\t
						mptr=cnt
					EndIf
				EndIf
			EndIf
		Next

		Function Return mptr
	End Function

	Function.w FindNextLat{mmin,mmax,plus.w}
	Shared latchl(),latchr(),latls.w,latrs.w
		mptr=-1
		If plus
			For cnt.w=0 To latls
				If mmin<latchl(cnt)
					If latchl(cnt)<mmax
						mmax=latchl(cnt)
						mptr=cnt
					EndIf
				EndIf
			Next
		Else
			For cnt.w=0 To latrs
				If mmin<latchr(cnt)
					If latchr(cnt)<mmax
						mmax=latchr(cnt)
						mptr=cnt
					EndIf
				EndIf
			Next
		EndIf
		Function Return mptr
	End Function



.Generate

	mystp=1 ASR 5
	For mycnt.w=0 To 7
		plusa.w=(mycnt&1=1)
		plusb.w=(mycnt&2=2)
		If mycnt>3
			tau1=31
			tau2=19
		Else
			tau1=12
			tau2=3
		EndIf

		For k=1 To 5

			FindLo tau1
			If plusa
				x1=bez\i:y1=bez\j
			Else
				x1=bez\k:y1=bez\l
			EndIf
			FindDif tau1+mystp
			If plusa
				dx1=bez\i ASL 5:dy1=bez\j ASL 5
			Else
				dx1=bez\k ASL 5:dy1=bez\l ASL 5
			EndIf

			FindLo tau2
			If plusb
				x2=bez\i:y2=bez\j
			Else
				x2=bez\k:y2=bez\l
			EndIf
			FindDif tau2+mystp
			If plusb
				dx2=bez\i ASL 5:dy2=bez\j ASL 5
			Else
				dx2=bez\k ASL 5:dy2=bez\l ASL 5
			EndIf


			mag1=jsqr{dx1*dx1+dy1*dy1}
			mag2=jsqr{dx2*dx2+dy2*dy2}
			dista=((x1-x2)*dy2-(y1-y2)*dx2)/mag2
			distb=((x2-x1)*dy1-(y2-y1)*dx1)/mag1
			tau1=##[$C384](tau1+dista/mag1,2,pts3)
			tau2=##[$C384](tau2-distb/mag2,2,pts3)
		Next
		If plusa
			latls+1:latchl(latls)=tau1
		Else
			latrs+1:latchr(latrs)=tau1
		EndIf
		If plusb
			latls+1:latchl(latls)=tau2
		Else
			latrs+1:latchr(latrs)=tau2
		EndIf

		FindLo tau1
		If plusa
			Circle bez\i ASL #sc,bez\j ASL #sc,4,3
		Else
			Circle bez\k ASL #sc,bez\l ASL #sc,4,3
		EndIf
		FindLo tau2
		If plusb
			Circle bez\i ASL #sc,bez\j ASL #sc,4,4
		Else
			Circle bez\k ASL #sc,bez\l ASL #sc,4,4
		EndIf

	Next

	basel=latchl(FindNextLat{2,pts4,On})
	baser=latchr(FindNextLat{2,pts4,Off})

	For hiscnt.w=0 To 6

		verts=-1
		plus.w=On
		tau1=basel;
		tau2=latchl(FindNextLat{tau1 ,pts4,plus})	:	basel=tau2
		Gosub FryIt

		plus.w=Off
		tau1=baser;latchr(FindNextLat{baser,pts4,plus})
		tau2=latchr(FindNextLat{tau1 ,pts4,plus})	:	baser=tau2
		Gosub FryIt


		Gosub MakeGoodTri
	Next

Return
CEND



.MakeGoodTri
CNIF #c=#a
	curl=FindNext{1,pts4,On}
	curr=FindNext{1,pts4,Off}
		mminl=vert(curl)\t
		mminr=vert(curr)\t

	FindLo mminl
	x1=bez\i:y1=bez\j
	FindLo mminr
	x2=bez\k:y2=bez\l

	done.w=Off
	##[$80BB]
		Line x1 ASL #sc, y1 ASL #sc, x2 ASL #sc, y2 ASL #sc,5

		mminl=vert(curl)\t
		mminr=vert(curr)\t
		nxl=FindNext{mminl,pts4,On}
		nxr=FindNext{mminr,pts4,Off}

		If (nxl>-1) OR (nxr>-1)

			x3=-200:y3=-200
			x4=-200:y4=-200
			If nxl>-1
				FindLo vert(nxl)\t
				x3=bez\i:y3=bez\j
			EndIf
			If nxr>-1
				FindLo vert(nxr)\t
				x4=bez\k:y4=bez\l
			EndIf


			dx=(x4-x1) ASR 3
			dy=(y4-y1) ASR 3
			distl=dx*dx+dy*dy
			dx=(x3-x2) ASR 3
			dy=(y3-y2) ASR 3
			distr=dx*dx+dy*dy

			If distl>distr
				Line x1 ASL #sc, y1 ASL #sc, x3 ASL #sc, y3 ASL #sc,6
				x1=x3:y1=y3:curl=nxl
			Else
				Line x4 ASL #sc, y4 ASL #sc, x2 ASL #sc, y2 ASL #sc,7
				x2=x4:y2=y4:curr=nxr
			EndIf

		Else
			done.w=On
		EndIf
	##[$80BC] done

CEND

Return


.FryIt
CNIF #c=#a
;	FindLo tau2
;	x1=bez\k ASL #sc:y1=bez\l ASL #sc
;	Line x1,y1,x1+10,y1+10,5

;	verts=0
	verts+1
	vert(verts)\t=tau1
	vert(verts)\plus=plus
	verts+1
	vert(verts)\t=tau2
	vert(verts)\plus=plus



	For pass.w=0 To 1
		dtp=tau1
		dista=0

		While dtp<tau2

			dtp+0.05
			FindLo dtp
				If plus
					newi=bez\i:newj=bez\j
				Else
					newi=bez\k:newj=bez\l
				EndIf
			FindDif dtp+0.02

			If plus
				dx=bez\i*(50*0.05)
				dy=bez\j*(50*0.05)
			Else
				dx=bez\k*(50*0.05)
				dy=bez\l*(50*0.05)
			EndIf

			dista=dista+jsqr{dx*dx+dy*dy}
			If pass=1
				If dista>myidt
CNIF #c=#a
					Point newi ASL #sc,newj ASL #sc,1
CEND
					dista-myidt
					verts+1:vert(verts)\t=dtp
					vert(verts)\plus=plus
				EndIf
			EndIf

		Wend

		If pass=0
			myidt=(dista+0.01)/(##[$C381](dista/7)+1)
		EndIf

	Next
CEND


Return







.PlaceCarold

CNIF #c=#j
;	If butt&1 Then rotang+1
;	If butt&2 Then rotang-1



	mytau=mytau+joy*0.1

	FindLo mytau
	quikx=(bez\i+bez\k) ASR 1
	quiky=(bez\j+bez\l) ASR 1
	FindDif mytau+1



	fredang=Angle((bez\i+bez\k) ASL 4,(bez\j+bez\l) ASL 4) ASR 16
	qs=-jsin{fredang} ASR 2
	qc=-jcos{fredang} ASR 2
;	rotang*0.98
;	fredang=fredang+rotang



;	ad.l=?sincos+((fredang&1023) ASL 2)
;	f=jfrac{fredang}:of=1-f
;	qs=Peek.w(ad	)*of+Peek.w(ad+4)*f
;	qc=Peek.w(ad+2)*of+Peek.w(ad+6)*f
CEND

Return



.RotObj


CNIF 1=0
	myscal=2;1.3
	qqs=jext{qs}*2*myscal
	qqc=jext{qc}*2*myscal
	*dest=base(0)
	*mp.xy=map

	For y=0 To 16
		For x=0 To y
;			!calc{*dest,x,y}
;			!mpc{*mp.xy,x,y}

			*mp\x=(*dest\x*qqc-*dest\y*qqs +160)ASL 4

			hgh=*dest\x*qqs+*dest\y*qqc +100
			If hgh<0 Then hgh=0
			*mp\y=(hgh&$ffff) ASL 2
			*dest+SizeOf.vec
			*mp+SizeOf.xy
		Next
	Next
CEND



CNIF #c=#j

	!waitdsp

;	BlCopyMem{map.l,tritemp.l,trisize.l }
	mytemp.l=$f1cf80

	Poke.l mytemp	,tritemp.l	;dest
	Poke.l mytemp+4,base(t)		;src

	Poke.l mytemp+	8,jfr{qs ASR 1,qc ASR 1}
;	quikx.q=(5-jfrac{deadx}) ASL 6
;	quiky.q=(5-jfrac{deady}) ASL 6

	Poke.q mytemp+ $c,quikx
	Poke.q mytemp+$10,quiky

	!rundsp{0}

;	!waitdsp

;	BlCopyMem{tritemp.l,map.l,trisize.l }
	Return
CEND



Return



.Draw
CNIF #c=#j

	BlPoly{*bmr,map,colbase}
CEND

CNIF #c=#a
	For y=0 To 15
		!mpc{*mp.xy,0,y}
		*mpn.xy=*mp+SizeOf.xy*(y+1)
		*dt2.xy=*mpn+SizeOf.xy


;		fred(0)=*mp\x:fred(1)=*mp\y
;		fred(2)=*mpn\x:fred(3)=*mpn\y
;		fred(4)=*dt2\x:fred(5)=*dt2\y
;		Polyf 3,&fred(0),*mp\c2


		For x=0 To y-1
			*mp+SizeOf.xy

;			fred(2)=*mp\x:fred(3)=*mp\y
;			Polyf 3,&fred(0),*mp\c1
			*mpn=*dt2:*dt2+SizeOf.xy

;			fred(0)=*mp\x:fred(1)=*mp\y
;			fred(2)=*mpn\x:fred(3)=*mpn\y
;			fred(4)=*dt2\x:fred(5)=*dt2\y
;			Polyf 3,&fred(0),*mp\c2

;			BlLin{*bmr,*mpn\x ASR 4,*mpn\y ASR 2,*mp\x ASR 4,*mp\y ASR 2,x+1}

		Next
	Next

CEND
Return


;			BlLin{*bmr,*dt4\x ASR 4,*dt4\y ASR 2,*dt2\x ASR 4,*dt2\y ASR 2,*mp\c}
;			BlLin{*bmr,*dt2\x ASR 4,*dt2\y ASR 2,*dt3\x ASR 4,*dt3\y ASR 2,*mp\c}

























.
.
.
.
.
.
.


##[$80CA] *p
.SpinIt

;	If jox=2 Then chan(\channel)\reqsam=3:jox=0
	If \inair
		\rot=##[$C386](\rot,-1,1)
	Else
		If \idle<0
			If \control=#contcomp
				\rot=(\rot+*p\jox*\steering) ASR 1
			Else
				\rot=(\rot+	 jox*\steering) ASR 1
			EndIf
		EndIf
	EndIf

	oldk=\k
	If \drop

		\headk-\gravity:newk=\k+\headk+\headk
		tx=\i+\headi+\headi:tz=\j+\headj+\headj
		soonk=QHite(tx,tz,skbm)
		If newk >soonk
;			Stop
			\inair=On:\traction=1
			CNIF #c=#s
			 Select (Peek.w($c00004) AND 7)	;quick random..
				 Case 0:\pitch=QLimit(\pitch+\mpitch,0,4)
				 Case 1:\roll =QLimit(\roll +\mroll ,0,4)
				End Select
			CEND
		Else

			\headk=(soonk-oldk)ASR 1:\inair=Off

			pitch.w=##[$C386]((QHite(tx,tz+0.2,skbm)-soonk)+2.5,0,4)
			\mpitch=##[$C382](pitch-\pitch):\pitch+\mpitch

			roll.w=##[$C386]((QHite(tx-0.2,tz,skbm)-soonk)+2.5,0,4)
			\mroll=##[$C382](roll-\roll):\roll+\mroll

		EndIf
	EndIf

	\dir=##[$851A](\dir+\rot)
	\qc=qcos(\head):\qs=qsin(\head)
	temp=\roll*160+\pitch ASL 5+\head ASR 1
	If temp<>\fr
		\fr=temp:\upd=3
	Else
		\upd=1
	EndIf
Return



Macro FindScr
	*s\v`1x=(*sha\rx`1																					 )
	*s\v`1y=(*sha\ry`1-##[$C487](QHite(\i+*sha\ri`1,\j+*sha\rj`1,skbm)-oldk))
;	*s\v`1y=IOP(MapY(\i+*sha\ri`1,\j+*sha\rj`1,skbm))

End Macro


##[$80CA] *p
.DrawShadow

	CNIF #c=#s

		oldk=\k

		*s.quad=&quadverts(0);\q
;		*sha.ShadPt=peek.l($ff000c)+?shadowdat+SizeOf.ShadPt*FixAng(\head+0.5)
		*sha.ShadPt=Peek.l($ff000c)+\carnum ASL 12 +SizeOf.ShadPt*##[$851A](\head+0.5)
		!FindScr{0}:!FindScr{1}:!FindScr{2}:!FindScr{3}
;		temp=0
		temp=##[$C483] (&quadverts(0),*p\q+384)

		*p\shady=temp

;		If QAbs(*p\headk)>3
;			*p\segasp\rshady=-1
;		Else
;			*p\segasp\rshady=0
;		EndIf

	CEND


Return


Statement bounce{result.w,*e.quadratic,*par.parse}
	Shared sqlu.l

;result obtained from TestNew..
;fi,fj are the params to be changed...
;di,dj,i,j are just for fun..

	here.w=Off ; in case we crash more than once?

	result+16
	##[$80BB]
		If ( (result & 1)=1)
			If *e\lstraight
				here+FixHitLine(*e,*par)
			Else
				here+FixHitQuad(*e,*par,sqlu)
			EndIf
		EndIf	 ;noimpact
		result ASR 1
		*e+#hquad
		*par\norm+32
	##[$80BC] (result=1) ; OR (here=On)
	*par\norm AND 63
	*par\boom=(here<0)
End Statement	;end of bounce



Statement Damage{result.w,*e.quadratic,*par.parse}
	##[$80BB]
		If ( (result & 1)=1)
			If *e\lstraight
				deli=*par\fi-*e\lc
				delj=*par\fj-*e\lf
				fac=*e\lb*deli+*e\le*delj
				*par\i=*e\lc+*e\lb*fac
				*par\j=*e\lf+*e\le*fac	;				here+bouncenew{*e,*par}
			Else
				deli=*par\fi-*e\lc
				delj=*par\fj-*e\lf
				fac=*e\lb*deli+*e\le*delj
				*par\i=*e\lc+fac*(*e\lb+*e\ma*fac)
				*par\j=*e\lf+fac*(*e\le+*e\md*fac) ;				here+bouncepod{*e,*par,sqlu}
			EndIf
		EndIf	 ;noimpact
		result ASR 1
		*e+#hquad
	##[$80BC] (result=0)
End Statement	;end of Damage


#mung=On
#clip=On

##[$80CA] *p
.MoveIndiv
CNIF #race

;	If \towed<>0 Then Return

	If \control=#contcomp Then comp=True:Else:comp=False	;computer override!

	If \idle<0 ;be strict!


		\movi=0:\movj=0

	CNIF #mung
		*par\fi=\i:*par\fj=\j
		*par\i =\i:*par\j =\j
		dt=\curdt
		*e=edge(dt):result.w=CheckCollQuad(*e,*par):*g.xtra=grot(dt+1)
		If result.w>0
			If (result&5)>0
				If (*g\cai-*par\fi)**g\swivj > (*g\caj-*par\fj)**g\swivi
					result&14
				Else
					result&11
				EndIf
			EndIf
			If (result&10)>0
				If (*g\cai-*par\fi)**g\swivj > (*g\caj-*par\fj)**g\swivi
					result&13
				Else
					result&7
				EndIf
			EndIf

			If result>0
				Damage{result,*e,*par}
				\i=*par\i:\j=*par\j:\headi=0:\headj=0
			EndIf

		EndIf
		;mung walls (fin)
	CEND


		If \inair
			\nrev=0
		Else

			If comp

				\jox=0
				ni=*p\i+*p\headi ASL 2
				nj=*p\j+*p\headj ASL 2

				mess.w=firstmass(##[$C384](*p\curdt,2,pts3))
				*first.guide=mass(mess)
				safe=On
;				MOVE #$8708,$c00004
				DEFTYPE.guide *guide
				cur.w=\curdt
				cur=##[$C384](mess+##[$8529](massbase.l,&mass(mess),massbig.l,ni,nj,cur,pts1),0,nxmass.w)
CNIF 1=0
				While safe
					mess=##[$C384](mess+1,0,nxmass.w)
					*guide.guide=mass(mess)
					dif=(*guide\dtp-\curdt)
					If dif<0 Then dif+pts1
					If (dif>-2 AND dif<8)
						difi=*guide\mi-ni
						difj=*guide\mj-nj
						If (*guide\di*difj-*guide\dj*difi)<0
							cur.w=mess:maxout=dist:safe=Off
						EndIf
					EndIf
				Wend
CEND
;				MOVE #$8700,$c00004

				desti=0
				*guide	 =mass(			cur						)
				*lg.guide=mass(##[$C384](cur-1,0,nxmass))

				If lapdir=1
					difi=*guide\li-ni:normi=*guide\li-*lg\li
					difj=*guide\lj-nj:normj=*guide\lj-*lg\lj
					If difi*normj<difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\ri:destj=*rg\rj:joy=cmpacc7
					EndIf

					difi=*guide\ri-ni:normi=*guide\ri-*lg\ri
					difj=*guide\rj-nj:normj=*guide\rj-*lg\rj
					If difi*normj>difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\li:destj=*rg\lj:joy=cmpacc7
					EndIf
				Else
					##[$80C9] *lg,*guide

					difi=*guide\li-ni:normi=*guide\li-*lg\li
					difj=*guide\lj-nj:normj=*guide\lj-*lg\lj
					If difi*normj>difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\ri:destj=*rg\rj:joy=cmpacc7
					EndIf

					difi=*guide\ri-ni:normi=*guide\ri-*lg\ri
					difj=*guide\rj-nj:normj=*guide\rj-*lg\rj
					If difi*normj<difj*normi
						*rg.guide=mass(##[$C384](cur+lapdir2,0,nxmass))
						desti=*rg\li:destj=*rg\lj:joy=cmpacc7
					EndIf

				EndIf


				If desti=0
					*rg.guide=mass(##[$C384](cur+lapdir4,0,nxmass))
					desti=*rg\mi:destj=*rg\mj:joy=cmpacc
				EndIf

;				MOVE #$8707,$c00004

				difi=desti-\i
				difj=destj-\j
				\jox=##[$C382](difi*\qs-difj*\qc)
			EndIf

			\vel=\headi*\qc+\headj*\qs

									;	*****	 HILL	 ******
			tx=\i-\qc:tz=\j-\qs
			If \vel<0
				joy+(\headk ASR 1)	;hmmmm
			Else
				joy-(\headk ASR 1)	;hmmmm
			EndIf
;			joy+(!qhite{tx,tz}-\k) ASR 3

			##[$8528] *p,joy
;			\nrev=(\rev+joy*\accel)*(\engfric)
;
;			\movi+(\qc*\nrev)-\headi
;			\movj+(\qs*\nrev)-\headj
;			\nrev=(\nrev-\rev) ASR 2
;
;			\traction=JAbs(\qc*\movj-\qs*\movi)
;
;			\movi*\retard
;			\movj*\retard

		EndIf

		ddi1=\headi ASL 2+(\movi ASL 2+ \movi) ASL 1
		ddj1=\headj ASL 2+(\movj ASL 2+ \movj) ASL 1
		proi=\i+ddi1
		proj=\j+ddj1

		*g=grot(\curdt)
		ni=proi-*g\midi:nj=proj-*g\midj
		If *g\dirj*ni < *g\diri*nj	;n.b. qwrap (2,pts3)
			\curdt-1
			If (\curdt<		2) Then \curdt+pts1:lapinc.w=-lapdir:Gosub DrawLaps
;			If leadtime(\curdt)<tim Then leadtime(\curdt)=tim

		Else
			*g=grot(\curdt+1):ni=proi-*g\midi:nj=proj-*g\midj
			If *g\dirj*ni > *g\diri*nj
				\curdt+1
				If (\curdt>pts2) Then \curdt-pts1:lapinc=lapdir:Gosub DrawLaps
;				If leadtime(\curdt)<tim Then leadtime(\curdt)=tim
			EndIf
		EndIf



	CNIF #clip
		test\boom=Off
		ddi1=-ddi1
		ddj1=-ddj1
		test\i =*p\i:test\j =*p\j
		test\fi=proi:test\fj=proj
		test\di=ddi1:test\dj=ddj1

		\side=0:\top=0
		If (##[$C385](ddi1) < 0.02) AND (##[$C385](ddj1) < 0.02) ;goslo
			\headi=0:\headj=0:\movi=0:\movj=0
			ddi1=0:ddj1=0
		Else
			ro=ddi1 ASL 6:ger=ddj1 ASL 6
			qfac.q=RDistance(ro,ger) ASL 7
			test\diri=ddi1*qfac
			test\dirj=ddj1*qfac

			dt=\curdt:							;*g=grot(dt)
			*e=edge(dt)
			result.w=CheckCollQuad(*e,*par)
			If result<>0
				*par\boom=Off
				bounce{result,*e,*par}
				If test\boom
					##[$8527] *p,*par,&qcos(0),&qsin(0),ddi1,ddj1
CNIF 1=0
					\swai=test\fi
					\swaj=test\fj

					\headi=-ddi1 ASR 2:\movi=0
					\headj=-ddj1 ASR 2:\movj=0


					\swiv=##[$851A]((\dir-*par\norm)*2)

					\difi=qcos(*par\norm)
					\difj=qsin(*par\norm)	;Hooway!

;					If *p=*p0
;						Use BitMap 0
;						Line MapX(\swai,\swaj),MapY(\swai,\swaj),MapX(\swai+\difi,\swaj+\difj),MapY(\swai+\difi,\swaj+\difj),14
;					EndIf

					If ddi1<0 Then \side=1 Else \side=2
					If ddj1<0 Then \top=3 Else \top=4
CEND
				EndIf
			EndIf
		EndIf
	CEND

	Else
		##[$80CA] *p
		If \idle=1

			\traction=0

			dtp=##[$C384](signmovst+*p\pos*signmov,3,pts4) ;quick you fool!
;			dtp=JWrap(signmovst+*p\carnum*signmov,3,pts4) ;quick you fool!
			FindLo dtp,skbm
			If signside.w
				difi=bez\i-\i:difj=bez\j-\j
			Else
				difi=bez\k-\i:difj=bez\l-\j
			EndIf

			\headi=difi ASR 4
			\headj=difj ASR 4
			\movi=0:\movj=0
			FindLo dtp-0.05,skbm:FindDif dtp+0.1,skbm
			If signside.w
				ddist=##[$851A](Angle(bez\i ASL 3,-bez\j ASL 3) ASR 10	 -\dir)
			Else
				ddist=##[$851A](Angle(bez\k ASL 3,-bez\l ASL 3) ASR 10+32-\dir)
			EndIf

			\rot=(ddist-32) ASR 4

		EndIf

	EndIf



	If (\idle=-1) ;AND (\towed=0) ;strict!!!!!!!
		If lapdir=1
			myleng.w=*p\lap ASL 7 +*p\curdt
		Else
			myleng.w=*p\lap ASL 7 -*p\curdt
		EndIf
		tdist(*p\pos)\h=myleng

		If warpmode
			If (*p\control<(#contcomp))	;local player
				If (*p<>*newleader)

					If (spoon((spptr+1)&#spoon) >myleng) ;losing by 1 second
						If ((tdist(*newleader\pos)\h-1)>myleng) ;but not much
	;						If (*p\warp=0) Then *p\warp=1
	;						if snd
	;							chan(\channel)\reqsam=7:joy=-8
	;						EndIf

							*dp=*newleader

							*p\newwarps+1
							*p\qc=*dp\qc:*p\qs=*dp\qs
							*p\i=*dp\i+*p\qc*1.2
							*p\j=*dp\j+*p\qs*1.2
							*p\k=QHite(*p\i,*p\j,skbm)
							*p\headi=*dp\headi:*p\headj=*dp\headj:*p\headk=*dp\headk

							*p\rev=*dp\rev:*p\vel=*dp\vel
							*p\dir=*dp\dir:*p\rot=*dp\rot
							*p\curdt=*dp\curdt
							If *p\lap<>*dp\lap Then lapinc=*dp\lap-*p\lap:Gosub DrawLaps
;							*p\coll=1
							*p\warp=0:*p\lasttime-#spoon
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf







	EndIf


	\vel=\headi*\qc+\headj*\qs

CEND
Return


.DrawLaps
	*p\lap+lapinc



	If (laps.w<*p\lap)
		\coll=1:\tottime=fps
		\idle=1:\rot=0
		tdist(\pos)\h=32000

;		If *p\control<#contcomp
			nureduce.w-1
			If nureduce.w<0 Then endrace.w=fps+200
;		EndIf


	EndIf

	If lapinc=1
;		If laps=*p\lap Then chan(*p\channel)\reqsam=4

		If startrace<0 Then startrace=fps
		quik.w=fps-*p\lasttime

		If quik>0
;			PrintCarCar quik/5,?tagbin,*p\q
			If quik<*p\bestlap Then *p\bestlap=quik

			If (*p\control<#contcomp)
;				dum.w=quik*0.002:thing.l=			 dum	ASL 8:quik-dum*500
;				dum.w=quik*0.02 :thing.l=(thing+dum) ASL 8:quik-dum*50
;				thing=(thing+10) ASL 8+Int(quik*0.2)
;				PutSpriteNums thing,*p\spr1,*p\spr2
				*p\disc=15:*p\oldpos=-1
;				PrintCarCar 0,?tagbin,*p\q
				##[$C48C] quik/5,?tagbin,*p\q
			EndIf
		Else

		EndIf
		*p\lasttime=fps

	Else
		*p\lasttime=10000
	EndIf



Return

CheckWallLatent
CNIF #race
	##[$80CA] *p
	For *p=Pl(0) To Pl(#uscar) Step SizeOf.car	; if in a collision, \movi=0=\movj

		*p\rev+*p\nrev

		Select \side
			Case 0:impact.w=Off
			Case 1:impact.w=(\i+\headi) >= \swai
			Case 2:impact.w=(\i+\headi) <= \swai
		End Select
		If NOT impact
			Select \top
				Case 3:impact.w=(\j+\headj) >= \swaj
				Case 4:impact.w=(\j+\headj) <= \swaj
			End Select
		EndIf
		If impact

			\i=\swai:\j=\swaj
			fac=(\headi*\difj-\headj*\difi);ASL 1 ; do the wild vel
			fac=fac+ fac ASR 1
			\headi-(fac*\difj)
			\headj+(fac*\difi)

			If (##[$C385](\headi)>0.03) OR (##[$C385](\headj)>0.03)	;so bounce ain't excessive..
				blah=RDistance(\headi ASL 7,\headj ASL 7) ASL 4	;was 3
				If blah<1
					\headi*blah:\headj*blah

				EndIf
;				\headi+0.5
;;		 Safe{}
			Else
				\headi= \difj ASR 5
				\headj=-\difi ASR 5
			EndIf

			blah=qsin(\swiv)	;do the wild spin after bounce..
			\dir=##[$851A](\dir-blah)
			\rot-blah ;ASL 1

			\side=0:\top=0:\swai=-1	;reset so ain't happen 'gin
			\swiv=0 ;:\rev ASR penalty
		EndIf

	Next
CEND

Return






.
.
.
.
.




CNIF #c=#j
	;********************** JAGOS SUBS ******************************

.jagos ;(thanx mark!)
	;
	;OK, well need some zero page locations...
	;
	#allocat=$200
	#stopat=$204
	#vbint=$208
	#gpint=$20c
	#obint=$210
	#tiint=$214
	#dsint=$218
	#_INT1=$21c

	#superstacksize=256
	#userstacksize=256


	copymem		 ;a0=src, a1=srcf, a2=dest
	;
	CMP.l a1,a0:BCC 'done:MOVE.l (a0)+,(a2)+:BRA copymem
	'done:RTS

	initjagos
	;
	CLR.l $ff0:CLR.l $ff8:
	MOVE.l #$200000,allocat:MOVE.l (a7),a0
	MOVE.l allocat,a7:SUB.l #superstacksize,allocat
	MOVE #$0,sr
	MOVE.l allocat,a7:SUB.l #userstacksize,allocat:MOVE.l a0,-(a7)
	;
	MOVE #$1f00,_INT1:LEA inthandler(pc),a0:MOVE.l a0,$100
	;
	MOVEQ #8,d0:BSR alloc:CLR.l (a0):MOVE.l #4,4(a0):MOVE.l a0,stopat
	MOVE.l a0,d0:SWAP d0:MOVE.l d0,$f00020:RTS


	alloc ;d0=size, return a0=mem
	MOVE.l 4,a6:MOVEQ #0,d1:JSR -204(a6):MOVE.l d0,a0:RTS

	vbinton:OR #1,_INT1:MOVE _INT1,$f000e0:RTS
	vbintoff:ANDI #$fffe,_INT1:MOVE _INT1,$f000e0:RTS

	inthandler
	;
	MOVEM.l d0-d7/a0-a6,-(a7)
	;
	MOVE $f000e0,d2:ANDI #$1f,d2:MOVE d2,d0
	LSL #8,d0:OR d2,d0:MOVE d0,$f000e0
	;
	LSR #1,d2:BCC 'novbint:MOVE.l vbint,a0:JSR (a0):'novbint
	LSR #1,d2:BCC 'nogpint:MOVE.l gpint,a0:JSR (a0):'nogpint
	LSR #1,d2:BCC 'noobint:MOVE.l obint,a0:JSR (a0):'noobint
	LSR #1,d2:BCC 'notiint:MOVE.l tiint,a0:JSR (a0):'notiint
	LSR #1,d2:BCC 'nodsint:MOVE.l dsint,a0:JSR (a0):'nodsint
	;
	MOVE d0,$f000e2
	;
	MOVEM.l (a7)+,d0-d7/a0-a6:RTE


	initvbint	;d0=scanline, a0=address of code
	MOVE d0,$f0004e:MOVE.l a0,vbint

	If a=a
		MOVE.l a5,global
		MOVE.l a3,local
	EndIf
	RTS



	vbdb	;vertical blank double buffer...
		MOVEM.l d0/d2,-(a7)
		MOVE.l global,a5
		MOVE.l local,a4

		ADDQ #1,framecnt

		RefrBmap{*bmr2.jbmap}
		HeadBmap{*bmr2}

	;	HeadBmap{Peek.l($204)-32}

		MOVEM.l (a7)+,d0/d2
	RTS



global :Dc.l 0
local	:Dc.l 0
CEND



CNIF 1=0

.printd2
;
;RTS
;
;print d2 at d0,d1
;
MOVEM.l d2-d4/a2,-(a7)
;
MOVE.l bmap1,a0							;where it goes
MULU #320,d1:ADD.l d1,a0:LSL #2,d0:AND #$fff0,d0:ADD d0,a0
MOVE.l d2,d0
;
MOVEQ #7,d4
'loop
ROL.l #4,d0:MOVE d0,d2:AND #15,d2
LEA digs(pc),a1:LSL #4,d2:ADD d2,a1						 ;start of digit
MOVEQ #7,d3:MOVE.l a0,a2
'loop2
MOVE.l (a1),(a2):MOVE.l 4(a1),4(a2)
MOVE.l 8(a1),16(a2):MOVE.l 12(a1),20(a2)
;
LEA 576(a1),a1:LEA 1280(a2),a2
DBF d3,'loop2
LEA 32(a0),a0:DBF d4,'loop
;
MOVEM.l (a7)+,d2-d4/a2:RTS

Event
CEND



	Event

CNIF #c=#j
	gpu_1
	IncBin "gpu"
	gpu_1f

	dsp_1
	IncBin "dsp"
	dsp_1f
CEND


	sincos:		IncBin "sincos.bin"
;	shadowdat: IncBin "shadow.dat"
	sqludat:	 IncBin "sql.inc"

CNIF #c<>#s
	mytrack:	 IncBin "maps:f5.nmp"
CEND


CNIF #c=#s

	blank:Dcb.w 64,$80
	carpalette: IncBin "car.palette"
	segpalette: IncBin "sega.palette"

strip:
	Dcb.l 32,$89aba981
	Dcb.l 32,$1cdefedc

checkers:IncBin "checkers.bin"



	CNIF #frontend
		font:
			Dc.l 0,0,0,0,0,0,0,0
			Dc.l 0,0,0,0,0,0,0,0
			IncBin "font.bin"
		fontf:

		fence:
			IncBin "rails.bin"
		fencef

		miniat:IncBin "cars.bin"
					 IncBin "rainbow.bin"
		miniatf

		seldat:IncBin"select.bin"
		seldatf
		selmap:IncBin"select.map"



		fsize:IncBin "size.bin"

	CEND



CEND










.InitOs
	CNIF #c=#j
;		BSR initjagos
		MOVE.l #$00a600a6,$f00038:MOVE #$656,$f0003c
		;MOVE #ypos,$f00046:MOVE #ypos+hite+hite,$f00048
		MOVE #$2e,$f00046
		;MOVE #$2e+240+240,$f00048
		MOVE #$2e+199+199,$f00048

		bld.l=$f02200
		!waitgpu
		!waitdsp

		Poke.l $f1a100,(Peek.l($f1a100)&$f) OR (1 ASL 14)
		BlCopyMem{?gpu_1,$f03000,?gpu_1f-?gpu_1}
		BlCopyMem{?dsp_1,$f1b000,?dsp_1f-?dsp_1}

	CEND

Return




;	nmp.l						;8k+ contours NOT CRUNCHED
;	blockmap.l			 ;8k crunched
;	blocks.l[8]			;40k+ crunched

.InitVars

	;warpmode.w=On

	mytrk.w=2
	skill.w=3
CNIF #frontend
	menu.w=#main
CEND

	screenmode=0

	mytau=6

	scrx=80:scry=0
	;laps.w=10
	laps.w=4
	CNIF #c=#s
		segjoy.w=##[$C48E]
		If segjoy<0
			numseg.w=1-segjoy
		Else
			numseg=segjoy-1
		EndIf
	CEND

Return



;NEWTYPE .segasp					 ;sort points here
;	dpth.w:car.w						;car=0 for car or numsprites for bridge
;	binfo.l[0]							;ptr to bridge info in rom
;	shady.w:rshady						;
;	sx.q:sy.q:spdata.w			;bridge
;End NEWTYPE





Macro ssp SizeOf.segasp\`1(a1):End Macro

Statement findsprites{myinfo.l,splist.l,cptr.l,mydata.l}
	;
	MOVEM.l a4-a6,-(a7)
	;
	MOVE.l d0,a0:MOVE.l d1,a1:MOVE.l d0,a2:MOVE.l d2,a4:MOVE.l d3,a5
	domore:MOVE (a0)+,d0:BPL domore
donother
	MOVE (a0)+,d0:BMI dun:MOVE (a0)+,d1						 ;d0-d3=x y n block
	MOVE (a0)+,d2:LEA 0(a2,d2),a3:MOVEM (a3)+,d2-d3
nxpart:
	MOVEM (a3)+,d4-d5
	ADD d1,d5:MOVE d5,!ssp{sy}
	ADD d0,d4:MOVE d4,!ssp{sx}
	MOVE d3,!ssp{spdata}
	MOVE #3000,!ssp{dpth}
	;
	MOVE (a3),d4:AND#$f00,d4:OR#5,d4:MOVE d4,!ssp{l}:ADD 2(a3),d3
	;
	MOVE.b(a3),d4:ADDQ#4,a3:MOVE d4,d5:AND #12,d4 ;d4=w d5=h+1
	LEA 0(a5,d4),a6:MOVE.l a6,!ssp{wptr}
	AND#3,d5:ADDQ#1,d5:MOVE d5,d4
	MOVE d4,!ssp{h0}:ADD d5,d4
	MOVE d4,!ssp{h1}:ADD d5,d4
	MOVE d4,!ssp{h2}:ADD d5,d4
	MOVE d4,!ssp{h3}
	;
	MOVE.l a1,(a4)+:ADD #SizeOf.segasp,a1:SUBQ#1,d2:BNE nxpart:BRA donother
	;
dun:
	MOVE.l #0,(a4):MOVEM.l (a7)+,a4-a6:AsmExit
	;
End Statement


.GetNewTrack
	CNIF #c=#s
		*ath.theader=tkptr + SizeOf.theader*mytrk.w
		maptr.l=*ath\nmp+tkbin
		myinfo.l=*ath\info+tkbin

		For cnt.w=0 To #uscar
			cptr(cnt)=&spr(cnt)
			cptr(#uscar+1+cnt)=&spr(#uscar+1+cnt)
		Next
		cnt.w=#uscar+#uscar+1+1
		findsprites{myinfo,&spr(cnt),&cptr(cnt),?mytable}

	CELSE

		maptr.l=?mytrack
	CEND

	condt.l=maptr+64*64*2 + 2
	pts.w=Peek.w(maptr+64*64*2):pts1.w=pts+1:pts2.w=pts+2:pts3=pts+3:pts4=pts+4

	SetMaptr maptr.l+2,skbm
	SetConDt condt.l,skbm
	SetIO &bez.ij,skbm
	Gosub PreProcess

Return




.DoPal
	CNIF #c=#j
			palbase.l=$f00400
			For tr.w=0 To 255
				mycol=tr ASL 1

				blah.q=(##[$8481](15*tr+2.3,tr)+1)*127:mr=blah
				blah.q=(##[$8481](tr,tr*7+3242)+1)*127:mg=blah
				blah.q=(##[$8481](tr*31+32.6,tr*9+324)+1)*127:mb=blah

				temp.l=(jint{mr ASR 3} ASL 5 + jint{mb ASR 3}) ASL 6+ jint{mg ASR 2}
		;		temp.l=$ffff;3333
				Poke.w palbase+mycol,temp
			Next
	CEND

	CNIF #c=#s
		If inrace
			base.l=#cram+32
			##[$C482] blockmap	 ,#cram+96,16
			##[$C482] blockmap+32,#cram	 ,16

			##[$C482] ?carpalette,base,8
			##[$C482] ?carpalette,base+32,8

			##[$C482] ?carpalette+16+newp(Pl(0)\newp)\col ASL 3,base+16,4
			##[$C482] ?carpalette+16+newp(Pl(2)\newp)\col ASL 3,base+24,4

			##[$C482] ?carpalette+16+newp(Pl(1)\newp)\col ASL 3,base+48,4
			##[$C482] ?carpalette+16+newp(Pl(3)\newp)\col ASL 3,base+56,4

		Else
			base.l=#cram
			##[$C482] ?segpalette,base+96,16
			##[$C482] ?carpalette,base+64,8 ;cheap...
			##[$C482] ?carpalette,base+80,8


			##[$C482] ?carpalette,base,8
			##[$C482] ?carpalette,base+32,8

			##[$C482] ?carpalette+16+newp(0)\col ASL 3,base+16,4
			##[$C482] ?carpalette+16+newp(1)\col ASL 3,base+24,4

			##[$C482] ?carpalette+16+newp(2)\col ASL 3,base+48,4
			##[$C482] ?carpalette+16+newp(3)\col ASL 3,base+56,4


		EndIf


		If cnt=-42	 ;champsel screen
			##[$C482] ?segpalette+32,base,16
		EndIf


	CEND
Return


##[$80CA] *p
.HandleHeader
		If \idle=1
			\disc-1
			If \disc=0
				quik=\bestlap
				If quik>0 Then ##[$C48C] quik,?tagbin,\q:\disc=32000:\oldpos=-1
			EndIf
		EndIf

		If \idle=-1 ;racing
			\disc-1
			If \disc=0
				If *p\oldpos=-2
;					tt$="			 "
;					PutSpriteMess tt$,*p\spr1,*p\spr2
					##[$C48C] 0,?tagbin,*p\q
					*p\oldpos=9
				EndIf
				If *p\oldpos=-1
					*p\oldpos=9
				Else
;					PutSpriteNums 0,*p\spr1,*p\spr2
					##[$C48C] 0,?tagbin,*p\q
				EndIf
			EndIf
		EndIf

		If (*p\oldpos>-1)
			If (*p\pos<> *p\oldpos) OR (*p\disc<-1000)
				*p\oldpos=*p\pos
				*p\disc=2
;				PutSpriteNums *p\pos+1,*p\spr1,*p\spr2
				##[$C48C] -1-*p\pos,?tagbin,*p\q
			EndIf
		EndIf
Return






##[$80CA] *p
.SetStartCar
	\idle=0:\drop=Off:\inair=On
	\coll=-1:\warp=0:\lap=0:\jox=0
	\pitch=2:\roll=2:\mpitch=0:\mroll=0:\rot=0:\movi=0:\movj=0
	\headi=0:\headj=0:\headk=0:\rev=0:\nrev=0:\vel=0:\traction=0

	\swaheadi=0:\swaheadj=0:\swamovi=0:\swamovj=0
	\side=0:\top=0:\swai=0:\swaj=0:\difi=1:\difj=0:\swiv=0
	\bestlap=32000:\lasttime=10000:\tottime=-1
Return


.PlaceNorm
CNIF #race
	dtp.q=pts3+0.5:If lapdir=-1 Then dtp=2.5
	signmovst=dtp

	FindLo dtp,skbm:dti =(bez\i+bez\k)ASR 1:dtj =(bez\j+bez\l)ASR 1:dtp-(0.1*lapdir)
	FindLo dtp,skbm:dpri=(bez\i+bez\k)ASR 1:dprj=(bez\j+bez\l)ASR 1

	dj=(dtj-dprj) :di=(dti-dpri):width=1.2
	qnorm.q=0.1/jsqr{di*di+dj*dj}

	signmov=2.5:If trailer Then signmov=4.5

	di*10*qnorm*1.25:dj*10*qnorm*1.25
	tdir=##[$851A](Angle(dj ASL 6,di ASL 6) ASR 10+32)




	mycnt.w=0
	For *p=Pl(0) To Pl(#maxcar) Step SizeOf.car
		*p\i=dti+dj*width*((mycnt&1)-0.5)*2 - 2*di*width*mycnt;dback
		*p\j=dtj-di*width*((mycnt&1)-0.5)*2 - 2*dj*width*mycnt;dback
 ;	 *p\k=QHite(*p\i,*p\j,skbm)+10

		*p\dir=tdir:*p\qc=qcos(tdir):*p\qs=qsin(tdir)
		*p\curdt=dtp
		mycnt+1
	Next

CEND
Return


Statement CopGrot{src.w,dest.w}
Shared grot(),edge()
	*gs.xtra		 =grot(src):*gd.xtra		 =grot(dest)
	*es.quadratic=edge(src):*ed.quadratic=edge(dest)

	For i=0 To SizeOf.quadratic:Poke.b *ed+i,Peek.b (*es+i):Next
	For i=0 To SizeOf.xtra		 :Poke.b *gd+i,Peek.b (*gs+i):Next

End Statement



PreProcess
CNIF #race

	oldi=100:oldj=100
	For dt=0 To pts3

		*g=grot(dt):*e=edge(dt)

		FindLo dt+0	,skbm:A1=bez\i:A2=bez\j:bA1=bez\k:bA2=bez\l
		FindLo dt+0.5,skbm:B1=bez\i:B2=bez\j:bB1=bez\k:bB2=bez\l
		FindLo dt+1	,skbm:C1=bez\i:C2=bez\j:bC1=bez\k:bC2=bez\l


		*g\swivi=A1-bA1:*g\swivj=A2-bA2

;		*g\desti=(A1+	 C1+bA1+		bC1)ASR 2
;		*g\destj=(A2+	 C2+bA2+		bC2)ASR 2
;		*g\desti=(A1+B1+C1+bA1+bB1+bC1)/6
;		*g\destj=(A2+B2+C2+bA2+bB2+bC2)/6
;		*g\desti=(B1+bB1)ASR 1
;		*g\destj=(B2+bB2)ASR 1
		*g\desti=(B1+bB1) ASR 1 +(C1-B1+bC1-bB1)+(A1-B1+bA1-bB1)
		*g\destj=(B2+bB2) ASR 1 +(C2-B2+bC2-bB2)+(A2-B2+bA2-bB2)

		cai=A1:caj=A2
		cbi=C1:cbj=C2	;keep em in - why not?
		*g\midi=B1	:*g\midj=B2
		*g\cai=A1	 :*g\caj=A2
		*g\dai=A1-C1:*g\daj=A2-C2

		ni	=A1-C1:nj	=A2-C2:pdist=jsqr{ni	*ni	+nj	*nj	}:ni	/pdist:nj	/pdist
		difi=A1-B1:difj=A2-B2:pdist=jsqr{difi*difi+difj*difj}:difi/pdist:difj/pdist
		fac=(ni*difj-nj*difi)
		If ##[$C385](fac)<0.13
			*e\lstraight=On
		Else
			*e\lstraight=Off
			*e\lodd1=(fac<0)
			*e\lodd3=(fac>0)
		EndIf


		plussage.w=0:Gosub DoQuadratic

		*e+#hquad
		A1=bA1:A2=bA2:B1=bB1:B2=bB2:C1=bC1:C2=bC2

		*g\cbi=A1	 :*g\cbj=A2
		*g\dbi=A1-C1:*g\dbj=A2-C2

		dai =A1-cai:daj =A2-caj
		dbi =C1-cbi:dbj =C2-cbj		;ya never know.. might come in handy!
		*g\diri=B1-*g\midi:*g\dirj=B2-*g\midj

		mu=(cbj*dai-caj*dai+cai*daj-cbi*daj)/(dbi*daj-dbj*dai)

		ni	=A1-C1:nj	=A2-C2:pdist=jsqr{ni	*ni	+nj	*nj	}:ni	/pdist:nj	/pdist
		difi=A1-B1:difj=A2-B2:pdist=jsqr{difi*difi+difj*difj}:difi/pdist:difj/pdist
		fac=ni*difj-nj*difi
		If ##[$C385](fac)<0.13
			*e\lstraight=On
		Else
			*e\lstraight=Off
			*e\lodd1=(fac>0)
			*e\lodd3=(fac>0)
		EndIf
		plussage.w=32:Gosub DoQuadratic
	Next



	CopGrot{pts1,0}
	For src=1 To 7:CopGrot{src,src+pts1}:Next

	nxmass.w=0:stp=0.25:dtp=2:FindLo dtp,skbm:Gosub getnew:oi=ni:oj=nj

	While dtp<(pts+3)
		dist=0:stpmax=80:stpmin=0
		While (dist<3.8) OR (dist>4.2)
			ndt=dtp+stp:FindLo ndt,skbm:Gosub getnew
			dist=(oi-ni)*(oi-ni)+(oj-nj)*(oj-nj)
			If dist<4
				stpmin=stp
				If stpmax=80 Then stp+0.1: Else stp=(stpmax+stpmin) ASR 1
			Else
				stpmax=stp
				If stpmin=0 Then stp=##[$C386](stp-0.1,0,80):Else stp=(stpmax+stpmin) ASR 1
			EndIf
		Wend
		dtp=ndt:oi=ni:oj=nj

		difi=bez\k-bez\i:difj=bez\l-bez\j:proj.q=1/jsqr{difi*difi+difj*difj}:difi*proj:difj*proj

		li=bez\i+difi:lj=bez\j+difj
		ri=bez\k-difi:rj=bez\l-difj
		mass(nxmass)\mi=ni,nj
		mass(nxmass)\di=difi,difj
		mass(nxmass)\li=li,lj
		mass(nxmass)\ri=ri,rj
		mass(nxmass)\dtp=ndt:nxmass+1
;		Circle MapX(ni,nj),MapY(ni,nj),3,14
;		Line MapX(ni+difi,nj+difj),MapY(ni+difi,nj+difj),MapX(ni,nj),MapY(ni,nj),14
;		Circle MapX(li,lj),MapY(li,lj),3,14
;		Circle MapX(ri,rj),MapY(ri,rj),3,14

	Wend


	mess.w=0
	For dtp=2 To pts2

		mess=##[$C384](mess-20,0,nxmass)
		dif=mass(mess)\dtp-dtp
		If dif>5 Then dif-pts1
		While dif<0
			mess=##[$C384](mess+1,0,nxmass)
			dif=mass(mess)\dtp-dtp
			If dif>5 Then dif-pts1
		Wend
		firstmass(dtp)=##[$C384](mess-1,0,nxmass)

	Next
	If maxmess<nxmass Then maxmess=nxmass

	massbase.l=&mass(0)
	massbig.l=&mass(nxmass)


CEND
Return

CNIF #race

.getnew
	ni=(bez\i+bez\k) ASR 1
	nj=(bez\j+bez\l) ASR 1
Return


DoQuadratic
	If *e\lstraight	;one straight.. comin right up!
		difi=(C1-A1)	:difj=(C2-A2)
		pdist=jsqr{difi*difi+difj*difj}
		difi/pdist:difj/pdist:*e\lb=difi:*e\le=difj

		*e\lc=(A1+C1)ASR 1:*e\lf=(A2+C2)ASR 1
		b1=(A1-*e\lc)*difi+(A2-*e\lf)*difj
		b2=(C1-*e\lc)*difi+(C2-*e\lf)*difj
;		If b2<b1 Then Exchange b1,b2
		mid=(b1+b2) ASR 1:dif=##[$C385](b1-b2)*0.52
		b1=mid-dif:b2=mid+dif
		*e\lb1=b1:*e\lb2=b2

		*e\langst=##[$851A](Angle(difj ASL 6,difi ASL 6) ASR 10+32)
		*e\langadd=0
;		Circle MapX(*e\lc,*e\lf),MapY(*e\lc,*e\lf),5,8


	Else
		pc=A1:B1-pc:B1*2:C1-pc:pa=(C1-B1)*2:pb=C1-pa
		pf=A2:B2-pf:B2*2:C2-pf:pd=(C2-B2)*2:pe=C2-pd

		t=-0.5*(pa*pb+pd*pe)/(pa*pa+pd*pd)

		ob=2*t*pa+pb:oc=t*t*pa+t*pb+pc
		oe=2*t*pd+pe:of=t*t*pd+t*pe+pf
		pdist=jsqr{ob*ob+oe*oe}
		ob/pdist:oe/pdist
		od=-ob	:oa=oe	; to be modified along this line..

		t+1
		tc=t*t*pa+t*pb+pc-oc
		tf=t*t*pd+t*pe+pf-of

		dt1=tc*ob+tf*oe	 ;now, dot2*dot2=dot1...
		dt2=tc*oa+tf*od
		fac=(dt1*dt1/dt2)
		ma=oa/fac:md=od/fac
		oa*fac:od*fac

		*e\la=oa:*e\ld=od
		*e\ma=ma:*e\md=md
		*e\lb=ob:*e\le=oe
		*e\lc=oc:*e\lf=of

		t=0:tc=t*t*pa+t*pb+pc-oc
				tf=t*t*pd+t*pe+pf-of
				b1=tc*ob+tf*oe
		t=1:tc=t*t*pa+t*pb+pc-oc
				tf=t*t*pd+t*pe+pf-of
				b2=tc*ob+tf*oe
		dif=##[$C385](b1-b2)*0.52:mid=(b1+b2) ASR 1
		b1=mid-dif:b2=mid+dif
		*e\lb1=b1:*e\lb2=b2

		t=b1
		difi=2*t*ma+ob		 ;strictly optional..
		difj=2*t*md+oe		 ;differientiate it
		fang=(Angle(difj ASL 6,difi ASL 6) ASR 10+32)

		t=b2
		difi=2*t*ma+ob		 ;strictly optional..
		difj=2*t*md+oe		 ;differientiate it
		stang =(Angle(difj ASL 6,difi ASL 6) ASR 10+32)

		dang.q=(stang-fang)
		If dang<-32 Then dang+64
		If dang>32 Then dang-64	;take the smaller..

		dang/(b2-b1)

		*e\langst=fang-(b1*dang)
		*e\langadd=dang ASR 4


	EndIf
Return



.DoSignStart
	dtp=pts3+0.5:If lapdir=-1 Then dtp=2.5
	FindLo dtp,skbm
;	difi =(MapX(bez\i,bez\j)-signx) ASR 4:difj =(MapY(bez\i,bez\j,skbm)-signy) ASR 4
;	desti=(MapX(bez\k,bez\l)-signx) ASR 4:destj=(MapY(bez\k,bez\l,skbm)-signy) ASR 4
;	signside.w=(difi*difi+difj*difj) < (desti*desti+destj*destj)

	signside=(lapdir>0)

	FindDif 2.6,skbm
	If signside
		difi=1.4/jsqr{bez\i*bez\i+bez\j*bez\j}
	Else
		difi=1.4/jsqr{bez\k*bez\k+bez\l*bez\l}
	EndIf
	signmov=-difi*0.1*lapdir
;	signmov=0.5
	signmovst.q=pts3+0.5:If lapdir=-1 Then signmovst=2.5
Return


CEND



##[$80D3]
	champs
	mini:Dc.w	-8, 15, 20,-13,-10,-24
	pors:Dc.w	 7, -5,	4,	3,-18, -9
	midg:Dc.w -20, 18, -7, -4, 10, 13
	beet:Dc.w	 2,-14,-21,	1, -6,-17
	truk:Dc.w	 8, 23, 24, 22,-11,-12
	musc:Dc.w -16,-22, 19,	5,	9, 11
	ccow:Dc.w	12, -3, -1, -2,	6,-23
	f1f1:Dc.w	16, 21, 17, 14,-15,-19

champcars
	Dc.w	0,1,7,2,4,3,6,5

;	Dc.w -10,-13, 20, 16, 22, -8
;	Dc.w	 4,	7,-18,	3, -5, -9
;	Dc.w	-4, -7, 10, 13, 18,-20
;	Dc.w	 2, -6,-14,	1,-11,-17
;	Dc.w -12, 23, 15,	8,-21, 24
;	Dc.w	-3,	5,	9, 11,-16,-22
;	Dc.w	-2,	6, 12,-23, 19, -1
;	Dc.w	14, 17,-15, 21,-19,-24


tagbin:IncBin "tags.bin"

CNIF #title
	cmdat		:IncBin "cm.bin"
	titleadat:IncBin "titlea.bin"
	titlebdat:IncBin "titleb.bin"
	squigdat :IncBin "squig.bin"
CEND



.LostCode

CNIF 1=0
		If (((Peek.w($c00008)LSR 8)&255)>160); OR (Peek.w($ff0000)=-1)
			!MyVWait
			##[$C482] &myvram1(0),$fc00,320

			If (screenmode&1)=0
;				SegaMap mptl,0,41,blkh
				!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
				!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical

;				If screenmode=2
;					SegaMap mptla,16*64*2					,41,blkh
;				EndIf

			Else
;				SegaMap mptl,0				,21,blkh
;				SegaMap mptr,(64-22)*2,21,blkh
				!pokemem{#wvram+$10000000,-(vp(0)\sx AND 7)}					 ;horizontal
				!pokemem{#wsram+$00000000, (vp(0)\sy AND 7)}					 ;vertical
				!pokemem{#wvram+$10020000,-(vp(2)\sx AND 7)+(64-21)*8} ;horizontal
				!pokemem{#wsram+$00020000, (vp(2)\sy AND 7)}					 ;vertical

;				If screenmode=3
;					SegaMap mptla,16*64*2					,21,blkh
;					SegaMap mptra,16*64*2+(64-22)*2,21,blkh
;				EndIf
			EndIf


;			Repeat
;				cnt.w=(Peek.w($c00008)LSR 8)&255
;			Until cnt>125


		EndIf
CEND

CNIF 1=0
		MOVE #$8709,$c00004
		##[$80BB]

			cnt.w=(Peek.w($c00008)LSR 8)&255
		##[$80BC] cnt>174
		MOVE #$8703,$c00004
;		wwb:CMP.w #$7700,$c00008:BCS wwb
CEND




	CNIF 1=0


		jj=0
		If butt&1 Then jj+1
		If butt&2 Then jj-1
		myangvel=(myangvel+jj) *0.98
		myang=myang+myangvel ASR 4
		If myang<0 Then myang+1024
		If myang>=1024 Then myang-1024


		ad.l=?sincos+((myang&1023) ASL 2)
		f=jfrac{myang}:of=1-f



		qs=Peek.w(ad	)*of+Peek.w(ad+4)*f
		qc=Peek.w(ad+2)*of+Peek.w(ad+6)*f

		qqs=jext{qs}
		qqc=jext{qc}


		xvel=(xvel+jox) *0.95
		yvel=(yvel+joy) *0.95

		xdif=xvel*qqc + yvel*qqs
		ydif=xvel*-qqs + yvel*qqc
		deadx=jlimit{deadx+xdif ASR 3 ,1,63-#sqs}
		deady=jlimit{deady+ydif ASR 3 ,1,63-#sqs}

		delta.l=jint{deadx} +jint{deady}ASL 6
	CEND

	CNIF #c=#j
		LEA vbdb(pc),a0:MOVEQ #1,d0:BSR initvbint:BSR vbinton
	CEND






	CNIF 1=0
		Use On

		SUB Init
		peat
		VWait:DisplayBitMap 0,db:db=1-db:Use lmaxlen db:BlockScroll
		BitMapOutput db
		 sx3=MouseX:sy3=MouseY
		Gosub Make
		Gosub Rot
		Gosub Draw

	 ##[$80BC] Joyb(0)<>0
	End
	CEND


	CNIF 1=0
;		If (jcos{0}<0.9) OR (jcos{0}>1.1)
			For i.w=0 To 320
				hgh=i/320
				BlLin{*bmr,i,128,i,jcos{hgh}*64+128,$ffffffff}
			Next
;		EndIf
	CEND


Return

##[$80D3]

CNIF #c<>#s
	Event
	cardiff
	Dc.b	98,26,24,	 98,24,24,	44,0		;classic
	Dc.b	92,40,30,	 108,33,25 ,60	,0 ;grunty		2
	Dc.b	102,61,47,	115,59,45,64,0	 ;zippy
	Dc.b	100,80,60,	110,50,60,72,0	 ;nippy
	Dc.b	25,127,101, 29,45,122,68,0	;slippery
	Dc.b	117,23,17,	104,17,10 ,30	,0 ;pathetic	2
	Event
CEND




