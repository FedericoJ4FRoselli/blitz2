; ascii translation of /Users/simon/Google Drive/amiga/w/abc/bums/bum8/Bombs/BombsUseful.bb2,/Users/simon/Google Drive/amiga/w/abc/bums/old/bum8/Games/Bombs/BombsUseful.bb2,/Users/simon/Google Drive/amiga/w/abcstuff/acid/bums/bum8/Bombs/BombsUseful.bb2,/Users/simon/Google Drive/amiga/w/abcstuff/acid/bums/old/bum8/Games/Bombs/BombsUseful.bb2,/Users/simon/Google Drive/amiga/w/lha/bbold/bum8/bombs/BombsUseful.bb2
;
; BombsUseful
;
; Created by ARV
;
; BLITZ2 Version
; last modified 02-10-1994

; =======================================

Statement TheSettings{ *bombptr.gameVars, *biptr.OSInput}
Shared theArrow.selectarrowtype()
; Opens a screen and window for selecting game options
.TheSettings
USEPATH *bombptr

; Initialize
		For i.b=0 To 9
				If i MOD 2=0
						theArrow(i)\xpos = 190
				Else
						theArrow(i)\xpos = 244
				End If
				theArrow(i)\ypos = 50+20*((i)/2)
				theArrow(i)\state = 0
		Next i

		Screen 2, 2, "BOMBS GAME SETTINGS"
		DefaultIDCMP $8| $200
		Window 2, 0, 10, 320, DispHeight-10, $8| $1000, "SETTINGS", 0, 1
		WJam 1
		FlushEvents


		WColour 3
		WLocate 150,20:Print "min					 max"

		WLocate 10,40:Print "Width of grid	:"
		WLocate 10,60:Print "Height of grid :"
		WLocate 10,80:Print "Display-width	:"
		WLocate 10,100:Print "Display-height :"
		WLocate 10,120:Print "Percent bombs	:"
		WLocate 10,140:Print "Type of game	 :"
		WColour 1

; Now follows a simple event loop
		*biptr\ev = 0
		keep.b=True
		Repeat
				Gosub DrawArrows
				Gosub MinWidth
				Gosub MaxWidth
				Gosub MinHeight
				Gosub MaxHeight
				Gosub MinDispWidth
				Gosub MaxDispWidth
				Gosub MinDispHeight
				Gosub MaxDispHeight
				Gosub MinPercent
				Gosub MaxPercent
				Gosub TypeOfGame
.SettingsEvents
				GetUserInput{ *biptr}
				Select *biptr\ev
					Case $8													 ; Left Mouse Button
						Select *biptr\code
							Case $68											; LMB Down
								Goto SettingsEvents
							Case $E8											; LMB Up
								Gosub HandleArrows
							Case $69											; RMB Down
								Goto SettingsEvents
							Case $E9											; RMB Up
; Can implement a jump to either min or max value here
; if an arrow was clicked on
						End Select
					Case $200												 ; Close gadget
						keep=False
					Default
						Goto SettingsEvents
				End Select
		Until NOT keep

; Get out of here
		Free Window 2
		Free Screen 2
		Statement Return


HandleArrows
; Reset all arrows to state 1
		For i=0 To 9
USEPATH theArrow(i)
				\state = 0
; Check for an arrow being hit
				If (*biptr\iMouseX>=\xpos) AND (*biptr\iMouseX<\xpos+10)
						If (*biptr\iMouseY>=\ypos) AND (*biptr\iMouseY<\ypos+10)
								\state = 1
								arrowHit.b = i
						End If
				End If
		Next i
; Check for type of game being hit
		If (*biptr\iMouseX>=190) AND (*biptr\iMouseX<254)
				If (*biptr\iMouseY>=140) AND (*biptr\iMouseY<150)
						arrowHit = 10
				End If
		End If

; Do the useful bit here
USEPATH *bombptr
		Select arrowHit
			Case 0
				\wide = \wide-1
				Gosub MinWidth
			Case 1
				\wide = \wide+1
				Gosub MaxWidth
			Case 2
				\high = \high-1
				Gosub MinHeight
			Case 3
				\high = \high+1
				Gosub MaxHeight
			Case 4
				\displayWide = \displayWide-1
				Gosub MinDispWidth
			Case 5
				\displayWide = \displayWide+1
				Gosub MaxDispWidth
			Case 6
				\displayHigh = \displayHigh-1
				Gosub MinDispHeight
			Case 7
				\displayHigh = \displayHigh+1
				Gosub MaxDispHeight
			Case 8
				\percentageBombs = \percentageBombs-1
				Gosub MinPercent
			Case 9
				\percentageBombs = \percentageBombs+1
				Gosub MaxPercent
			Case 10
				\progressiveGame = NOT \progressiveGame
				Gosub TypeOfGame
		End Select
		Return

; All gosubs below were just to make it easy to write
; These can now be called in sequence, top to bottom
; No need to call them one at a time (unless you want to get confused)

DrawArrows
		For i=0 To 9
USEPATH theArrow(i)
				If \state=1
						WBox \xpos,\ypos, \xpos+9,\ypos+9, 3
				Else
						WBox \xpos,\ypos, \xpos+9,\ypos+9, 0
				End If
				If i MOD 2=0
						WBlit 22, \xpos,\ypos
				Else
						WBlit 27, \xpos,\ypos
				End If
		Next i
USEPATH *bombptr
		Return

MinWidth
		If \wide<#minWide Then \wide = #minWide:If arrowHit=0 Then BeepScreen 2
		WLocate 142,40:Print "	 "
		WLocate 166,40:Print #minWide
		Return

MaxWidth
		maxVar.l = #maxSquares/\high
		If maxVar>#maxWide Then maxVar = #maxWide
		If \wide>maxVar Then \wide = maxVar:If arrowHit=1 Then BeepScreen 2
		WLocate 262,40:Print "	 "
		WLocate 286-(Len(Str$(maxVar)))*8,40:Print maxVar
		WLocate 206,40:Print "	 "
		WLocate 230-(Len(Str$(\wide)))*8,40:WColour 2:Print \wide:WColour 1
		Return

MinHeight
		If \high<#minHigh Then \high = #minHigh:If arrowHit=2 Then BeepScreen 2
		WLocate 142,60:Print "	 "
		WLocate 166,60:Print #minHigh
		Return

MaxHeight
		maxVar = #maxSquares/\wide
		If maxVar>#maxHigh Then maxVar = #maxHigh
		If \high>maxVar Then \high = maxVar:If arrowHit=3 Then BeepScreen 2
		WLocate 262,60:Print "	 "
		WLocate 286-(Len(Str$(maxVar)))*8,60:Print maxVar
		WLocate 206,60:Print "	 "
		WLocate 230-(Len(Str$(\high)))*8,60:WColour 2:Print \high:WColour 1
		Return

MinDispWidth
		If \displayWide<#minDisplayWide Then \displayWide = #minDisplayWide:If arrowHit=4 Then BeepScreen 2
		WLocate 142,80:Print "	 "
		WLocate 166,80:Print #minDisplayWide
		Return

MaxDispWidth
		maxVar = #maxDisplayWide
		If maxVar>\wide Then maxVar = \wide
		If \displayWide>maxVar Then \displayWide = maxVar:If arrowHit=5 Then BeepScreen 2
		WLocate 262,80:Print "	 "
		WLocate 286-(Len(Str$(maxVar)))*8,80:Print maxVar
		WLocate 206,80:Print "	 "
		WLocate 230-(Len(Str$(\displayWide)))*8,80:WColour 2:Print \displayWide:WColour 1
		Return

MinDispHeight
		If \displayHigh<#minDisplayHigh Then \displayHigh = #minDisplayHigh:If arrowHit=6 Then BeepScreen 2
		WLocate 142,100:Print "	 "
		WLocate 166,100:Print #minDisplayHigh
		Return

MaxDispHeight
		maxVar = #maxDisplayHigh
		If maxVar>\high Then maxVar = \high
		If \displayHigh> maxVar Then \displayHigh = maxVar:If arrowHit=7 Then BeepScreen 2
		WLocate 262,100:Print "	 "
		WLocate 286-(Len(Str$(maxVar)))*8,100:Print maxVar
		WLocate 206,100:Print "	 "
		WLocate 230-(Len(Str$(\displayHigh)))*8,100:WColour 2:Print \displayHigh:WColour 1
		Return

MinPercent
		If \percentageBombs<#minPercentageBombs Then \percentageBombs = #minPercentageBombs:If arrowHit=8 Then BeepScreen 2
		WLocate 142,120:Print "	 "
		WLocate 166,120:Print #minPercentageBombs
		Return

MaxPercent
		If \percentageBombs>#maxPercentageBombs Then \percentageBombs = #maxPercentageBombs:If arrowHit=9 Then BeepScreen 2
		WLocate 262,120:Print "	 "
		WLocate 286-(Len(Str$(maxVar)))*8,120:Print #maxPercentageBombs
		WLocate 206,120:Print "	 "
		WLocate 230-(Len(Str$(\percentageBombs)))*8,120:WColour 2:Print \percentageBombs:WColour 1
		Return

TypeOfGame
		WLocate 180,140:Print "					 ":WLocate 180,140:WColour 2
		If \progressiveGame
				Print "progressive"
		Else
				Print "	casual"
		End If
		WColour 1
		Return

End Statement	;TheSettings

;

;XINCLUDE "BombsSettings.bb2"
;XINCLUDE "BombsFuncs.bb2"
;XINCLUDE "BombsDisplays.bb2"
;XINCLUDE "BombsGamePlay.bb2"
;
; BombsFuncs
;
; Created by ARV
;
; BLITZ2 Version
; last modified 27-09-1994

; =======================================

Statement ResetVars{ *bombptr.gameVars}
; Re-initializes the game variables for a (re)start
.ResetVars
USEPATH *bombptr
		\xcoord = 0
		\ycoord = 0
		\leftWide = 0
		\leftHigh = 0
		\timeInProgress = 0
		\gameInProgress = 0
		\rating = 0
		\openedSquares = 0
		\markedBombs = 0
		\falseBombs = 0
		\totalBombs = 0
		\closeState = 0
		\pauseState = 0
		\restartState = 0
		\progressBar\xcoord = \displayXCoord
		\progressBar\ycoord = \displayYCoord-20
		For i.b=1 To 10
				\scrollArrows[i]\displayed = False
		Next i
End Statement	;ResetVars

; =======================================

Statement PlaceBombs{ *bombptr.gameVars}
; PLACES THE REQUIRED NUMBER OF BOMBS IN THE GRID
; Just uses bombs of typenr=-1 for now
.PlaceBombs
USEPATH *bombptr
		\totalSquares = \wide * \high
; Reset all squares to closed and bombs unknown
		For i.l=1 To \totalSquares
				\square[i]\hasBomb = 0
				\square[i]\state = 0
		Next i
; Calculate the number of bombs required
		\totalBombs = \totalSquares * \percentageBombs / 100
; Place the bombs
		i = 0
		Repeat
				rndnum = !Random{ 1, \totalSquares+1}
				If \square[rndnum]\hasBomb=0
						\square[rndnum]\hasBomb = \bombs\typenr
						i=i+1
				End If
		Until i=\totalBombs
End Statement	; PlaceBombs

; =======================================

Function.b CheckTopLeft{ *bombptr.gameVars, num.l, mode.b}
; If there is a square to the top-left of the square "num", then
;		 if "mode" = #peekBomb then it returns 1
;		 if "mode" = #peekState it returns the state of the square
; If there is no square to the top-left of the square "num", then
;		 the function returns -1 no matter what the "mode" was
USEPATH *bombptr
		If (num MOD \wide<>1) AND (num>\wide)
				Select mode
					Case #peekBomb
						If \square[num-1-\wide]\hasBomb<0 Then Function Return 1
					Case #peekState
						Function Return \square[num-1-\wide]\state
				End Select
		End If
		Function Return -1
End Function	;CheckTopLeft

; =======================================

Function.b CheckTop{ *bombptr.gameVars, num.l, mode.b}
; If there is a square to the top of the square "num", then
;		 if "mode" = #peekBomb then it returns 1
;		 if "mode" = #peekState it returns the state of the square
; If there is no square to the top of the square "num", then
;		 the function returns -1 no matter what the "mode" was
USEPATH *bombptr
		If (num>\wide)
				Select mode
					Case #peekBomb
						If \square[num-\wide]\hasBomb<0 Then Function Return 1
					Case #peekState
						Function Return \square[num-\wide]\state
				End Select
		End If
		Function Return -1
End Function	;CheckTop

; =======================================

Function.b CheckTopRight{ *bombptr.gameVars, num.l, mode.b}
; If there is a square to the top-right of the square "num", then
;		 if "mode" = #peekBomb then it returns 1
;		 if "mode" = #peekState it returns the state of the square
; If there is no square to the top-right of the square "num", then
;		 the function returns -1 no matter what the "mode" was
USEPATH *bombptr
		If (num MOD \wide<>0) AND (num>\wide)
				Select mode
					Case #peekBomb
						If \square[num+1-\wide]\hasBomb<0 Then Function Return 1
					Case #peekState
						Function Return \square[num+1-\wide]\state
				End Select
		End If
		Function Return -1
End Function	;CheckTopRight

; =======================================

Function CheckLeft{ *bombptr.gameVars, num.l, mode.b}
; If there is a square to the left of the square "num", then
;		 if "mode" = #peekBomb then it returns 1
;		 if "mode" = #peekState it returns the state of the square
; If there is no square to the left of the square "num", then
;		 the function returns -1 no matter what the "mode" was
USEPATH *bombptr
		If (num MOD \wide<>1)
				Select mode
					Case #peekBomb
						If \square[num-1]\hasBomb<0 Then Function Return 1
					Case #peekState
						Function Return \square[num-1]\state
				End Select
		End If
		Function Return -1
End Function	;CheckLeft

; =======================================

Function CheckRight{ *bombptr.gameVars, num.l, mode.b}
; If there is a square to the right of the square "num", then
;		 if "mode" = #peekBomb then it returns 1
;		 if "mode" = #peekState it returns the state of the square
; If there is no square to the right of the square "num", then
;		 the function returns -1 no matter what the "mode" was
USEPATH *bombptr
		If (num MOD \wide<>0)
				Select mode
					Case #peekBomb
						If \square[num+1]\hasBomb<0 Then Function Return 1
					Case #peekState
						Function Return \square[num+1]\state
				End Select
		End If
		Function Return -1
End Function	;CheckRight

; =======================================

Function CheckBottomLeft{ *bombptr.gameVars, num.l, mode.b}
; If there is a square to the bottom-left of the square "num", then
;		 if "mode" = #peekBomb then it returns 1
;		 if "mode" = #peekState it returns the state of the square
; If there is no square to the bottom-left of the square "num", then
;		 the function returns -1 no matter what the "mode" was
USEPATH *bombptr
		If (num MOD \wide<>1) AND (num<=\totalSquares-\wide)
				Select mode
					Case #peekBomb
						If \square[num-1+\wide]\hasBomb<0 Then Function Return 1
					Case #peekState
						Function Return \square[num-1+\wide]\state
				End Select
		End If
		Function Return -1
End Function	;CheckBottomLeft

; =======================================

Function CheckBottom{ *bombptr.gameVars, num.l, mode.b}
; If there is a square to the bottom of the square "num", then
;		 if "mode" = #peekBomb then it returns 1
;		 if "mode" = #peekState it returns the state of the square
; If there is no square to the bottom of the square "num", then
;		 the function returns -1 no matter what the "mode" was
USEPATH *bombptr
		If (num<=\totalSquares-\wide)
				Select mode
					Case #peekBomb
						If \square[num+\wide]\hasBomb<0 Then Function Return 1
					Case #peekState
						Function Return \square[num+\wide]\state
				End Select
		End If
		Function Return -1
End Function	;CheckBottom

; =======================================

Function CheckBottomRight{ *bombptr.gameVars, num.l, mode.b}
; If there is a square to the bottom-right of the square "num", then
;		 if "mode" = #peekBomb then it returns 1
;		 if "mode" = #peekState it returns the state of the square
; If there is no square to the bottom-right of the square "num", then
;		 the function returns -1 no matter what the "mode" was
USEPATH *bombptr
		If (num MOD \wide<>0) AND (num<\totalSquares-\wide)
				Select mode
					Case #peekBomb
						If \square[num+1+\wide]\hasBomb<0 Then Function Return 1
					Case #peekState
						Function Return \square[num+1+\wide]\state
				End Select
		End If
		Function Return -1
End Function	;CheckBottomRight

; =======================================

Statement CalcBombNum{ *bombptr.gameVars, num.l}
; Calculates the number of bombs surrounding the square "num"
; and sets *bombptr\square[num]\hasBomb accordingly
.CalcBombNum
		total.b = 0
		i.b = CheckTopLeft{ *bombptr, num, #peekBomb}:	If i<>-1 Then total = total + 1
		i = CheckTop{ *bombptr, num, #peekBomb}:				If i<>-1 Then total = total + 1
		i = CheckTopRight{ *bombptr, num, #peekBomb}:	 If i<>-1 Then total = total + 1
		i = CheckLeft{ *bombptr, num, #peekBomb}:			 If i<>-1 Then total = total + 1
		i = CheckRight{ *bombptr, num, #peekBomb}:			If i<>-1 Then total = total + 1
		i = CheckBottomLeft{ *bombptr, num, #peekBomb}: If i<>-1 Then total = total + 1
		i = CheckBottom{ *bombptr, num, #peekBomb}:		 If i<>-1 Then total = total + 1
		i = CheckBottomRight{ *bombptr, num, #peekBomb}:If i<>-1 Then total = total + 1
		*bombptr\square[num]\hasBomb = total
End Statement	;CalcBombNum

; =======================================

Statement CheckMark{ *bombptr.gameVars, num.l}
; Checks to see if the newly marked square is has a bomb
; and increases/decreases \falseBombs accordingly
.CheckMark
USEPATH *bombptr
		If \square[num]\hasBomb<>\bombs\typenr
;		 there is no bomb here
				Select \square[num]\state
					Case 0
;						 square was just unmarked
						\falseBombs = \falseBombs - 1
					Case 4
;						 square was just marked
						\falseBombs = \falseBombs + 1
				End Select
		End If
End Statement	;CheckMark

; =======================================

Function.l FindNum{ *bombptr.gameVars}
; Returns the number of the square that was clicked on
.FindNum
USEPATH *bombptr
		num.l = ((\ycoord-\displayYCoord)/10+\leftHigh)*\wide + (\xcoord-\displayXCoord)/10+\leftWide+1
		Function Return num
End Function	;FindNum

;

;
; BombsDisplays
;
; Created by ARV
;
; BLITZ2 Version
; last modified 27-09-1994

; =======================================

Statement DrawSquare{ *bombptr.gameVars, num.l, xpos.l, ypos.l}
; Checks if xpos and ypos are within bounds of the grid,
; then draws a square at (xpos,ypos) with object "num"
DrawSquare
USEPATH *bombptr
		If (xpos>=\displayXCoord) AND (xpos<\displayXCoord+10*\displayWide)
				If (ypos>=\displayYCoord) AND (ypos<\displayYCoord+10*\displayHigh)
;						 coords are OK, now erase whatever is there
						WBox xpos,ypos, xpos+9,ypos+9, 0
						Select num
							Case $EF									; blank box required
							Case -1									 ; this is a bomb
								WBlit 12, xpos, ypos
							Default									 ; this is anything else
								WBlit num, xpos,ypos
						End Select
				End If
		End If
End Statement	;DrawSquare

; =======================================

Statement UpdateTitleBar{ *bombptr.gameVars}
; Custom titlebar for the game's display
; Update the number of bombs flagged
; This is hard-coded, change this if you add any "gadgets" in the title-bar!
UpdateTitleBar
USEPATH *bombptr
		WBox 64,5, 152,13, 11
		WLocate 64,7:Print \markedBombs
End Statement	;UpdateTitleBar

; =======================================

Statement UpdateProgressBar{ *bombptr.gameVars}
; Updates the position of the runner
UpdateProgressBar
USEPATH *bombptr
		pctInc = (\openedSquares + \markedBombs - \falseBombs) * 100 / \totalSquares
USEPATH *bombptr\progressBar
; need to change this still
		WBox \xcoord,\ycoord, \xcoord+10,\ycoord+10, 0

		\xcoord = \startXCoord + pctInc*(\endXCoord-\startXCoord)/100

		WBox \xcoord,\ycoord, \xcoord+10,\ycoord+10, 8

End Statement	;UpdateProgressBar

; =======================================

Statement UpdateTime{ *bombptr.gameVars}
; Executes a vwait, increases the time and displays
; May try to change this to interrupts
UpdateTime
USEPATH *bombptr
		If \gameInProgress=1
				VWait
				\timeInProgress = \timeInProgress + 1
				If \timeInProgress MOD #oneSecDelay=0
; Time to display another second lapsed
						timeStr$ = Str$(\timeInProgress/#oneSecDelay)
						length.w = Len(timeStr$)
						WBox 200,4, 320,13, 11
						WLocate 300-8*length,7:Print timeStr$
; Time to calculate the rating
						divisor.l = \timeInProgress/#oneSecDelay+250
						theRating.l = \percentageBombs*\percentageBombs*(\openedSquares+\markedBombs)/divisor
						If theRating>\rating Then \rating = \rating+3 Else \rating = theRating
						WLocate 200,7:Print Str$(\rating)
				End If
				UpdateProgressBar{ *bombptr}
		End If
End Statement	;UpdateTime

; =======================================

Statement ShowAllBombs{ *bombptr.gameVars, num.l}
; Plays an explosion, animates an explosion, the
; displays the positions of all bombs and ends the game
ShowAllBombs
USEPATH *bombptr
		\gameInProgress = 3
		\rating = 0
		For i.l=1 To \totalSquares
				If \square[i]\hasBomb<0
						If \square[i]\state=0 Then \square[i]\state = 2
						xpos = \displayXCoord+(((i-1) MOD \wide)-\leftWide)*10
						ypos = \displayYCoord+(i/\wide-\leftHigh)*10
						If i MOD \wide=0 Then ypos = ypos - 10
						If \square[i]\state=4
								\square[i]\hasBomb = 13
								\square[i]\state = 2
								DrawSquare{ *bombptr, 13, xpos, ypos}
						Else
								DrawSquare{ *bombptr, -1, xpos, ypos}
						End If
				End If
		Next i
End Statement	;ShowAllBombs

; =======================================

Statement RestoreRegion{ *bombptr.gameVars, theRegion.b}
; If a gadget or square was clicked down on, but the button
; was released outside of it's area, then this routine will
; restore the gadget or square to before the down press
RestoreRegion
USEPATH *bombptr
		Select theRegion
			Case #closeRegion
				\closeState = 0
				WBox 2,2, 18,18, 11
				WBlit 15-\closeState, 2,2
			Case #pauseRegion
				WBox 20,2, 36,18, 11
				WBlit 17-\pauseState, 20,2
			Case #restartRegion
				\restartState = 0
				WBox 38,2, 54,18, 11
				WBlit 19-\restartState, 38,2
			Case #gridRegion
				If \square[\downSquare[1]\num]\state=4
						\square[\downSquare[1]\num]\state = 4
						\downSquare[1]\num = 0
						DrawSquare{ *bombptr, 11, \downSquare[1]\xpos, \downSquare[1]\ypos}
				Else
						For i.b=1 To \downSquare[0]\num
								\square[\downSquare[i]\num]\state = 0
								\downSquare[i]\num = 0
								DrawSquare{ *bombptr, 0, \downSquare[i]\xpos, \downSquare[i]\ypos}
						Next i
				End If
				\downSquare[0]\num = 0
			End Select
End Statement	;RestoreRegion

; =======================================

Statement DisplayTitleBar{ *bombptr.gameVars, titleString$}
; Displays the state of the game in a bar at the top of the screen
; This is hard-coded
DisplayTitleBar
		WJam 0
		WBox 0,0,320,20,11
		RestoreRegion{ *bombptr, #closeRegion}
		RestoreRegion{ *bombptr, #pauseRegion}
		RestoreRegion{ *bombptr, #restartRegion}
		WLocate 64,7:Print titleString$
End Statement	;DisplayTitleBar

; =======================================

Statement DrawGrid{ *bombptr.gameVars}
Shared ntscOffset
; Draws a border around the displayed part of the field
; This is hard-coded
DrawGrid
USEPATH *bombptr
		\displayXCoord = ( (320) - (\displayWide*10) )/2
		\displayYCoord = ( (DispHeight+18) - (\displayHigh*10) )/2 + ntscOffset
		endX = \displayXCoord + \displayWide*10
		endY = \displayYCoord + \displayHigh*10
; Now we can draw the border of the grid
		WBox \displayXCoord-6,\displayYCoord-6, endX+5,endY+5, 1
		WBox \displayXCoord-1,\displayYCoord-1, endX,endY, 0
; Now we can draw the intermediate progress bar
		\progressBar\xcoord = \displayXCoord
		\progressBar\ycoord = \displayYCoord-20
		\progressBar\startXCoord = \displayXCoord
		\progressBar\startYCoord = \displayYCoord-20
		\progressBar\endXCoord = endX-10
		\progressBar\endYCoord = \displayYCoord-20
		WLine \displayXCoord-6,\displayYCoord-7, endX+5,\displayYCoord-7, endX+5,\displayYCoord-24, 2
		WLine \displayXCoord-6,\displayYCoord-7, \displayXCoord-6,\displayYCoord-24, endX+5,\displayYCoord-24, 1
		UpdateProgressBar{ *bombptr}
; And now we can draw the squares themselves
		For j.b=0 To \displayHigh-1
				For i.b=0 To \displayWide-1
						DrawSquare{ *bombptr, 0, \displayXCoord+(i*10), \displayYCoord+(j*10)}
				Next i
		Next j
End Statement	;DrawGrid

; =======================================

Statement DoScrolls{ *bombptr.gameVars, override.b}
; Checks if any scroll-arrows need to be drawn and draws them
; Refreshes the grid if a scroll-arrow was clicked on
; NOTE: only button releases are taken into account
; The arrows are numbered 20 thru' 29
; Drawn from left to right, top to bottom,
; using \displayXYCoords and \displayWideHigh offsets
; "override" is used to display the arrows only without any
; checks for clicks or redrawing of the grid at startup or restart
DoScrolls
USEPATH *bombptr
		arrowHit.b = False
		If (\displayWide=\wide) AND (\displayHigh=\high)
				Statement Return
		Else
				localY.w = \displayYCoord + \displayHigh*5 - 45
				leftX.w = \displayXCoord-23
				riteX.w = \displayXCoord + \displayWide*10 + 13
				If override Then Goto skip1
; check to see if an arrow was hit,
; sets "arrowHit" to the number of the arrow that was clicked on
				If (\xcoord>=leftX) AND (\xcoord<=leftX+9)
						For i.b=0 To 4
								If (\ycoord>=localY+i*20) AND (\ycoord<=localY+9+i*20)
										If \scrollArrows[i+1]\displayed Then arrowHit = i+1
								End If
						Next i
				Else
						If (\xcoord>=riteX) AND (\xcoord<=riteX+9)
								For i.b=0 To 4
										If (\ycoord>=localY+i*20) AND (\ycoord<=localY+9+i*20)
												If \scrollArrows[i+6]\displayed Then arrowHit = i+6
										End If
								Next i
						End If
				End If
				Select arrowHit
					Case 1
						\leftHigh = \leftHigh-\displayHigh/2
						If \leftHigh<0 Then \leftHigh=0
					Case 2
						\leftHigh = \leftHigh-\displayHigh/2
						If \leftHigh<0 Then \leftHigh=0
						\leftWide = \leftWide-\displayWide/2
						If \leftWide<0 Then \leftWide=0
					Case 3
						\leftWide = \leftWide-\displayWide/2
						If \leftWide<0 Then \leftWide=0
					Case 4
						\leftHigh = \leftHigh+\displayHigh/2
						If \leftHigh>\high-\displayHigh Then \leftHigh=\high-\displayHigh
						\leftWide = \leftWide-\displayWide/2
						If \leftWide<0 Then \leftWide=0
					Case 5
						\leftHigh = \leftHigh+\displayHigh/2
						If \leftHigh>\high-\displayHigh Then \leftHigh=\high-\displayHigh
					Case 6
						\leftHigh = \leftHigh-\displayHigh/2
						If \leftHigh<0 Then \leftHigh=0
					Case 7
						\leftHigh = \leftHigh-\displayHigh/2
						If \leftHigh<0 Then \leftHigh=0
						\leftWide = \leftWide+\displayWide/2
						If \leftWide>\wide-\displayWide Then \leftWide=\wide-\displayWide
					Case 8
						\leftWide = \leftWide+\displayWide/2
						If \leftWide>\wide-\displayWide Then \leftWide=\wide-\displayWide
					Case 9
						\leftHigh = \leftHigh+\displayHigh/2
						If \leftHigh>\high-\displayHigh Then \leftHigh=\high-\displayHigh
						\leftWide = \leftWide+\displayWide/2
						If \leftWide>\wide-\displayWide Then \leftWide=\wide-\displayWide
					Case 10
						\leftHigh = \leftHigh+\displayHigh/2
						If \leftHigh>\high-\displayHigh Then \leftHigh=\high-\displayHigh
					Default
						Statement Return
				End Select
;redraw the grid
				For j.l=0 To \displayHigh-1
						For k.l=0 To \displayWide-1
								num = (j+\leftHigh)*\wide + k+\leftWide+1
								Select \square[num]\state
									Case 0
										DrawSquare{ *bombptr, 0, \displayXCoord+(k*10), \displayYCoord+(j*10)}
									Case 2
										If \square[num]\hasBomb=0
												bombNum.l = $EF
										Else
												bombNum = \square[num]\hasBomb
										End If
										DrawSquare{ *bombptr, bombNum, \displayXCoord+(k*10), \displayYCoord+(j*10)}
									Case 4
										DrawSquare{ *bombptr, 11, \displayXCoord+(k*10), \displayYCoord+(j*10)}
								End Select
						Next k
				Next j
skip1
;erase all scroll-arrows
				WBox leftX,localY, leftX+9,localY+89, 0
				WBox riteX,localY, riteX+9,localY+89, 0
				For i=1 To 10
						\scrollArrows[i]\displayed = False
				Next i
;draw the LHS arrows
				If \leftHigh>0
;draw the up arrows
						\scrollArrows[1]\displayed = True
						\scrollArrows[6]\displayed = True
						If \leftWide>0
;draw the up-left arrow
								\scrollArrows[2]\displayed = True
;draw the left arrow
								\scrollArrows[3]\displayed = True
						End If
						If \wide-\displayWide>\leftWide
;draw the up-right arrows
								\scrollArrows[7]\displayed = True
;draw the right arrow
								\scrollArrows[8]\displayed = True
						End If
				End If
				If \high-\displayHigh>\leftHigh
;draw the down arrows
						\scrollArrows[5]\displayed = True
						\scrollArrows[10]\displayed = True
						If \leftWide>0
;draw the down-left arrow
								\scrollArrows[4]\displayed = True
;draw the left arrow
								\scrollArrows[3]\displayed = True
						End If
						If \wide-\displayWide>\leftWide
;draw the down-right arrow
								\scrollArrows[9]\displayed = True
;draw the right arrow
								\scrollArrows[8]\displayed = True
						End If
				End If
				If \leftWide>0
;draw the left arrow
						\scrollArrows[3]\displayed = True
				End If
				If \wide-\displayWide>\leftWide
;draw the right arrow
						\scrollArrows[8]\displayed = True
				End If
;redraw the valid arrows
				For i=1 To 10
USEPATH *bombptr\scrollArrows[i]
						If \displayed Then WBlit \num, \xpos,\ypos
				Next i
		End If
End Statement	;DoScrolls

; =======================================

Statement InitScrolls{ *bombptr.gameVars}
; Initializes all variables for the scroll-arrows
InitScrolls
USEPATH *bombptr
		localY.w = \displayYCoord + \displayHigh*5 - 65
		leftX.w = \displayXCoord-23
		riteX.w = \displayXCoord + \displayWide*10 + 13
		For i.b=1 To 5
				\scrollArrows[i]\num = i+19
				\scrollArrows[i]\xpos = leftX
				\scrollArrows[i]\ypos = localY+i*20
		Next i
		For i.b=6 To 10
				\scrollArrows[i]\num = i+19
				\scrollArrows[i]\xpos = riteX
				\scrollArrows[i]\ypos = localY+(i-5)*20
		Next i
End Statement	;InitScrolls

;

;
; BombsGamePlay
;
; Created by ARV
;
; BLITZ2 Version
; last modified 28-09-1994

; =======================================

Statement SetupDisplay{ *bombptr.gameVars}
Shared gameStartTitle$
; Initializes a display and includes:-
;	 i	 screen, window, mouse-button input
;	 ii	mouse-pointer imagery
;	 iii titlebar, grid and scroll-arrows
SetupDisplay
USEPATH *bombptr
		Screen 1, 4, "BOMBS!"
		Use SetCycle 0
		DefaultIDCMP $8
		Window 1, 0, 0, 320, DispHeight, $800| $1000, "", 0, 1
		Handle 30, -8,-8
		Handle 31, -8,-8
		WPointer 30
		DisplayTitleBar{ *bombptr, gameStartTitle$}
		DrawGrid{ *bombptr}
		InitScrolls{ *bombptr}
		DoScrolls{ *bombptr, True}
End Statement	;SetupGrid

; =======================================

Statement SquareChecks{ *bombptr.gameVars}
; Checks are made for :-
;	 i	 any false bombs -> exit routine
;	 ii	any bombs to be found -> only if all unmarked squares
;			 must be bombs -> mark them and end the game
SquareChecks
USEPATH *bombptr
		If (\falseBombs=0) AND (\totalBombs=\totalSquares-\openedSquares)
				\gameInProgress = 3
				For i.l=1 To \totalSquares
						If (\square[i]\hasBomb<0) AND (\square[i]\state=0)
								\square[i]\state = 4
								\markedBombs = \markedBombs + 1
								xpos = \displayXCoord+(((i-1) MOD \wide)-\leftWide)*10
								ypos = \displayYCoord+(i/\wide-\leftHigh)*10
								If i MOD \wide=0 Then ypos = ypos - 10
								DrawSquare{ *bombptr, 11, xpos, ypos}
						End If
				Next i
				UpdateTitleBar{ *bombptr}
				UpdateProgressBar{ *bombptr}
				lastWin.l = Used Window
				If \rating>Val(\ratings[10]\value) Then TheScores{ *bombptr}
				Use Window lastWin
		End If
End Statement	;SquareChecks

; =======================================

Statement FreeupDisplay{ *bombptr.gameVars}
; Free up all memory in screens, windows etc that was used for the game
FreeupDisplay
USEPATH *bombptr
		Free Window 1
		Free Screen 1
End Statement	;FreeupDisplay

; =======================================

Statement FloodGrid{ *bombptr.gameVars, num.l}
Shared hold.holdtype()
; Opens all empty squares and their immediate neighbours
; Need "*bombptr" for general game settings
; Need "num" to denote the square to start with
FloodGrid
		If num=0 Then Statement Return
; Put the mouse to sleep - does not work yet!
		WPointer 31
USEPATH *bombptr
		totalHold.l = 1
		hold(1)\num = num
		hold(1)\hasBomb = 0
; CHANGE THE \xpos AND \ypos TO COORDINATES OF THE SQUARE RATHER THAN THE MOUSE-CLICK
		hold(1)\xpos = \displayXCoord+(((num-1) MOD \wide)-\leftWide)*10
		hold(1)\ypos = \displayYCoord+(num/\wide-\leftHigh)*10
		If num MOD \wide=0 Then hold(1)\ypos = hold(1)\ypos - 10
		\openedSquares = \openedSquares + 1
		\square[hold(1)\num]\state = 2
		DrawSquare{ *bombptr, $EF, hold(1)\xpos, hold(1)\ypos}

		While totalHold>0
; This always works on "hold(1)\..."
; Any extra squares to be added are added at the back as "hold(totalHold)\..."
				i = CheckTopLeft{ *bombptr, hold(1)\num, #peekState}
				If i=0
						CalcBombNum{ *bombptr, hold(1)\num-1-\wide}
						If \square[hold(1)\num-1-\wide]\hasBomb=0
								totalHold = totalHold + 1
								hold(totalHold)\num = hold(1)\num-1-\wide
								hold(totalHold)\hasBomb = 0
								hold(totalHold)\xpos = hold(1)\xpos - 10
								hold(totalHold)\ypos = hold(1)\ypos - 10
						End If
						\openedSquares = \openedSquares + 1
						\square[hold(1)\num-1-\wide]\state = 2
						bombNum = \square[hold(1)\num-1-\wide]\hasBomb
						If bombNum=0 Then bombNum = $EF
						DrawSquare{ *bombptr, bombNum, hold(1)\xpos-10, hold(1)\ypos-10}
				End If

				i = CheckTop{ *bombptr, hold(1)\num, #peekState}
				If i=0
						CalcBombNum{ *bombptr, hold(1)\num-\wide}
						If \square[hold(1)\num-\wide]\hasBomb=0
								totalHold = totalHold + 1
								hold(totalHold)\num = hold(1)\num-\wide
								hold(totalHold)\hasBomb = 0
								hold(totalHold)\xpos = hold(1)\xpos
								hold(totalHold)\ypos = hold(1)\ypos - 10
						End If
						\openedSquares = \openedSquares + 1
						\square[hold(1)\num-\wide]\state = 2
						bombNum = \square[hold(1)\num-\wide]\hasBomb
						If bombNum=0 Then bombNum = $EF
						DrawSquare{ *bombptr, bombNum, hold(1)\xpos, hold(1)\ypos-10}
				End If

				i = CheckTopRight{ *bombptr, hold(1)\num, #peekState}
				If i=0
						CalcBombNum{ *bombptr, hold(1)\num+1-\wide}
						If \square[hold(1)\num+1-\wide]\hasBomb=0
								totalHold = totalHold + 1
								hold(totalHold)\num = hold(1)\num+1-\wide
								hold(totalHold)\hasBomb = 0
								hold(totalHold)\xpos = hold(1)\xpos + 10
								hold(totalHold)\ypos = hold(1)\ypos - 10
						End If
						\openedSquares = \openedSquares + 1
						\square[hold(1)\num+1-\wide]\state = 2
						bombNum = \square[hold(1)\num+1-\wide]\hasBomb
						If bombNum=0 Then bombNum = $EF
						DrawSquare{ *bombptr, bombNum, hold(1)\xpos+10, hold(1)\ypos-10}
				End If

				i = CheckLeft{ *bombptr, hold(1)\num, #peekState}
				If i=0
						CalcBombNum{ *bombptr, hold(1)\num-1}
						If \square[hold(1)\num-1]\hasBomb=0
								totalHold = totalHold + 1
								hold(totalHold)\num = hold(1)\num-1
								hold(totalHold)\hasBomb = 0
								hold(totalHold)\xpos = hold(1)\xpos - 10
								hold(totalHold)\ypos = hold(1)\ypos
						End If
						\openedSquares = \openedSquares + 1
						\square[hold(1)\num-1]\state = 2
						bombNum = \square[hold(1)\num-1]\hasBomb
						If bombNum=0 Then bombNum = $EF
						DrawSquare{ *bombptr, bombNum, hold(1)\xpos-10, hold(1)\ypos}
				End If

				i = CheckRight{ *bombptr, hold(1)\num, #peekState}
				If i=0
						CalcBombNum{ *bombptr, hold(1)\num+1}
						If \square[hold(1)\num+1]\hasBomb=0
								totalHold = totalHold + 1
								hold(totalHold)\num = hold(1)\num+1
								hold(totalHold)\hasBomb = 0
								hold(totalHold)\xpos = hold(1)\xpos + 10
								hold(totalHold)\ypos = hold(1)\ypos
						End If
						\openedSquares = \openedSquares + 1
						\square[hold(1)\num+1]\state = 2
						bombNum = \square[hold(1)\num+1]\hasBomb
						If bombNum=0 Then bombNum = $EF
						DrawSquare{ *bombptr, bombNum, hold(1)\xpos+10, hold(1)\ypos}
				End If

				i = CheckBottomLeft{ *bombptr, hold(1)\num, #peekState}
				If i=0
						CalcBombNum{ *bombptr, hold(1)\num-1+\wide}
						If \square[hold(1)\num-1+\wide]\hasBomb=0
								totalHold = totalHold + 1
								hold(totalHold)\num = hold(1)\num-1+\wide
								hold(totalHold)\hasBomb = 0
								hold(totalHold)\xpos = hold(1)\xpos - 10
								hold(totalHold)\ypos = hold(1)\ypos + 10
						End If
						\openedSquares = \openedSquares + 1
						\square[hold(1)\num-1+\wide]\state = 2
						bombNum = \square[hold(1)\num-1+\wide]\hasBomb
						If bombNum=0 Then bombNum = $EF
						DrawSquare{ *bombptr, bombNum, hold(1)\xpos-10, hold(1)\ypos+10}
				End If

				i = CheckBottom{ *bombptr, hold(1)\num, #peekState}
				If i=0
						CalcBombNum{ *bombptr, hold(1)\num+\wide}
						If \square[hold(1)\num+\wide]\hasBomb=0
								totalHold = totalHold + 1
								hold(totalHold)\num = hold(1)\num+\wide
								hold(totalHold)\hasBomb = 0
								hold(totalHold)\xpos = hold(1)\xpos
								hold(totalHold)\ypos = hold(1)\ypos + 10
						End If
						\openedSquares = \openedSquares + 1
						\square[hold(1)\num+\wide]\state = 2
						bombNum = \square[hold(1)\num+\wide]\hasBomb
						If bombNum=0 Then bombNum = $EF
						DrawSquare{ *bombptr, bombNum, hold(1)\xpos, hold(1)\ypos+10}
				End If

				i = CheckBottomRight{ *bombptr, hold(1)\num, #peekState}
				If i=0
						CalcBombNum{ *bombptr, hold(1)\num+1+\wide}
						If \square[hold(1)\num+1+\wide]\hasBomb=0
								totalHold = totalHold + 1
								hold(totalHold)\num = hold(1)\num+1+\wide
								hold(totalHold)\hasBomb = 0
								hold(totalHold)\xpos = hold(1)\xpos + 10
								hold(totalHold)\ypos = hold(1)\ypos + 10
						End If
						\openedSquares = \openedSquares + 1
						\square[hold(1)\num+1+\wide]\state = 2
						bombNum = \square[hold(1)\num+1+\wide]\hasBomb
						If bombNum=0 Then bombNum = $EF
						DrawSquare{ *bombptr, bombNum, hold(1)\xpos+10, hold(1)\ypos+10}
				End If

; Take the last in the array and move it to the front
				hold(1)\num = hold(totalHold)\num
				hold(1)\hasBomb = hold(totalHold)\hasBomb
				hold(1)\xpos = hold(totalHold)\xpos
				hold(1)\ypos = hold(totalHold)\ypos
				totalHold = totalHold - 1
; One extra call to update the time
				UpdateTime{ *bombptr}
		Wend
		WPointer 30
End Statement	;FloodGrid

; =======================================

Statement LMBDownSquare{ *bombptr.gameVars}
; Displays one or more half-opened squares
; Keeps track of all these squares in "\downSquares[]"
LMBDownSquare
USEPATH *bombptr
		num.l = FindNum{ *bombptr}
		\downSquare[0]\num = 0
; first click
		If \square[num]\state=0
				\downSquare[1]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
				\downSquare[1]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
				\square[num]\state = 1
				\downSquare[0]\num = 1
				\downSquare[1]\num = num
				Gosub LMBDownDraw
		End If
; second click
		If \square[num]\state=2
				If CheckTopLeft{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num - 1 - \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 - 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 - 10
				End If
				If CheckTop{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num - \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 - 10
				End If
				If CheckTopRight{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num + 1 - \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 + 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 - 10
				End If
				If CheckLeft{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num - 1
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 - 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
				End If
				If CheckRight{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num + 1
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 + 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
				End If
				If CheckBottomLeft{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num - 1 + \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 - 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 + 10
				End If
				If CheckBottom{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num + \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 + 10
				End If
				If CheckBottomRight{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num + 1 + \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 + 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 + 10
				End If
		End If
		Gosub LMBDownDraw
		Statement Return

LMBDownDraw
		\LMBDownNum = num
		For i.b=1 To \downSquare[0]\num
				\square[\downSquare[i]\num]\state = 1
				DrawSquare{ *bombptr, 9, \downSquare[i]\xpos, \downSquare[i]\ypos}
		Next i
Return
End Statement	;LMBDownSquare

; =======================================

Statement LMBUpSquare{ *bombptr.gameVars, theRegion.b}
; If the button release was outside the button press square then it
; restores the pressed down squares, else
; it opens the square on the first click
; or the surrounding squares on the second click
LMBUpSquare
USEPATH *bombptr
		num.l = FindNum{ *bombptr}
		If num<>\LMBDownNum									; same as LMBDown?
				RestoreRegion{ *bombptr, theRegion}
		Else
		If \gameInProgress=0 Then \gameInProgress = 1
				Select \square[num]\state
					Case 2
; open all covered surrounding squares
						For i.b=1 To \downSquare[0]\num
								If \square[\downSquare[i]\num]\hasBomb=\bombs\typenr
										ShowAllBombs{ *bombptr, num}
								Else
										CalcBombNum{ *bombptr, \downSquare[i]\num}
										\openedSquares = \openedSquares + 1
										\square[\downSquare[i]\num]\state = 2
										If \square[\downSquare[i]\num]\hasBomb=0
												bombnum=$EF
										Else
												bombnum=\square[\downSquare[i]\num]\hasBomb
										End If
										DrawSquare{ *bombptr, bombnum, \downSquare[i]\xpos, \downSquare[i]\ypos}
								End If
						Next i
; Checks to see if we can flood the grid
						While \downSquare[0]\num>0
								If \square[\downSquare[\downSquare[0]\num]\num]\hasBomb=0
										\openedSquares = \openedSquares - 1
										FloodGrid{ *bombptr, \downSquare[\downSquare[0]\num]\num}
								End If
								\downSquare[0]\num = \downSquare[0]\num - 1
						Wend

					Case 1
						If \square[num]\hasBomb=\bombs\typenr
; it has a bomb
								ShowAllBombs{ *bombptr, num}
						Else
								CalcBombNum{ *bombptr, num}
								If \square[num]\hasBomb=0
; open all empty squares
										FloodGrid{ *bombptr, num}
								Else
; open the square
										xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
										ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
										\square[num]\state = 2
										\openedSquares = \openedSquares + 1
										DrawSquare{ *bombptr, \square[num]\hasBomb, xpos, ypos}
								End If
						End If
					Default
				End Select
		If \gameInProgress<2 Then SquareChecks{ *bombptr}
		End If
End Statement	;LMBUpSquare

; =======================================

Statement RMBDownSquare{ *bombptr.gameVars}
; Displays one or more half-opened squares
; Keeps track of all these squares in "\downSquares[]"
RMBDownSquare
USEPATH *bombptr
		num.l = FindNum{ *bombptr}
		\downSquare[0]\num = 0
		Select \square[num]\state
			Case 0
; first click
				\downSquare[1]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
				\downSquare[1]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
				\square[num]\state = 3
				\downSquare[0]\num = 1
				\downSquare[1]\num = num
				Gosub RMBDownDraw
			Case 2
; second click
				If CheckTopLeft{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num - 1 - \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 - 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 - 10
				End If
				If CheckTop{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num - \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 - 10
				End If
				If CheckTopRight{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num + 1 - \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 + 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 - 10
				End If
				If CheckLeft{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num - 1
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 - 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
				End If
				If CheckRight{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num + 1
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 + 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
				End If
				If CheckBottomLeft{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num - 1 + \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 - 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 + 10
				End If
				If CheckBottom{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num + \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 + 10
				End If
				If CheckBottomRight{ *bombptr, num, #peekState}=0
						\downSquare[0]\num = \downSquare[0]\num + 1
						\downSquare[\downSquare[0]\num]\num = num + 1 + \wide
						\downSquare[\downSquare[0]\num]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10 + 10
						\downSquare[\downSquare[0]\num]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10 + 10
				End If
				Gosub RMBDownDraw
			Case 4
				\downSquare[1]\xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
				\downSquare[1]\ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
				\downSquare[0]\num = 1
				\downSquare[1]\num = num
				Gosub RMBDownDraw
				\square[num]\state = 4
		End Select
		Statement Return

RMBDownDraw
		\RMBDownNum = num
		For i.b=1 To \downSquare[0]\num
				\square[\downSquare[i]\num]\state = 3
				DrawSquare{ *bombptr, 10, \downSquare[i]\xpos, \downSquare[i]\ypos}
		Next i
Return
End Statement	;RMBDownSquare

; =======================================

Statement RMBUpSquare{ *bombptr.gameVars, theRegion.b}
; If the square was marked then unmark it
; If the square was unmarked then mark it
; If the square was opened then mark all surrounding closed squares
; If the button release was at a different place from the
; button press then the squares are restored
RMBUpSquare
USEPATH *bombptr
		num.l = FindNum{ *bombptr}
		If num<>\RMBDownNum									; same as RMBDown?
				RestoreRegion{ *bombptr, theRegion}
		Else
				\gameInProgress = 1
				Select \square[num]\state
					Case 4
; unmark the square
						\square[num]\state = 0
						\markedBombs = \markedBombs - 1
						CheckMark{ *bombptr, num}
						xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
						ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
						DrawSquare{ *bombptr, 0, xpos, ypos}
					Case 3
; mark the square
						\square[num]\state = 4
						\markedBombs = \markedBombs + 1
						CheckMark{ *bombptr, num}
						xpos = \displayXCoord+((\xcoord-\displayXCoord)/10)*10
						ypos = \displayYCoord+((\ycoord-\displayYCoord)/10)*10
						DrawSquare{ *bombptr, 11, xpos, ypos}
					Case 2
; mark all surrounding closed squares
						For i.b=1 To \downSquare[0]\num
								\square[\downSquare[i]\num]\state = 4
								\markedBombs = \markedBombs + 1
								CheckMark{ *bombptr, \downSquare[i]\num}
								DrawSquare{ *bombptr, 11, \downSquare[i]\xpos, \downSquare[i]\ypos}
						Next i
					Default
				End Select
; redisplay the number of marked bombs
				UpdateTitleBar{ *bombptr}
		End If
End Statement	;RMBUpSquare

; =======================================

Statement HandleLMBDown{ *bombptr.gameVars, theRegion.b}
; Make intermediate drawings on the screen - no other changes
HandleLMBDown
USEPATH *bombptr
		Select theRegion
			Case #closeRegion						 ; CLOSE gadget
				\closeState = 1
				WBox 2,2, 18,18, 11
				WBlit 15-\closeState, 2,2
			Case #restartRegion					 ; RESTART gadget
				\restartState = 1
				WBox 38,2, 54,18, 11
				WBlit 19-\restartState, 38,2
			Case #gridRegion							; GRID
				If \gameInProgress<2
						LMBDownSquare{ *bombptr}
				End If
		End Select
End Statement	;HandleLMBDown

; =======================================

Function.b HandleLMBUp{ *bombptr.gameVars, theRegion.b}
; Any changes made are from the button releases
; The gadget or square must have been pressed down first
; or the area will be restored
; The only exception is the scroll arrows
; these do not have to be pressed down before, but
; only need a button release over them
;
; The return value indicates whether to keep playing (TRUE)
; or end the game (FALSE)
; Only the CLOSE Gadget will return FALSE
;
Shared gameStartTitle$
; Restore all regions and take appropriate actions
HandleLMBUp
USEPATH *bombptr
		If theRegion<>\LMBDownRegion
				RestoreRegion{ *bombptr, \LMBDownRegion}
		Else
				Select theRegion
					Case #closeRegion				 ; CLOSE gadget
						If (\rating>Val(\ratings[10]\value)) AND (\falseBombs=0) Then TheScores{ *bombptr}
						ResetVars{ *bombptr}
						WBox 2,2, 36,18, 11
						WBlit 15-\closeState, 2,2
						Function Return False

					Case #pauseRegion				 ; PAUSE gadget
						Select \gameInProgress
							Case 1
								\gameInProgress = 2
								\pauseState = 1-\pauseState
							Case 2
								\gameInProgress = 1
								\pauseState = 1-\pauseState
						End Select
						WBox 20,2, 36,18, 11
						WBlit 17-\pauseState, 20,2

					Case #restartRegion			 ; RESTART gadget
						If \restartState=1
								\restartState = 0
								WBox 38,2, 54,18, 11
								WBlit 19-\restartState, 38,2
								WBox \progressBar\xcoord,\progressBar\ycoord, \progressBar\xcoord+10,\progressBar\ycoord+10, 0
								ResetVars{ *bombptr}
								PlaceBombs{ *bombptr}
								DisplayTitleBar{ *bombptr, gameStartTitle$}
								DrawGrid{ *bombptr}
								UpdateProgressBar{ *bombptr}
								InitScrolls{ *bombptr}
								DoScrolls{ *bombptr, True}
						End If

					Case #gridRegion					; GRID
						If \gameInProgress<2
								LMBUpSquare{ *bombptr, theRegion}
						End If

					Default
						DoScrolls{ *bombptr, False}
				End Select
		End If
		Function Return True
End Function	;HandleLMBUp

; =======================================

Statement HandleRMBDown{ *bombptr.gameVars, theRegion.b}
; Make intermediate drawings on the screen - no other changes
HandleRMBDown
USEPATH *bombptr
		Select theRegion
			Case #closeRegion							 ; CLOSE gadget
				\closeState = 1
				WBox 2,2, 18,18, 11
				WBlit 15-\closeState, 2,2
			Case #restartRegion						 ; RESTART gadget
				\restartState = 1
				WBox 38,2, 54,18, 11
				WBlit 19-\restartState, 38,2
			Case #progressRegion						; PROGRESS BAR
			Case #gridRegion								; GRID
				If \gameInProgress<2
						RMBDownSquare{ *bombptr}
				End If
		End Select
End Statement	;HandleRMBDown

; =======================================

Function.b HandleRMBUp{ *bombptr.gameVars, theRegion.b}
; Any changes made are from the button releases
; The gadget or square must have been pressed down first
; or the area will be restored
; The only exception is the scroll arrows
; these do not have to be pressed down before, but
; only need a button release over them
;
; The return value indicates whether to keep playing (TRUE)
; or end the game (FALSE)
; Only the CLOSE Gadget will return FALSE
;
HandleRMBUp
USEPATH *bombptr
		If (theRegion<>\RMBDownRegion)
				RestoreRegion{ *bombptr, \RMBDownRegion}
		Else
				Select theRegion
					Case #closeRegion				 ; CLOSE gadget
						lastWin.l = Used Window
						If \rating>Val(\ratings[10]\value) Then TheScores{ *bombptr}
						Use Window lastWin
						ResetVars{ *bombptr}
						WBox 2,2, 36,18, 11
						WBlit 15-\closeState, 2,2
						Function Return False
					Case #pauseRegion				 ; PAUSE gadget
						Select \gameInProgress
							Case 1
								\gameInProgress = 2
								\pauseState = 1-\pauseState
							Case 2
								\gameInProgress = 1
								\pauseState = 1-\pauseState
						End Select
						WBox 20,2, 36,18, 11
						WBlit 17-\pauseState, 20,2
					Case #restartRegion			 ; RESTART gadget
						If \restartState=1
								\restartState = 0
								WBox 38,2, 54,18, 11
								WBlit 19-\restartState, 38,2
								WBox \progressBar\xcoord,\progressBar\ycoord, \progressBar\xcoord+10,\progressBar\ycoord+10, 0
								ResetVars{ *bombptr}
								PlaceBombs{ *bombptr}
								DisplayTitleBar{ *bombptr, gameStartTitle$}
								DrawGrid{ *bombptr}
								UpdateProgressBar{ *bombptr}
								InitScrolls{ *bombptr}
								DoScrolls{ *bombptr, True}
						End If
					Case #gridRegion					; GRID
						If \gameInProgress<2
								RMBUpSquare{ *bombptr, theRegion}
						End If
					Default
						DoScrolls{ *bombptr, False}
				End Select
		End If
		Function Return True
End Function	;HandleRMBUp

; =======================================

Function.b SelectRegion{ *bombptr.gameVars}
; Checks all regions and gadgets for mouse-clicks
; region 1 = CLOSE gadget
;				2 = PAUSE
;				3 = RESTART
;				4 = PROGRESS
;				5 = GRID
; All gadgets are hard coded, the grid depends on the display-settings
SelectRegion
USEPATH *bombptr
		theRegion.b = 0
		If (\ycoord>1) AND (\ycoord<19)							 ; gadgets
				If (\xcoord>1) AND (\xcoord<19)					 ; close
						theRegion = #closeRegion
				End If
				If (\xcoord>19) AND (\xcoord<37)					; pause
						theRegion = #pauseRegion
				End If
				If (\xcoord>37) AND (\xcoord<55)					; restart
						theRegion = #restartRegion
				End If
		End If
		If (\ycoord>\displayYCoord-24) AND (\ycoord<\displayYCoord-7)
				If (\xcoord>\displayXCoord-6) AND (\xcoord<\displayXCoord+10*\displayWide+6)
						theRegion = #progressRegion
; NOTE: This is here only as a safe-guard as there are no
;			 actions taken on clicks in this region
;			 Feel free to add your own, but add them also to
;			 "HandleLMB..." and "HandleRMB...",
;			 then call your routines
; Leave all the other regions alone or risk stuffing them up
				End If
		End If
		If (\ycoord>\displayYCoord) AND (\ycoord<\displayYCoord+10*\displayHigh)
				If (\xcoord>\displayXCoord) AND (\xcoord<\displayXCoord+10*\displayWide)
						theRegion = #gridRegion
				End If
		End If
		Function Return theRegion
End Function	;SelectRegion

; =======================================

Statement TheGame{ *bombptr.gameVars, *biptr.OSInput}
; Plays a game of BOMBS!
; Use the LMB to open a square
; Use the RMB to mark a square
.TheGame
; SETS ALL GAME VARIABLES LIKE BOMBS, NEIGHBOURS ETC
USEPATH *bombptr
		ResetVars{ *bombptr}
		PlaceBombs{ *bombptr}			; places bombs in the playing field
		SetupDisplay{ *bombptr}		; draws the grid
		Menus Off
		keep.b=True
		FlushEvents
		Repeat
				GetGameInput{ *biptr}
				Gosub GameEvents
		Until NOT keep
		Menus On
		FreeupDisplay{ *bombptr}
		Statement Return

.GameEvents
		\xcoord = *biptr\iMouseX
		\ycoord = *biptr\iMouseY

		theRegion.b = SelectRegion{ *bombptr}
		Select *biptr\code
			Case $68																	; LMB Down
				\LMBDownRegion = theRegion
				HandleLMBDown{ *bombptr, theRegion}
			Case $E8																	; LMB Up
				keep = HandleLMBUp{ *bombptr, theRegion}
			Case $69																	; RMB Down
				\RMBDownRegion = theRegion
				HandleRMBDown{ *bombptr, theRegion}
			Case $E9																	; RMB Up
				keep = HandleRMBUp{ *bombptr, theRegion}
		End Select
		UpdateTime{ *bombptr}
Return

End Statement	;TheGame

;